# === INICIO: .gitignore ===
project_snapshot.txt
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¬°Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Cach√© de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Cach√© de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querr√°s subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de c√≥digo
# Configuraciones espec√≠ficas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena pr√°ctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: Dockerfile ===
# Dockerfile
# Usamos alpine, que es muy ligero, por lo que tenemos que a√±adir paquetes
FROM python:3.11-alpine

# Instalamos las dependencias de sistema para psycopg2, adem√°s de netcat y git
RUN apk add --no-cache postgresql-libs netcat-openbsd git

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

COPY . .

# El entrypoint se define en docker-compose.yml,
# el CMD es el comando que se le pasa.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: NOTAS.md ===
## Telegram

### Mi ID de usuario (benabbhi)

1648877346

## Postgres

### Conectarse

```shell
docker-compose exec postgres psql -U runegram -d runegram_db
```
### Ver tablas

```
\dt
```

## Docker

### Prune

```shell
docker system prune -a --volumes
```

## TODO

* Las salas no muestran los objetos caidos
* Como se determina que comando le corresponde a quie?
* No se actualizan ambos extremos de las salidas
# === FIN: NOTAS.md ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

Runegram es un proyecto para crear un juego de rol textual multijugador (MUD - Multi-User Dungeon) que se juega a trav√©s de la interacci√≥n con un bot de Telegram. Este repositorio contiene el motor de un juego funcional, con una arquitectura escalable lista para la expansi√≥n masiva de contenido.

## Filosof√≠a de Dise√±o: Motor vs. Contenido

La arquitectura del proyecto se divide en dos conceptos clave para m√°xima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **c√≥digo fuente** de la aplicaci√≥n. Es la maquinaria gen√©rica que hace que el juego funcione (conexi√≥n a la base de datos, comunicaci√≥n con Telegram, ejecuci√≥n de l√≥gica). No sabe qu√© es una "espada", solo sabe c√≥mo manejar un "√çtem".
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** que dan vida al mundo. Aqu√≠ se define qu√© es una "espada", qu√© hace el comando "atacar", o qu√© monstruos existen. Est√° dise√±ado para que los dise√±adores de juego puedan a√±adir contenido sin tocar el motor principal.

## Sistemas Clave Implementados

### 1. Carga del Mundo Dirigida por Datos
El mundo est√°tico del juego ya no se construye con comandos de administrador, sino que se define enteramente en archivos de datos.

*   **Definici√≥n (`game_data/room_prototypes.py`):** Todas las salas, sus descripciones y las conexiones entre ellas se definen en un diccionario de Python. Esto act√∫a como el "mapa maestro" del mundo.
*   **Sincronizaci√≥n (`world_loader_service.py`):** Al iniciar el bot, un servicio dedicado lee estos prototipos, comprueba el estado de la base de datos y crea o actualiza las salas y salidas para que coincidan con la "fuente de la verdad". Esto garantiza un mundo consistente en cada reinicio.

### 2. Sistema de Comandos Din√°micos y Contextuales
La lista de comandos disponibles para un jugador no es est√°tica; cambia en tiempo real seg√∫n su contexto.

*   **M√∫ltiples Fuentes:** Un `command_service` centralizado construye la lista de `CommandSets` activos para un jugador a partir de:
    1.  **Base:** Comandos innatos del personaje, guardados en la base de datos.
    2.  **Equipo:** Objetos en el inventario que otorgan `CommandSets` (ej: unas ganz√∫as que otorgan el set `thievery`).
    3.  **Entorno:** La sala actual, que puede otorgar `CommandSets` (ej: una forja que otorga el set `smithing`).
    4.  **Rol:** Los administradores reciben sets de comandos especiales.
*   **Actualizaci√≥n en Telegram:** El motor actualiza la lista de comandos (`/`) en el cliente de Telegram del jugador en tiempo real, cada vez que su contexto cambia (al moverse de sala, coger un objeto, etc.), proporcionando una experiencia de usuario fluida e intuitiva.

### 3. Sistema Dual de Scripts: Eventos y Tickers
El motor permite que el contenido del juego ejecute l√≥gica a trav√©s de dos sistemas complementarios.

*   **Scripts Reactivos (Eventos):** Son disparados por acciones del jugador.
    *   **Trigger:** `"on_look": "script_nombre(...)"` en el prototipo de un objeto.
    *   **Ejecuci√≥n:** Cuando un jugador mira el objeto, el `script_service` ejecuta la funci√≥n correspondiente.
*   **Scripts Proactivos (Tickers):** Se ejecutan de forma programada, independientemente de la acci√≥n del jugador, haciendo que el mundo se sienta vivo.
    *   **Definici√≥n:** `"tickers": [{"schedule": "*/5 * * * *", "script": "...", "category": "ambient"}]`
    *   **Ejecuci√≥n:** Un `ticker_service` (usando `APScheduler`) se encarga de ejecutar estos scripts seg√∫n su horario (cron o intervalo).
    *   **Inteligencia:** Los tickers de categor√≠a `"ambient"` solo se ejecutan para jugadores considerados "activos", evitando notificar a usuarios que no est√°n jugando.

### 4. Sistema de Canales y Presencia
Para facilitar la comunicaci√≥n y la inmersi√≥n social, el juego implementa un sistema de canales y seguimiento de actividad.

*   **Seguimiento de Actividad (`online_service.py`):** Utilizando **Redis** para m√°xima velocidad, el motor registra un timestamp cada vez que un jugador env√≠a un comando. Si la √∫ltima actividad fue hace menos de 5 minutos, se le considera "online".
*   **Canales (`channel_service.py`):**
    *   Se definen en `game_data/channel_prototypes.py`.
    *   Los jugadores pueden suscribirse o desuscribirse (`/canal activar/desactivar`).
    *   Permiten comunicaci√≥n global (ej: `/novato [mensaje]`) entre todos los jugadores suscritos.
    *   El comando `/quien` utiliza el `online_service` para mostrar una lista de los jugadores activos.

## Estructura del Proyecto

```
runegram/
‚îú‚îÄ‚îÄ alembic/              # Migraciones de la base de datos
‚îú‚îÄ‚îÄ commands/             # DEFINICI√ìN de los comandos (clases Command)
‚îÇ   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îî‚îÄ‚îÄ player/
‚îú‚îÄ‚îÄ game_data/            # DEFINICI√ìN del contenido del juego
‚îÇ   ‚îú‚îÄ‚îÄ channel_prototypes.py # Define los canales de chat
‚îÇ   ‚îú‚îÄ‚îÄ item_prototypes.py    # Define los prototipos de objetos
‚îÇ   ‚îî‚îÄ‚îÄ room_prototypes.py    # Define el mapa del mundo (salas y salidas)
‚îú‚îÄ‚îÄ scripts/              # Scripts de utilidad (ej: full_reset.bat)
‚îú‚îÄ‚îÄ src/                  # C√ìDIGO FUENTE del motor de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ bot/
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ player/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ dispatcher.py # El router de comandos principal
‚îÇ   ‚îú‚îÄ‚îÄ models/           # Modelos de datos de SQLAlchemy
‚îÇ   ‚îú‚îÄ‚îÄ services/         # L√≥gica de negocio y acceso a datos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ broadcaster_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ channel_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ online_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ script_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticker_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ world_loader_service.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ .env                  # Archivo de variables de entorno (ignorado)
‚îú‚îÄ‚îÄ docker-compose.yml    # Orquestaci√≥n de los contenedores
‚îú‚îÄ‚îÄ Dockerfile            # Definici√≥n de la imagen Docker de la app
‚îú‚îÄ‚îÄ entrypoint.sh         # Script de arranque
‚îî‚îÄ‚îÄ run.py                # Punto de entrada
```

## Puesta en Marcha

Se necesita Docker y Docker Compose.

1.  **Configurar el Entorno:** Crea un archivo `.env` en la ra√≠z del proyecto a partir del `.env.example`.
2.  **Ejecutar el Script de Reinicio:** Para asegurar un entorno limpio, usa el script automatizado.
    ```bash
    # En Windows
    scripts\full_reset.bat
    ```
    Este script reconstruir√° la imagen, levantar√° los servicios y aplicar√° todas las migraciones.
3.  **Jugar:** Abre Telegram y env√≠a `/start` a tu bot.

---

## Visi√≥n a Futuro y Tareas Pendientes (TODO)

Esta secci√≥n documenta las pr√≥ximas mejoras para evolucionar de un motor robusto a un juego completo y pulido.

### üöÄ **Pr√≥ximas Grandes Funcionalidades**

*   #### **Sistema de Combate y Habilidades**
    *   **Visi√≥n:** Crear un sistema de combate y progresi√≥n de habilidades basado en una mec√°nica de d100 (tirada de 100 caras).
    *   **Tareas:**
        1.  **Modelos de Datos:** Crear los modelos `Skill` y `CharacterSkill`. A√±adir atributos de combate (Salud, Man√°, etc.) al modelo `Character`.
        2.  **Mec√°nica d100:** Implementar la l√≥gica de "aprender haciendo": una acci√≥n tiene √©xito si `d100 <= nivel_de_habilidad`, y al tener √©xito, se gana experiencia.
        3.  **PNJs y Spawners:** Crear `npc_prototypes.py`, un modelo `NPC` y un `npc_service` para poder "spawnear" monstruos en el mundo y gestionar su IA (agresiva, pasiva) y sus "respawns".
        4.  **Comandos de Combate:** Crear el `CommandSet` de combate (`/atacar`, `/huir`, etc.).

*   #### **Completar el Sistema de Locks y Permisos**
    *   **Visi√≥n:** Crear un sistema de permisos granular para controlar el acceso a salidas, objetos y comandos, yendo m√°s all√° del simple `rol()`.
    *   **Tareas:**
        1.  **Expandir el Parser:** Mejorar `permission_service` para que entienda una sintaxis rica: `tiene_objeto(llave_oxidada)`, `habilidad(forzar_cerraduras)>25`, `clase(guerrero)`. Implementar operadores l√≥gicos `y` / `o`.
        2.  **Integraci√≥n:** Aplicar la verificaci√≥n de `locks` en el `CmdMove` para las salidas y en el `dispatcher` para los comandos.

### ‚ú® **Mejoras del Motor y Calidad de Vida**

*   **Bandeja de Entrada para Notificaciones:** Para los tickers de categor√≠a `important` o `quest`, guardar los mensajes para los jugadores inactivos y present√°rselos cuando vuelvan a conectarse ("Mientras no estabas...").
*   **Sistema de Contenedores:** Expandir los √≠tems para que puedan ser contenedores (mochilas, cofres) con su propio inventario, capacidad y `locks`.
*   **Sistema de Clases y Razas:** Usar una **M√°quina de Estados Finitos (FSM)** para guiar al jugador a trav√©s de una creaci√≥n de personaje por pasos, permiti√©ndole elegir clase y raza, lo que a su vez establecer√° sus `CommandSets` base en la BD.
*   **Mejorar Comando `/decir`:** Hacer que el comando `/decir` y las acciones de combate env√≠en mensajes a todos los jugadores *online* en la misma sala, creando una verdadera interacci√≥n social.

### üåç **Contenido y Expansi√≥n del Mundo**

*Gracias a la arquitectura Data-Driven, expandir el mundo es ahora una tarea de dise√±o, no de programaci√≥n.*
*   **Crear Nuevos Prototipos:** Dise√±ar m√°s objetos, monstruos y PNJ en los archivos de `game_data`.
*   **Dise√±ar Zonas:** Expandir el `room_prototypes.py` para crear nuevas √°reas, ciudades y mazmorras.
*   **Escribir Quests:** Implementar PNJ que puedan dar misiones, utilizando el sistema de `FSM` para rastrear el progreso del jugador en una quest.
*   **Crear Habilidades y Clases:** Definir las habilidades disponibles en el juego y los `CommandSets` que cada clase aprender√° a medida que progrese.
# === FIN: README.md ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCI√ìN PRINCIPAL DE ALEMBIC
# Aqu√≠ se definen las configuraciones m√°s importantes.
# ==============================================================================
[alembic]

# --- Ubicaci√≥n de los Scripts de Migraci√≥n ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la ra√≠z del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA L√çNEA M√ÅS IMPORTANTE.
# Le dice a Alembic c√≥mo conectarse a tu base de datos PostgreSQL.
# La magia aqu√≠ es que no ponemos la contrase√±a directamente.
# El archivo `alembic/env.py` se encargar√° de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define c√≥mo se nombran los nuevos archivos de migraci√≥n.
# {rev} es el ID de la revisi√≥n, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos despu√©s de que se genera un nuevo archivo de migraci√≥n.
# Es muy √∫til para formatear autom√°ticamente el c√≥digo con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACI√ìN DE LOGGING
# Define c√≥mo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aqu√≠, la configuraci√≥n por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml

services:
  bot:
    # Construye la imagen a partir del Dockerfile en el directorio actual
    build: .

    # --- INICIO DE LA MODIFICACI√ìN ---
    # 1. ENTRYPOINT: Especifica el script que se ejecutar√° al iniciar el contenedor.
    #    Nuestro script /app/entrypoint.sh se encargar√° de esperar a la BD
    #    y ejecutar las migraciones.
    entrypoint: /app/entrypoint.sh

    # 2. COMMAND: Este comando ya no se ejecuta directamente. En su lugar,
    #    se pasa como argumento a nuestro entrypoint.sh. El script lo
    #    ejecutar√° al final con 'exec "$@"'.
    command: python run.py
    # --- FIN DE LA MODIFICACI√ìN ---

    environment:
      - PYTHONPATH=/app

    # Carga las variables de entorno desde el archivo .env
    env_file:
      - .env

    # Se asegura de que postgres y redis se inicien antes que el bot
    depends_on:
      - postgres
      - redis

    # Mapea tu c√≥digo local al contenedor para ver los cambios al instante
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      # Tambi√©n mapeamos el entrypoint para poder modificarlo sin reconstruir
      - ./entrypoint.sh:/app/entrypoint.sh

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: entrypoint.sh ===
#!/bin/sh

# Salimos inmediatamente si un comando falla
set -e

echo "--- Esperando a que PostgreSQL est√© disponible... ---"
# El host 'postgres' es el nombre del servicio en docker-compose.yml
# Bucle hasta que el puerto 5432 de postgres est√© abierto
while ! nc -z postgres 5432; do
  sleep 0.1
done
echo "--- PostgreSQL est√° listo. ---"

echo "--- Ejecutando migraciones de la base de datos... ---"
alembic upgrade head

echo "--- ¬°Migraciones completadas! Iniciando el bot... ---"
# 'exec "$@"' ejecuta el comando que se le pasa al script.
# En nuestro caso, ser√° 'python run.py'
exec "$@"
# === FIN: entrypoint.sh ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
APScheduler==3.10.1
python-dateutil
psycopg2-binary==2.9.9
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
import logging
import asyncio
import sys
from aiogram import executor

from src.bot.dispatcher import dp
# Importamos todos los servicios necesarios para el arranque
from src.services import world_loader_service, ticker_service
from src.db import async_session_factory

import src.handlers

async def on_startup(dispatcher):
    logging.info("Bot iniciando...")

    # Paso 1: Iniciamos el scheduler (el motor de tareas programadas)
    ticker_service.initialize_scheduler()

    async with async_session_factory() as session:
        # Sincronizamos el mundo est√°tico (salas y salidas)
        await world_loader_service.sync_world_from_prototypes(session)

        # Paso 2: Cargamos los tickers de entidades que ya existen en la BD
        await ticker_service.load_and_schedule_all_tickers(session)

    logging.info("Ejecuci√≥n de startup finalizada. El bot est√° en l√≠nea.")

async def on_shutdown(dispatcher):
    logging.warning("Bot deteni√©ndose...")
    # Es una buena pr√°ctica apagar el scheduler de forma limpia
    ticker_service.scheduler.shutdown()

def main():
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s [%(levelname)s] - %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)

if __name__ == "__main__":
    main()
# === FIN: run.py ===


# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACI√ìN DEL PATH ---
# A√±ade el directorio ra√≠z del proyecto al sys.path para que Python
# pueda encontrar nuestros m√≥dulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACI√ìN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneraci√≥n
# y la configuraci√≥n (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---
# Aqu√≠ sobrescribimos la URL de la base de datos que est√° en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuraci√≥n de la aplicaci√≥n.
# Esto centraliza la configuraci√≥n y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Funci√≥n auxiliar que Alembic ejecutar√° de forma s√≠ncrona
    una vez que la conexi√≥n as√≠ncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor as√≠ncrono
    # a partir de la URL de nuestra configuraci√≥n.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma as√≠ncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""A√±adir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser m√°s expl√≠citos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # Nota: La columna 'exits' de tipo JSONB ser√° eliminada por una migraci√≥n posterior,
        # as√≠ que la dejamos aqu√≠ por ahora para mantener la consistencia hist√≥rica.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # A√±adimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Rellenamos las filas existentes con un ID de sala por defecto (1).
    # Esto es necesario para que la siguiente l√≠nea (nullable=False) no falle en bases de datos existentes.
    # El `create_character` service y el `world_loader` aseguran que la sala con ID 1 (limbo) exista.
    op.execute('UPDATE characters SET room_id = 1 WHERE room_id IS NULL')

    # Ahora s√≠, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final.
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""A√±adir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""A√±adir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===
# alembic/script.py.mako

"""A√±adir key a las salas para prototipos

Revision ID: cdb486941d55
Revises: 57531370cbd7
Create Date: 2025-09-30 12:53:43.463923+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cdb486941d55'
down_revision = '57531370cbd7'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('key', sa.String(length=50), nullable=True))
    op.create_index(op.f('ix_rooms_key'), 'rooms', ['key'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_rooms_key'), table_name='rooms')
    op.drop_column('rooms', 'key')
    # ### end Alembic commands ###
# === FIN: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===


# === INICIO: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===
"""Crear tabla para apscheduler jobs

Revision ID: db2dac1704aa
Revises: cdb486941d55
Create Date: <LA FECHA SE GENERA AUTOM√ÅTICAMENTE>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db2dac1704aa'
down_revision = 'cdb486941d55'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Crea la tabla 'apscheduler_jobs' con el esquema exacto que espera
    la librer√≠a APScheduler para su SQLAlchemyJobStore.
    """
    op.create_table(
        'apscheduler_jobs',
        sa.Column('id', sa.Unicode(191), primary_key=True),
        sa.Column('next_run_time', sa.Float(25), index=True),
        sa.Column('job_state', sa.LargeBinary, nullable=False)
    )


def downgrade() -> None:
    """
    Elimina la tabla 'apscheduler_jobs' si se revierte la migraci√≥n.
    """
    op.drop_table('apscheduler_jobs')
# === FIN: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===


# === INICIO: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===
# alembic/script.py.mako

"""Crear tabla de configuraciones de personaje

Revision ID: f17a871c68a1
Revises: db2dac1704aa
Create Date: 2025-09-30 14:49:51.717892+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'f17a871c68a1'
down_revision = 'db2dac1704aa'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('character_settings',
    sa.Column('character_id', sa.BigInteger(), nullable=False),
    sa.Column('active_channels', postgresql.JSONB(astext_type=sa.Text()), server_default='{}', nullable=False),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.PrimaryKeyConstraint('character_id')
    )
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    op.drop_table('character_settings')
    # ### end Alembic commands ###
# === FIN: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    accounts_table = op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

    # --- INICIO DE LA SECCI√ìN DE SEEDING ---
    # Aqu√≠ insertamos la cuenta del administrador despu√©s de crear la tabla.
    # Usamos op.bulk_insert para a√±adir datos de forma segura dentro de una migraci√≥n.
    op.bulk_insert(accounts_table,
        [
            {'telegram_id': 1648877346, 'role': 'ADMINISTRADOR'},
        ]
    )
    # --- FIN DE LA SECCI√ìN DE SEEDING ---

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # --- SECCI√ìN DE SEEDING (INVERSA) ---
    # Si hacemos downgrade, tambi√©n eliminamos los datos que a√±adimos.
    op.execute("DELETE FROM accounts WHERE telegram_id = 1648877346")
    # --- FIN DE LA SECCI√ìN DE SEEDING ---

    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===


# === INICIO: commands/__init__.py ===
# === FIN: commands/__init__.py ===


# === INICIO: commands/command.py ===
# commands/command.py
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character

class Command:
    """Clase base para todos los comandos del juego."""
    lock: str = ""
    description: str = "Un comando sin descripci√≥n."

    def __init__(self, names: list[str] = None, description: str = None):
        """
        Inicializador para permitir la creaci√≥n de instancias de comandos
        con alias y descripciones din√°micas.
        """
        if names:
            self.names = names
        elif not hasattr(self, 'names'):
            self.names = []

        if description:
            self.description = description
        elif not hasattr(self, 'description'):
            self.description = "Un comando sin descripci√≥n."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """El m√©todo que se ejecuta cuando se llama al comando."""
        raise NotImplementedError
# === FIN: commands/command.py ===


# === INICIO: commands/admin/__init__.py ===

from . import building
from . import movement
from . import info
# === FIN: commands/admin/__init__.py ===


# === INICIO: commands/admin/building.py ===
# src/commands/admin/building.py
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from commands.command import Command
from src.models.character import Character
from src.services import item_service
from game_data.item_prototypes import ITEM_PROTOTYPES

class CmdGenerarObjeto(Command):
    names = ["generarobjeto", "genobj"]
    lock = "rol(ADMINISTRADOR)"
    description = "Genera un objeto en la sala a partir de su clave de prototipo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            return await message.answer("Uso: /generarobjeto [key_del_prototipo]")

        item_key = args[0].lower()
        try:
            item = await item_service.spawn_item_in_room(session, character.room_id, item_key)
            item_name = ITEM_PROTOTYPES.get(item.key, {}).get("name", "un objeto desconocido")
            await message.answer(f"‚úÖ Objeto '{item_name}' generado en la sala actual.")
        except ValueError as e:
            await message.answer(f"‚ùå Error: {e}")

# Exportamos el nuevo set de comandos de "spawning"
SPAWN_COMMANDS = [
    CmdGenerarObjeto(),
    # Aqu√≠ podr√≠as a√±adir /generarnpc en el futuro
]
# === FIN: commands/admin/building.py ===


# === INICIO: commands/admin/info.py ===
# commands/admin/info.py
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character, Room

class CmdListarSalas(Command):
    names = ["listarsalas", "lsalas"]
    lock = "rol(ADMINISTRADOR)"
    description = "Muestra ID, Clave y Nombre de todas las salas del mundo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """Muestra una lista de todas las salas del juego con su ID, Key y Nombre."""

        result = await session.execute(select(Room).order_by(Room.id))
        all_rooms = result.scalars().all()

        if not all_rooms:
            return await message.answer("No se encontraron salas en la base de datos.")

        # Construimos el cuerpo del mensaje
        response_lines = ["<b>Lista de Salas del Mundo:</b>"]
        for room in all_rooms:
            # Ya no necesitamos <code> en cada l√≠nea, <pre> se encargar√° del formato
            response_lines.append(f"ID: {room.id:<4} | Key: {room.key:<20} | Nombre: {room.name}")

        body = "\n".join(response_lines)

        # Envolvemos el cuerpo completo en una etiqueta <pre>
        response_text = f"<pre>{body}</pre>"

        # Usamos parse_mode HTML para que Telegram interprete las etiquetas
        await message.answer(response_text, parse_mode="HTML")

# Exportamos el nuevo set de comandos de informaci√≥n
INFO_COMMANDS = [
    CmdListarSalas(),
]
# === FIN: commands/admin/info.py ===


# === INICIO: commands/admin/movement.py ===
# src/commands/admin/movement.py
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service
from src.utils.presenters import show_current_room

class CmdTeleport(Command):
    names = ["teleport", "tp"]
    lock = "rol(ADMINISTRADOR)"
    description = "Teletransp√≥rtate a cualquier sala usando su ID."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            return await message.answer("Uso: /teleport [ID_sala]")

        try:
            to_room_id = int(args[0])
        except (ValueError, IndexError):
            return await message.answer("El ID de la sala debe ser un n√∫mero.")

        try:
            await player_service.teleport_character(session, character.id, to_room_id)
            await message.answer(f"üöÄ Teletransportado a la sala {to_room_id}.")
            await show_current_room(message)
        except Exception as e:
            await message.answer(f"‚ùå Error al teletransportar: {e}")

# --- Exportaci√≥n del Command Set ---
ADMIN_MOVEMENT_COMMANDS = [CmdTeleport()]
# === FIN: commands/admin/movement.py ===


# === INICIO: commands/player/__init__.py ===
from . import general
from . import character
from . import interaction
from . import movement
from . import channels
# === FIN: commands/player/__init__.py ===


# === INICIO: commands/player/channels.py ===
# commands/player/channels.py
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdChannel(Command):
    names = ["canal"]
    description = "Activa o desactiva un canal. Uso: /canal [activar|desactivar] [nombre]."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args or len(args) < 2 or args[0].lower() not in ["activar", "desactivar"]:
            await message.answer("Uso: /canal [activar|desactivar] [nombre_canal]")
            return

        action = args[0].lower()
        channel_key = args[1].lower()

        try:
            await channel_service.set_channel_status(session, character, channel_key, activate=(action == "activar"))
            await message.answer(f"‚úÖ Has {action}do el canal '{channel_key}'.")
        except ValueError as e:
            await message.answer(f"‚ùå Error: {e}")

class CmdChannels(Command):
    names = ["canales"]
    description = "Muestra los canales disponibles y su estado (activado/desactivado)."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        settings = await channel_service.get_or_create_settings(session, character)
        user_channels = settings.active_channels.get("active_channels", [])

        response = ["<b>Estado de tus Canales:</b>"]
        for key, proto in CHANNEL_PROTOTYPES.items():
            status = "‚úÖ Activado" if key in user_channels else "‚ùå Desactivado"
            response.append(f"- <b>{proto['name']}</b> ({key}): {status}\n  <i>{proto['description']}</i>")

        await message.answer("\n".join(response), parse_mode="HTML")


class CmdNovato(Command):
    names = ["novato"]
    lock = ""
    description = "Env√≠a un mensaje por el canal de ayuda para novatos."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            return await message.answer("Uso: /novato [mensaje]")

        settings = await channel_service.get_or_create_settings(session, character)
        if not await channel_service.is_channel_active(settings, "novato"):
            return await message.answer("Tienes el canal 'novato' desactivado. Act√≠valo con:\n/canal activar novato")

        channel_message = f"[{character.name}] {' '.join(args)}"
        await channel_service.broadcast_to_channel(session, "novato", channel_message, exclude_character_id=character.id)
        # Confirmaci√≥n para el que env√≠a el mensaje
        await message.answer(f"üì¢ <b>Novato:</b> {channel_message}", parse_mode="HTML")

CHANNEL_COMMANDS = [
    CmdChannel(),
    CmdChannels(),
    CmdNovato(),
]
# === FIN: commands/player/channels.py ===


# === INICIO: commands/player/character.py ===
# commands/player/character.py
import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service

class CmdCreateCharacter(Command):
    names = ["crearpersonaje"]
    description = "Crea tu personaje para empezar a jugar."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if character:
            return await message.answer("Ya tienes un personaje.")

        character_name = " ".join(args)
        if not character_name or len(character_name) > 50:
            return await message.answer("Por favor, proporciona un nombre v√°lido (m√°x 50 caracteres). Uso: /crearpersonaje [nombre]")

        try:
            new_char = await player_service.create_character(session, message.from_user.id, character_name)
            await message.answer(
                f"¬°Tu personaje, {new_char.name}, ha sido creado con √©xito!\n"
                "Ahora est√°s listo para explorar el mundo de Runegram. ¬°Env√≠a /start para comenzar!"
            )
        except ValueError as e:
            await message.answer(f"No se pudo crear el personaje: {e}")
        except Exception as e:
            await message.answer("Ocurri√≥ un error inesperado al crear tu personaje.")

            # --- MEJORA DE LOGGING CLAVE ---
            # Reemplazamos el print() por logging.exception() para obtener el traceback completo.
            logging.exception(f"Error finalizando la creaci√≥n del personaje para {message.from_user.id}")

# --- Exportaci√≥n del Command Set ---
CHARACTER_COMMANDS = [CmdCreateCharacter()]
# === FIN: commands/player/character.py ===


# === INICIO: commands/player/general.py ===
# commands/player/general.py
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.utils.presenters import show_current_room
from src.services import script_service, online_service

class CmdLook(Command):
    names = ["mirar", "m", "l"]
    lock = ""
    description = "Observa tu entorno o un objeto/personaje espec√≠fico."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        if not args:
            await show_current_room(message)
            return

        target_name = " ".join(args).lower()
        found_target = None

        for item in character.room.items:
            if target_name in item.get_keywords() or target_name in item.get_name().lower():
                found_target = item
                break

        if not found_target:
            for item in character.items:
                if target_name in item.get_keywords() or target_name in item.get_name().lower():
                    found_target = item
                    break

        if not found_target:
            return await message.answer("No ves eso por aqu√≠.")

        await message.answer(f"<pre>{found_target.get_description()}</pre>", parse_mode="HTML")

        if "on_look" in found_target.prototype.get("scripts", {}):
            await script_service.execute_script(
                script_string=found_target.prototype["scripts"]["on_look"],
                session=session,
                character=character,
                target=found_target
            )

class CmdSay(Command):
    names = ["decir", "'"]
    lock = ""
    description = "Habla con las personas que est√°n en tu misma sala."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            return await message.answer("¬øQu√© quieres decir?")
        say_text = " ".join(args)
        await message.answer(f"Dices: {say_text}")

class CmdInventory(Command):
    names = ["inventario", "inv", "i"]
    lock = ""
    description = "Muestra los objetos que llevas en tu inventario."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        inventory = character.items
        if not inventory:
            response = "No llevas nada."
        else:
            items_list = [f" - {item.get_name()}" for item in inventory]
            items_str = "\n".join(items_list)
            response = f"<b>Llevas lo siguiente:</b>\n{items_str}"

        await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")

class CmdHelp(Command):
    names = ["ayuda", "help"]
    lock = ""
    description = "Muestra una lista con los comandos b√°sicos del juego."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        help_text = (
            "<b>Comandos B√°sicos de Runegram</b>\n"
            "---------------------------------\n"
            "/mirar - Muestra la descripci√≥n de tu entorno.\n"
            "/inventario - Muestra los objetos que llevas.\n"
            "/decir [mensaje] - Hablas a la gente en tu misma sala.\n"
            "/coger [objeto] - Recoges un objeto del suelo.\n"
            "/dejar [objeto] - Dejas un objeto que llevas.\n"
            "/quien - Muestra qui√©n est√° conectado.\n\n"
            "Para moverte, usa /norte, /sur, etc."
        )
        await message.answer(f"<pre>{help_text}</pre>", parse_mode="HTML")

class CmdWho(Command):
    names = ["quien", "who"]
    lock = ""
    description = "Muestra una lista de los jugadores conectados."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """Muestra una lista de los jugadores actualmente en l√≠nea."""

        online_characters = await online_service.get_online_characters(session)

        if not online_characters:
            return await message.answer("Eres la √∫nica alma aventurera en este mundo ahora mismo.")

        # Excluimos al propio jugador de la cuenta si solo hay una persona
        if len(online_characters) == 1 and online_characters[0].id == character.id:
            return await message.answer("Eres la √∫nica alma aventurera en este mundo ahora mismo.")

        response_lines = [f"<b>Hay {len(online_characters)} aventureros en Runegram:</b>"]
        for char in sorted(online_characters, key=lambda c: c.name):
            response_lines.append(f"- {char.name}")

        response_text = "\n".join(response_lines)
        await message.answer(f"<pre>{response_text}</pre>", parse_mode="HTML")


# --- Exportaci√≥n del Command Set (Actualizado) ---
GENERAL_COMMANDS = [CmdLook(), CmdSay(), CmdInventory(), CmdHelp(), CmdWho()]
# === FIN: commands/player/general.py ===


# === INICIO: commands/player/interaction.py ===
# commands/player/interaction.py

from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service, command_service, player_service


class CmdGet(Command):
    names = ["coger", "g"]
    lock = ""
    description = "Recoge un objeto del suelo."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        if not args:
            return await message.answer("¬øQu√© quieres coger?")

        item_name_to_get = " ".join(args).lower()
        item_to_get = None

        for item in character.room.items:
            if item_name_to_get in item.get_name().lower():
                item_to_get = item
                break

        if not item_to_get:
            return await message.answer("No ves eso por aqu√≠.")

        await item_service.move_item_to_character(session, item_to_get.id, character.id)

        # Si el objeto que cogimos otorga un command set, actualizamos la lista en Telegram.
        if item_to_get.prototype.get("grants_command_sets"):
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            await command_service.update_telegram_commands(refreshed_character)

        await message.answer(f"Has cogido: {item_to_get.get_name()}")


class CmdDrop(Command):
    names = ["dejar", "d"]
    lock = ""
    description = "Deja un objeto de tu inventario en el suelo."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        if not args:
            return await message.answer("¬øQu√© quieres dejar?")

        item_name_to_drop = " ".join(args).lower()
        item_to_drop = None

        for item in character.items:
            if item_name_to_drop in item.get_name().lower():
                item_to_drop = item
                break

        if not item_to_drop:
            return await message.answer("No llevas eso.")

        await item_service.move_item_to_room(session, item_to_drop.id, character.room_id)

        # Si el objeto que dejamos otorgaba un command set, actualizamos la lista en Telegram.
        if item_to_drop.prototype.get("grants_command_sets"):
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            await command_service.update_telegram_commands(refreshed_character)

        await message.answer(f"Has dejado: {item_to_drop.get_name()}")


# --- Exportaci√≥n del Command Set ---
INTERACTION_COMMANDS = [
    CmdGet(),
    CmdDrop(),
]
# === FIN: commands/player/interaction.py ===


# === INICIO: commands/player/movement.py ===
# commands/player/movement.py
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service # Importamos command_service
from src.utils.presenters import show_current_room

class CmdMove(Command):
    """
    Comando gen√©rico para manejar todo el movimiento.
    """
    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        direction = self.names[0]
        target_exit = next(
            (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == direction),
            None
        )

        if not target_exit:
            return await message.answer("No puedes ir en esa direcci√≥n.")

        await player_service.teleport_character(session, character.id, target_exit.to_room_id)

        # Despu√©s de movernos, actualizamos la lista de comandos de Telegram
        # ya que la nueva sala podr√≠a otorgar nuevos comandos.
        refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
        await command_service.update_telegram_commands(refreshed_character)

        await show_current_room(message)

# --- Creaci√≥n del Command Set con descripciones ---
MOVEMENT_COMMANDS = [
    CmdMove(names=["norte", "n"], description="Moverse hacia el norte."),
    CmdMove(names=["sur", "s"], description="Moverse hacia el sur."),
    CmdMove(names=["este", "e"], description="Moverse hacia el este."),
    CmdMove(names=["oeste", "o"], description="Moverse hacia el oeste."),
    CmdMove(names=["arriba", "ar"], description="Moverse hacia arriba."),
    CmdMove(names=["abajo", "ab"], description="Moverse hacia abajo."),
    CmdMove(names=["noreste", "ne"], description="Moverse hacia el noreste."),
    CmdMove(names=["noroeste", "no"], description="Moverse hacia el noroeste."),
    CmdMove(names=["sureste", "se"], description="Moverse hacia el sureste."),
    CmdMove(names=["suroeste", "so"], description="Moverse hacia el suroeste."),
]
# === FIN: commands/player/movement.py ===


# === INICIO: game_data/__init__.py ===
# === FIN: game_data/__init__.py ===


# === INICIO: game_data/channel_prototypes.py ===
# game_data/channel_prototypes.py

CHANNEL_PROTOTYPES = {
    "novato": {
        "name": "Novato",
        "icon": "üì¢",
        "description": "Un canal para que los nuevos aventureros pidan ayuda.",
        # 'CHAT' permite a los jugadores enviar mensajes con /novato
        # 'BROADCAST' ser√≠a solo para anuncios del sistema.
        "type": "CHAT",
        # Los nuevos personajes tendr√°n este canal activado por defecto.
        "default_on": True,
    },
    # --- Futuros canales podr√≠an ir aqu√≠ ---
    # "comercio": {
    #     "name": "Comercio",
    #     "icon": "üí∞",
    #     "description": "Para comprar y vender objetos con otros jugadores.",
    #     "type": "CHAT",
    #     "default_on": True,
    # },
    # "anuncios": {
    #     "name": "Anuncios",
    #     "icon": "üìú",
    #     "description": "Noticias y eventos importantes del mundo.",
    #     "type": "BROADCAST",
    #     "default_on": True,
    # }
}
# === FIN: game_data/channel_prototypes.py ===


# === INICIO: game_data/item_prototypes.py ===
# game_data/item_prototypes.py

ITEM_PROTOTYPES = {
    "espada_viviente": {
        "name": "una espada viviente",
        "description": "La hoja de acero parece retorcerse y susurrarte secretos.",
        "scripts": {
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        },
        "tickers": [
            {
                "schedule": "*/2 * * * *",
                "script": "script_espada_susurra_secreto",
                # Categoriza este ticker como "de ambiente".
                # El sistema lo ignorar√° para jugadores inactivos.
                "category": "ambient"
            }
        ]
    },

    "corazon_sangrante": {
        "name": "un coraz√≥n sangrante",
        "description": "Late d√©bilmente y gotea un icor oscuro.",
        "tickers": [
            {
                "schedule": "interval:30",
                "script": "script_objeto_sangra_en_el_suelo",
                "category": "ambient"
            }
        ]
    }
}
# === FIN: game_data/item_prototypes.py ===


# === INICIO: game_data/room_prototypes.py ===
# game_data/room_prototypes.py

# Este diccionario es la "Fuente de la Verdad" para todas las salas del juego.
# La clave (ej: "limbo") es un identificador √∫nico que NUNCA debe cambiar.
ROOM_PROTOTYPES = {
    "limbo": {
        "name": "El Limbo",
        "description": "Te encuentras en una habitaci√≥n vac√≠a, suspendida en la nada. Es el comienzo de tu aventura y un refugio seguro.",
        "exits": {
            # "direcci√≥n": "clave_de_la_sala_destino"
            "norte": "plaza_central"
        }
    },
    "plaza_central": {
        "name": "Plaza Central de Runegard",
        "description": "Est√°s en el coraz√≥n de la ciudad. El bullicio de mercaderes y aventureros llena el aire. Varios caminos parten desde aqu√≠.",
        "exits": {
            # El cargador crear√° autom√°ticamente la salida 'sur' de vuelta al 'limbo'.
            "este": "calle_mercaderes"
        }
    },
    "calle_mercaderes": {
        "name": "Calle de los Mercaderes",
        "description": "Decenas de puestos se alinean en esta calle, ofreciendo todo tipo de mercanc√≠as ex√≥ticas.",
        "exits": {
            # El cargador crear√° 'oeste' de vuelta a 'plaza_central'.
        }
    }
}
# === FIN: game_data/room_prototypes.py ===


# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
CLS
ECHO.
ECHO ##################################################################
ECHO #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO ##################################################################
ECHO.
ECHO ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES:
ECHO   1. Detendra y eliminara todos los contenedores y el volumen de la BD.
ECHO   2. Reconstruira la imagen del bot y levantara todos los servicios.
ECHO.
ECHO Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.

PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen... ---
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo y levantando servicios... ---
docker-compose up --build -d

ECHO.
ECHO ##################################################################
ECHO #                ¬°PROCESO COMPLETADO CON EXITO!                  #
ECHO ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/generate_snapshot.py ===
# scripts/generate_snapshot.py

import os
from pathlib import Path

# --- CONFIGURACI√ìN ---

# Directorio ra√≠z del proyecto (sube dos niveles desde este script)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# Nombre del archivo de salida
OUTPUT_FILENAME = "project_snapshot.txt"

# --- LISTA NEGRA: Directorios y archivos a IGNORAR SIEMPRE ---
# Usamos sets para una b√∫squeda m√°s eficiente.
EXCLUDED_DIRS = {
    ".git",
    ".idea",
    ".vscode",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    "postgres_data",
    "node_modules",
}

EXCLUDED_FILES = {
    ".env",
    OUTPUT_FILENAME,
    "poetry.lock",
    "Pipfile.lock",
}

# Extensiones de archivo a ignorar (ej: binarios, compilados)
EXCLUDED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".egg-info",
    ".swp",
    ".db",
    ".sqlite3",
}

# --- FIN DE LA CONFIGURACI√ìN ---


def write_file_content(output_file, file_path):
    """Escribe el contenido de un archivo en el archivo de salida, con un encabezado."""
    # Obtenemos la ruta relativa usando el est√°ndar POSIX (barras /)
    relative_path = file_path.relative_to(PROJECT_ROOT).as_posix()
    print(f"  -> A√±adiendo: {relative_path}")

    header = f"# === INICIO: {relative_path} ===\n"
    footer = f"# === FIN: {relative_path} ===\n\n\n"

    output_file.write(header)
    try:
        # Leemos el contenido del archivo
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            # A√±adimos un salto de l√≠nea al final si no lo tiene, para un formato limpio
            if content and not content.endswith('\n'):
                content += '\n'
            output_file.write(content)
    except Exception as e:
        output_file.write(f"*** No se pudo leer el archivo: {e} ***\n")
    output_file.write(footer)


def main():
    """Funci√≥n principal para generar el snapshot del proyecto."""
    output_path = PROJECT_ROOT / OUTPUT_FILENAME
    print(f"Generando snapshot del proyecto en: {output_path}\n")

    # Usaremos una lista para almacenar las rutas de los archivos a incluir
    files_to_process = []

    # os.walk recorre todos los directorios y archivos desde la ra√≠z del proyecto
    for root, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        # Modificamos la lista de directorios 'in-place' para evitar que os.walk entre en ellos
        dirs[:] = [d for d in sorted(dirs) if d not in EXCLUDED_DIRS]

        # Procesamos los archivos del directorio actual
        for filename in sorted(files):
            # Comprobamos si el archivo o su extensi√≥n est√°n en la lista negra
            if filename in EXCLUDED_FILES:
                continue

            file_path = Path(root) / filename
            if file_path.suffix in EXCLUDED_EXTENSIONS:
                continue

            # Si el archivo pasa todos los filtros, lo a√±adimos a la lista
            files_to_process.append(file_path)

    # Escribimos todos los archivos encontrados en el archivo de salida
    with open(output_path, 'w', encoding='utf-8') as output_file:
        for file_path in files_to_process:
            write_file_content(output_file, file_path)

    print(f"\n¬°Snapshot generado con √©xito! {len(files_to_process)} archivos procesados.")


if __name__ == "__main__":
    main()
# === FIN: scripts/generate_snapshot.py ===


# === INICIO: scripts/run_migrations.sh ===
# === FIN: scripts/run_migrations.sh ===


# === INICIO: src/__init__.py ===
# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===
# src/config.py

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    bot_token: SecretStr

    # Database
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Redis
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        # URL AS√çNCRONA (para el resto de la app)
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @property
    def sync_database_url(self) -> str:
        # URL S√çNCRONA (exclusivamente para APScheduler)
        return (
            f"postgresql+psycopg2://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        env_file = '.env'
        env_file_encoding = 'utf-8'

settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Creamos el motor de la base de datos as√≠ncrono
async_engine = create_async_engine(
    settings.database_url,
    echo=False, # Ponlo en True para ver las queries SQL en la consola
)

# Creamos una f√°brica de sesiones as√≠ncronas
async_session_factory = async_sessionmaker(
    async_engine,
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===
# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
from aiogram import Bot

from src.config import settings

bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# Creamos el almacenamiento de estados con la configuraci√≥n de Redis.
#
# Se especifica expl√≠citamente un 'pool_size' m√°s grande para evitar
# el error 'redis.exceptions.ConnectionError: Too many connections'
# que ocurre cuando la aplicaci√≥n recibe varios mensajes a la vez y
# agota el peque√±o pool de conexiones por defecto.
storage = RedisStorage2(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    pool_size=20,  # Aumentamos el n√∫mero de conexiones disponibles en el pool. 20 es un buen punto de partida.
)

# Creamos la instancia principal del Dispatcher que se usar√° en todo el proyecto
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
import logging
from aiogram import types
from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service, online_service, command_service
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.player.movement import MOVEMENT_COMMANDS
from commands.player.channels import CHANNEL_COMMANDS
from commands.admin.building import SPAWN_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from commands.admin.info import INFO_COMMANDS
from src.utils.presenters import show_current_room
from sqlalchemy.ext.asyncio import AsyncSession

# Este diccionario sigue siendo la "fuente de la verdad" de todas las instancias de comandos.
COMMAND_SETS = {
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "movement": MOVEMENT_COMMANDS,
    "channels": CHANNEL_COMMANDS,
    "spawning": SPAWN_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
    "admin_info": INFO_COMMANDS,
    # --- Futuros sets de comandos ir√≠an aqu√≠ ---
    # "thievery": [],
    # "smithing": [],
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Dispatcher principal que utiliza el command_service para determinar
    los comandos activos de un personaje de forma din√°mica.
    """
    async with async_session_factory() as session:
        account = await player_service.get_or_create_account(session, message.from_user.id)
        character = account.character
        input_text = message.text.strip()

        if character:
            await online_service.update_last_seen(character.id)

        if input_text.lower().startswith('/start'):
            if character is None:
                await message.answer(
                    "¬°Bienvenido a Runegram! Veo que eres nuevo por aqu√≠. "
                    "Para empezar, necesitas crear tu personaje. Usa el comando "
                    "/crearpersonaje [nombre] para darle vida a tu aventurero."
                )
            else:
                # Al iniciar sesi√≥n, actualizamos sus comandos en Telegram.
                await command_service.update_telegram_commands(character)
                await show_current_room(message)
            return

        # Protecci√≥n para usuarios sin personaje
        if not character:
            allowed_cmds = ["/crearpersonaje"]
            cmd_name_only = input_text.split()[0].lower()
            if cmd_name_only not in allowed_cmds:
                return await message.answer("Primero debes crear un personaje con /crearpersonaje.")

        if not input_text.startswith('/'):
             return await message.answer("Comando desconocido. Los comandos deben empezar con / (ej: /mirar, /norte).")

        cmd_name = message.get_command(pure=True).lower()
        args = message.get_args().split() if message.get_args() else []

        found_cmd = None
        # --- L√ìGICA DE COMMANDSETS DIN√ÅMICA ---
        # Obtenemos la lista de sets activos desde el servicio en cada turno.
        active_sets_names = await command_service.get_active_command_sets_for_character(character)

        for set_name in active_sets_names:
            if set_name in COMMAND_SETS:
                for cmd_instance in COMMAND_SETS[set_name]:
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
            if found_cmd:
                break

        if not found_cmd:
            return await message.answer("No conozco ese comando.")

        # El sistema de locks (a implementar) se encargar√° de los permisos granulares.
        # Por ahora, el lock de la clase Command sigue funcionando.
        can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
        if not can_run:
            return await message.answer(error_message or "No puedes hacer eso.")

        try:
            await found_cmd.execute(character, session, message, args)
        except Exception as e:
            await message.answer("Ocurri√≥ un error al ejecutar ese comando.")
            logging.exception(f"Error al ejecutar el comando /{cmd_name} para el personaje {character.name}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
from .character_setting import CharacterSetting
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    __tablename__ = 'accounts'

    id = Column(BigInteger, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    role = Column(String, default='JUGADOR', nullable=False)

    # Relaci√≥n: Una cuenta tiene un personaje
    # Usamos el string completo 'src.models.character.Character'
    character = relationship("src.models.character.Character", back_populates="account", uselist=False)

    def __repr__(self):
        return f"<Account(id={self.id}, telegram_id={self.telegram_id})>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
from sqlalchemy.orm import declarative_base

Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB
from .base import Base

class Character(Base):
    __tablename__ = 'characters'

    id = Column(BigInteger, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)

    # --- Relaciones ---
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)
    account = relationship("src.models.account.Account", back_populates="character")

    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)
    room = relationship("src.models.room.Room")

    items = relationship("src.models.item.Item", back_populates="character")

    settings = relationship(
        "src.models.character_setting.CharacterSetting",
        back_populates="character",
        uselist=False,
        cascade="all, delete-orphan"
    )

    # --- L√çNEA MODIFICADA ---
    # Actualizamos el valor por defecto para que todos los personajes nuevos
    # tengan acceso a todos los sets de comandos b√°sicos desde el principio.
    command_sets = Column(
        JSONB,
        nullable=False,
        server_default='["general", "interaction", "movement", "channels"]',
        default=["general", "interaction", "movement", "channels"]
    )
# === FIN: src/models/character.py ===


# === INICIO: src/models/character_setting.py ===
# src/models/character_setting.py
from sqlalchemy import BigInteger, Column, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB
from .base import Base

class CharacterSetting(Base):
    __tablename__ = 'character_settings'

    # Usamos el character_id como clave primaria para forzar una relaci√≥n 1 a 1.
    character_id = Column(BigInteger, ForeignKey('characters.id'), primary_key=True)

    # Columna JSONB para guardar una lista de los canales activos.
    # Ejemplo: {"active_channels": ["novato", "comercio"]}
    active_channels = Column(JSONB, nullable=False, server_default='{}')

    # Relaci√≥n inversa para poder acceder desde el personaje
    character = relationship("src.models.character.Character", back_populates="settings")
# === FIN: src/models/character_setting.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta de roble")
    name = Column(String(50), nullable=False, index=True)

    # De qu√© sala parte esta salida
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)
    # A qu√© sala lleva esta salida
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El string de lock para esta salida espec√≠fica
    locks = Column(String, nullable=False, default="")

    # Relaci√≥n para poder acceder a la sala de origen
    from_room = relationship("src.models.room.Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relaci√≥n para poder acceder a la sala de destino (√∫til para validaciones)
    # --- L√çNEA MODIFICADA ---
    to_room = relationship("src.models.room.Room", foreign_keys=[to_room_id], back_populates="exits_to")
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship
from game_data.item_prototypes import ITEM_PROTOTYPES # <-- Importa los prototipos

from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo.
    """
    __tablename__ = 'items'

    id = Column(BigInteger, primary_key=True)
    key = Column(String(50), nullable=False, index=True)
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    room = relationship("src.models.room.Room", back_populates="items")
    character = relationship("src.models.character.Character", back_populates="items")

    @property
    def prototype(self):
        """Devuelve el diccionario del prototipo para este objeto."""
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """Obtiene el nombre del item, usando override o el prototipo."""
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """Obtiene la descripci√≥n del item, usando override o el prototipo."""
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """Obtiene las keywords del item desde el prototipo."""
        return self.prototype.get("keywords", [])
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base

class Room(Base):
    __tablename__ = 'rooms'

    id = Column(BigInteger, primary_key=True)
    key = Column(String(50), unique=True, nullable=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")
    locks = Column(String, nullable=False, default="")

    # Relaciones existentes
    items = relationship("src.models.item.Item", back_populates="room")

    # --- RELACIONES PARA SALIDAS ---
    # Una lista de todas las salidas QUE PARTEN DE ESTA SALA.
    exits_from = relationship("src.models.exit.Exit", foreign_keys="[Exit.from_room_id]", back_populates="from_room", cascade="all, delete-orphan")

    # Una lista de todas las salidas QUE LLEGAN A ESTA SALA.
    # --- L√çNEA MODIFICADA ---
    exits_to = relationship("src.models.exit.Exit", foreign_keys="[Exit.to_room_id]", back_populates="to_room", cascade="all, delete-orphan")
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===
# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster_service.py ===
# src/services/broadcaster_service.py

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.bot.bot import bot
from src.models import Character


async def send_message_to_character(
    character: Character,
    message_text: str,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje formateado a un personaje espec√≠fico.
    """
    if not character:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un personaje nulo.")
        return

    if not character.account:
        logging.error(f"BROADCASTER: El personaje {character.name} (ID: {character.id}) no tiene su cuenta cargada. No se puede enviar mensaje.")
        return

    try:
        logging.info(f"[BROADCASTER DEBUG] Intentando enviar mensaje a {character.name} (Chat ID: {character.account.telegram_id})")
        await bot.send_message(
            chat_id=character.account.telegram_id,
            text=message_text,
            parse_mode=parse_mode
        )
        logging.info(f"[BROADCASTER DEBUG] Mensaje enviado con √©xito a {character.name}")
    except Exception:
        # Usamos logging.exception para obtener un traceback completo si el env√≠o falla
        logging.exception(f"BROADCASTER: No se pudo enviar mensaje a {character.name} (ID: {character.id})")


async def send_message_to_room(
    session: AsyncSession,
    room_id: int,
    message_text: str,
    exclude_character_id: int | None = None,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje a todos los personajes presentes en una sala espec√≠fica.
    """
    if not room_id:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un room_id nulo.")
        return

    query = (
        select(Character)
        .where(Character.room_id == room_id)
        .options(selectinload(Character.account))
    )

    result = await session.execute(query)
    characters_in_room = result.scalars().all()

    for char in characters_in_room:
        if char.id == exclude_character_id:
            continue

        await send_message_to_character(
            character=char,
            message_text=message_text,
            parse_mode=parse_mode
        )
# === FIN: src/services/broadcaster_service.py ===


# === INICIO: src/services/channel_service.py ===
# src/services/channel_service.py
import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Character, CharacterSetting
from src.services import broadcaster_service, player_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

async def get_or_create_settings(session: AsyncSession, character: Character) -> CharacterSetting:
    """Obtiene o crea las configuraciones para un personaje, asegurando valores por defecto."""
    if character.settings:
        return character.settings

    logging.info(f"Creando configuraciones por defecto para el personaje {character.name}")

    # Determinamos los canales activos por defecto desde los prototipos
    default_channels = [
        key for key, data in CHANNEL_PROTOTYPES.items() if data.get("default_on", False)
    ]

    new_settings = CharacterSetting(
        character_id=character.id,
        active_channels={"active_channels": default_channels}
    )
    session.add(new_settings)
    await session.commit()
    await session.refresh(new_settings)
    # Refrescamos tambi√©n el personaje para que la relaci√≥n se actualice
    await session.refresh(character, attribute_names=["settings"])

    return new_settings

async def is_channel_active(settings: CharacterSetting, channel_key: str) -> bool:
    """Comprueba si un canal est√° en la lista de canales activos de un jugador."""
    return channel_key in settings.active_channels.get("active_channels", [])

async def broadcast_to_channel(session: AsyncSession, channel_key: str, message: str, exclude_character_id: int | None = None):
    """
    Env√≠a un mensaje a todos los jugadores suscritos a un canal.
    """
    if channel_key not in CHANNEL_PROTOTYPES:
        logging.warning(f"Intento de transmitir a un canal desconocido: {channel_key}")
        return

    proto = CHANNEL_PROTOTYPES[channel_key]
    formatted_message = f"{proto['icon']} <b>{proto['name']}:</b> {message}"

    # Buscamos a todos los personajes que tengan la configuraci√≥n
    query = select(Character).options(selectinload(Character.settings), selectinload(Character.account))
    result = await session.execute(query)
    all_characters = result.scalars().all()

    for char in all_characters:
        if char.id == exclude_character_id:
            continue

        # Obtenemos/creamos las settings y comprobamos si el canal est√° activo para este usuario
        settings = await get_or_create_settings(session, char)
        if await is_channel_active(settings, channel_key):
            await broadcaster_service.send_message_to_character(char, formatted_message)

async def set_channel_status(session: AsyncSession, character: Character, channel_key: str, activate: bool):
    """Activa o desactiva un canal para un personaje."""
    if channel_key not in CHANNEL_PROTOTYPES:
        raise ValueError("El canal especificado no existe.")

    settings = await get_or_create_settings(session, character)
    active_channels_list = settings.active_channels.get("active_channels", [])

    if activate:
        if channel_key not in active_channels_list:
            active_channels_list.append(channel_key)
    else: # Desactivar
        if channel_key in active_channels_list:
            active_channels_list.remove(channel_key)

    # SQLAlchemy detecta el cambio en el JSONB y lo guardar√°
    settings.active_channels["active_channels"] = active_channels_list
    await session.commit()
# === FIN: src/services/channel_service.py ===


# === INICIO: src/services/command_service.py ===
# src/services/command_service.py
import logging
from aiogram.types import BotCommand, BotCommandScopeChat
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.bot import bot
from src.models import Character

# Importamos el dispatcher de forma segura para evitar importaciones circulares
def get_command_sets():
    from src.handlers.player.dispatcher import COMMAND_SETS
    return COMMAND_SETS

async def get_active_command_sets_for_character(character: Character) -> list[str]:
    """
    Construye la lista de nombres de CommandSets activos para un personaje.
    """
    if not character:
        return ["character_creation"]

    # --- L√çNEA CORREGIDA ---
    # character.command_sets es una lista, no un diccionario. La tratamos como tal.
    active_sets = set(character.command_sets)

    # 2. A√±adimos sets otorgados por los objetos en el inventario.
    for item in character.items:
        granted_sets = item.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 3. A√±adimos sets otorgados por la sala actual.
    if hasattr(character.room, 'key') and character.room.key: # Salvaguarda por si la sala no tiene prototipo
        from game_data.room_prototypes import ROOM_PROTOTYPES
        room_proto = ROOM_PROTOTYPES.get(character.room.key, {})
        granted_sets = room_proto.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 4. A√±adimos sets de administrador si corresponde.
    if character.account and character.account.role == "ADMINISTRADOR":
        active_sets.update(["spawning", "admin_movement", "admin_info"])

    return sorted(list(active_sets))


async def update_telegram_commands(character: Character):
    """
    Actualiza la lista de comandos visibles en el cliente de Telegram
    para un personaje espec√≠fico.
    """
    if not character:
        return

    COMMAND_SETS = get_command_sets()
    active_set_names = await get_active_command_sets_for_character(character)

    telegram_commands = []
    seen_commands = set()

    for set_name in active_set_names:
        for command_instance in COMMAND_SETS.get(set_name, []):
            main_name = command_instance.names[0]
            if main_name not in seen_commands:
                telegram_commands.append(
                    BotCommand(command=main_name, description=command_instance.description)
                )
                seen_commands.add(main_name)

    try:
        scope = BotCommandScopeChat(chat_id=character.account.telegram_id)
        await bot.set_my_commands(commands=telegram_commands, scope=scope)
        logging.info(f"Actualizados {len(telegram_commands)} comandos de Telegram para {character.name}.")
    except Exception as e:
        logging.warning(f"No se pudieron actualizar los comandos de Telegram para {character.name}: {e}")
# === FIN: src/services/command_service.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
from game_data.item_prototypes import ITEM_PROTOTYPES
# Importamos el ticker_service para registrar nuevos objetos
from src.services import ticker_service


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto, la coloca en una sala
    y registra sus tickers.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    new_item = Item(room_id=room_id, key=item_key)
    session.add(new_item)
    await session.commit()
    await session.refresh(new_item)

    # Despu√©s de crear el objeto, le decimos al scheduler que lo "observe"
    # por si tiene tareas programadas (tickers).
    await ticker_service.schedule_tickers_for_entity(new_item)

    return new_item


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """Mueve un objeto desde una sala al inventario de un personaje."""
    query = update(Item).where(Item.id == item_id).values(
        room_id=None,
        character_id=character_id
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """Mueve un objeto desde el inventario de un personaje a una sala."""
    query = update(Item).where(Item.id == item_id).values(
        room_id=room_id,
        character_id=None
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/online_service.py ===
# src/services/online_service.py
import time
import redis.asyncio as redis
from datetime import timedelta

from src.config import settings
from src.models import Character
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select


# --- CONFIGURACI√ìN ---
# Si un jugador no ha enviado un comando en este tiempo, se considera "offline".
ONLINE_THRESHOLD = timedelta(minutes=5)

# Creamos un cliente de Redis dedicado para este servicio.
redis_client = redis.Redis(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    decode_responses=True  # Importante para que devuelva strings, no bytes
)

def _get_redis_key(character_id: int) -> str:
    """Genera la clave de Redis estandarizada para un personaje."""
    return f"last_seen:{character_id}"

async def update_last_seen(character_id: int):
    """
    Actualiza el timestamp de la √∫ltima actividad de un personaje a "ahora".
    """
    key = _get_redis_key(character_id)
    # Guardamos el timestamp actual como un n√∫mero flotante (ej: 1678886400.0)
    await redis_client.set(key, time.time())
    # Opcional: Hacemos que la clave expire despu√©s de un tiempo para no llenar Redis.
    # Una semana es un tiempo razonable.
    await redis_client.expire(key, timedelta(days=7))

async def is_character_online(character_id: int) -> bool:
    """
    Verifica si un personaje se considera "online" basado en su √∫ltima actividad.
    """
    key = _get_redis_key(character_id)
    last_seen_timestamp_str = await redis_client.get(key)

    if not last_seen_timestamp_str:
        return False  # Si no hay registro, no est√° online.

    try:
        last_seen_timestamp = float(last_seen_timestamp_str)
        # Calculamos el tiempo transcurrido
        elapsed_time = time.time() - last_seen_timestamp
        # Comparamos con nuestro umbral
        return elapsed_time < ONLINE_THRESHOLD.total_seconds()
    except (ValueError, TypeError):
        return False

async def get_online_characters(session: AsyncSession) -> list[Character]:
    """
    Devuelve una lista de todos los personajes que se consideran "online".
    """
    result = await session.execute(select(Character))
    all_characters = result.scalars().all()

    online_characters = []
    for char in all_characters:
        if await is_character_online(char.id):
            online_characters.append(char)

    return online_characters
# === FIN: src/services/online_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
from src.models.character import Character


def _check_role(character: Character, required_role: str) -> bool:
    """Verifica si el personaje tiene el rol requerido."""
    return character.account.role.upper() == required_role.upper()


async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Verifica si un personaje puede pasar un lock.
    Devuelve una tupla: (puede_pasar, mensaje_de_error).
    """
    if not lock_string:
        return True, ""  # Un lock vac√≠o siempre se puede pasar.

    # L√≥gica AND: todas las funciones de lock deben ser verdaderas.
    lock_functions = lock_string.lower().split(' y ')

    for func in lock_functions:
        # Por ahora, solo implementamos la funci√≥n 'rol(argumento)'
        if func.startswith('rol(') and func.endswith(')'):
            required_role = func[4:-1]
            if not _check_role(character, required_role):
                # Devolvemos un mensaje de error espec√≠fico
                return False, "No tienes el rango necesario."
        else:
            # Si encontramos una funci√≥n de lock que no entendemos, por seguridad, fallamos.
            print(f"ADVERTENCIA: Funci√≥n de lock desconocida: {func}")
            return False, "Esa acci√≥n est√° bloqueada por una fuerza desconocida."

    # Si el personaje pas√≥ todos los chequeos de la cadena AND
    return True, ""
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.models.item import Item
from src.models.exit import Exit
from src.services import channel_service, command_service


async def get_character_with_relations_by_id(session: AsyncSession, character_id: int) -> Character | None:
    """
    Busca un personaje por su ID y carga expl√≠citamente todas sus relaciones
    cr√≠ticas para evitar errores de carga perezosa.
    """
    query = (
        select(Character)
        .where(Character.id == character_id)
        .options(
            selectinload(Character.room).selectinload(Room.items),
            selectinload(Character.room).selectinload(Room.exits_from),
            selectinload(Character.items),
            selectinload(Character.account),
            selectinload(Character.settings)
        )
    )
    result = await session.execute(query)
    return result.scalar_one_or_none()


async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Devuelve el objeto de la cuenta con su personaje y todas las relaciones cargadas.
    """
    # Primero, buscamos la cuenta y su relaci√≥n con el personaje.
    account_query = select(Account).where(Account.telegram_id == telegram_id).options(selectinload(Account.character))
    result = await session.execute(account_query)
    account = result.scalar_one_or_none()

    # Si la cuenta no existe, la creamos y la devolvemos. No tendr√° personaje.
    if not account:
        print(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
        new_account = Account(telegram_id=telegram_id)
        session.add(new_account)
        await session.commit()
        await session.refresh(new_account)
        return new_account

    # Si la cuenta existe pero no tiene personaje, la devolvemos tal cual.
    if not account.character:
        return account

    # Si la cuenta y el personaje existen, recargamos el personaje con todas sus relaciones.
    full_character = await get_character_with_relations_by_id(session, account.character.id)
    account.character = full_character
    return account


async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje, lo asocia a una cuenta, y env√≠a un mensaje de bienvenida.
    """
    account = await get_or_create_account(session, telegram_id)

    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya est√° en uso. Por favor, elige otro.")

    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1 # Asigna a la sala de inicio "limbo"
    )
    session.add(new_character)
    await session.commit() # Al hacer commit, new_character obtiene su ID.

    # --- CAMBIO CLAVE: Recargamos el personaje por completo ---
    # Usamos la funci√≥n que ya creamos para obtener una versi√≥n "fresca" y completa
    # del personaje, con todas sus relaciones cargadas (incluida .account).
    full_character = await get_character_with_relations_by_id(session, new_character.id)

    # Ahora usamos este objeto 'full_character' para el resto de operaciones.
    if not full_character:
        # Esto es una salvaguarda, nunca deber√≠a ocurrir.
        raise RuntimeError("No se pudo recargar el personaje reci√©n creado.")

    # --- MENSAJE DE BIENVENIDA ---
    await channel_service.get_or_create_settings(session, full_character)
    welcome_message = (
        f"¬°Bienvenido al mundo, {full_character.name}! "
        "Usa los comandos de movimiento como <b>/norte</b> o <b>/sur</b> para explorar. "
        "Si necesitas ayuda, puedes preguntar en este canal usando <b>/novato [tu pregunta]</b>. "
        "Para una lista de comandos m√°s detallada, escribe <b>/ayuda</b>."
    )
    await channel_service.broadcast_to_channel(session, "novato", welcome_message)

    # --- ACTUALIZAR COMANDOS DE TELEGRAM ---
    # Despu√©s de crear el personaje, establecemos su lista inicial de comandos.
    await command_service.update_telegram_commands(full_character)

    return full_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala."""
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py
import re
import random
import logging  # <-- Importamos logging
from sqlalchemy.ext.asyncio import AsyncSession

# Importamos los modelos de datos con los que los scripts interactuar√°n
from src.models.character import Character
from src.models.item import Item
from src.models.room import Room

# Importamos el servicio centralizado para enviar mensajes
from src.services import broadcaster_service


# ==============================================================================
# SECCI√ìN 1: DEFINICIONES DE LAS FUNCIONES DE SCRIPT
# ==============================================================================

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Notifica al jugador que un objeto brilla al ser mirado.
    """
    color = kwargs.get("color", "una luz misteriosa")
    message = f"üåü Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."

    await broadcaster_service.send_message_to_character(character, message)


async def script_espada_susurra_secreto(session: AsyncSession, target: Item, character: Character, **kwargs):
    """
    Script de ticker: Hace que un objeto emita un susurro a un personaje espec√≠fico
    que est√° activo en la misma sala.
    """
    secretos = [
        "El tesoro se encuentra bajo la sombra del roble marchito...",
        "La llave oxidada no abre una puerta, sino un coraz√≥n...",
        "Cuidado con el que no proyecta sombra...",
    ]
    secreto_elegido = random.choice(secretos)

    mensaje = f"<i>Un susurro escalofriante parece emanar de {target.get_name()}: \"{secreto_elegido}\"</i>"

    # Ahora enviamos el mensaje solo al personaje del contexto, que ya sabemos que est√° activo.
    await broadcaster_service.send_message_to_character(character, mensaje)


# ==============================================================================
# SECCI√ìN 2: EL MOTOR DE SCRIPTS
# ==============================================================================

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,
}

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre_script(key1=val1, key2=val2)'
    y devuelve el nombre y un diccionario de argumentos.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            print(f"ADVERTENCIA: Argumentos de script mal formados en '{script_string}'. Ignorando argumentos.")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El coraz√≥n del motor de scripts.
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        try:
            await script_function(session=session, **context, **kwargs)
        except Exception as e:
            # --- MEJORA DE LOGGING ---
            # Usamos logging.exception para obtener un traceback completo en los logs de Docker.
            logging.exception(f"Ocurri√≥ un error al ejecutar el script '{script_name}'")
    else:
        logging.warning(f"ADVERTENCIA: Se intent√≥ ejecutar un script desconocido: '{script_name}'")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/ticker_service.py ===
# src/services/ticker_service.py
import logging
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.db import async_session_factory
from src.services import script_service, online_service, player_service
from src.models import Item, Room, Character

scheduler = AsyncIOScheduler()


# ==============================================================================
# SECCI√ìN DE FUNCIONES AUXILIARES
# ==============================================================================

def parse_schedule(schedule_str: str) -> tuple[str, dict]:
    """
    Parsea el string de schedule del prototipo y lo convierte en argumentos para APScheduler.
    """
    if schedule_str.startswith("interval:"):
        seconds = int(schedule_str.split(':')[1])
        return 'interval', {'seconds': seconds}
    if schedule_str.startswith("date:"):
        date_val = schedule_str.split(':', 1)[1]
        return 'date', {'run_date': date_val}
    cron_expr = schedule_str
    if schedule_str.startswith("cron:"):
        cron_expr = schedule_str.split(':', 1)[1]
    parts = cron_expr.strip().split()
    if len(parts) != 5:
        logging.warning(f"ADVERTENCIA: Expresi√≥n cron mal formada en '{schedule_str}'. Se ignora.")
        return 'cron', {}
    cron_args = { 'minute': parts[0], 'hour': parts[1], 'day': parts[2], 'month': parts[3], 'day_of_week': parts[4] }
    return 'cron', cron_args


async def get_entity_by_id(session: AsyncSession, entity_id: int, entity_type: str):
    """
    Busca una entidad por su ID y tipo, cargando expl√≠citamente las relaciones
    necesarias para evitar errores de carga perezosa (lazy loading).
    """
    MODEL_MAP = {"Item": Item, "Room": Room, "Character": Character}
    model_class = MODEL_MAP.get(entity_type)
    if not model_class:
        logging.warning(f"ADVERTENCIA: Tipo de entidad desconocido '{entity_type}' para ticker.")
        return None

    query = select(model_class)

    # --- CAMBIO CLAVE: Carga de relaciones anidadas ---
    if model_class is Item:
        # Si es un Item, necesitamos precargar:
        # 1. La sala en la que est√° (si est√° en una).
        # 2. El personaje que lo lleva (si lo lleva alguien).
        # 3. La sala del personaje que lo lleva.
        query = query.options(
            selectinload(Item.room),
            selectinload(Item.character).selectinload(Character.room)
        )
    elif model_class is Character:
        query = query.options(selectinload(Character.room), selectinload(Character.account))

    query = query.where(model_class.id == entity_id)
    result = await session.execute(query)
    return result.scalar_one_or_none()


# ==============================================================================
# SECCI√ìN PRINCIPAL DEL SERVICIO
# ==============================================================================

def initialize_scheduler():
    """Configura y arranca el scheduler global."""
    jobstores = {'default': SQLAlchemyJobStore(url=settings.sync_database_url)}
    scheduler.configure(jobstores=jobstores)
    scheduler.start()
    logging.info("‚è∞ Ticker Service iniciado y listo para programar tareas.")

async def load_and_schedule_all_tickers(session: AsyncSession):
    """
    Busca todas las entidades con tickers en la base de datos y las programa.
    """
    logging.info("Cargando y programando tickers para todas las entidades existentes...")
    result = await session.execute(select(Item))
    all_items = result.scalars().all()
    for item in all_items:
        if item.prototype.get("tickers"):
            logging.info(f"  -> Programando tickers para el item '{item.key}' (ID: {item.id})")
            await schedule_tickers_for_entity(item)
    logging.info("Carga de tickers existentes finalizada.")

async def schedule_tickers_for_entity(entity):
    """
    Lee los tickers del prototipo de una entidad y los a√±ade al scheduler.
    """
    prototype_tickers = entity.prototype.get("tickers", [])
    for ticker_data in prototype_tickers:
        schedule_str = ticker_data.get("schedule")
        script_str = ticker_data.get("script")
        category = ticker_data.get("category", "ambient")
        if not schedule_str or not script_str:
            continue
        trigger_type, trigger_args = parse_schedule(schedule_str)
        if not trigger_args:
            continue
        job_id = f"ticker_{type(entity).__name__}_{entity.id}_{schedule_str}_{script_str}"
        scheduler.add_job(
            execute_ticker_script, trigger=trigger_type,
            args=[entity.id, type(entity).__name__, script_str, category],
            id=job_id, replace_existing=True, **trigger_args
        )

async def execute_ticker_script(entity_id: int, entity_type: str, script_string: str, category: str):
    """
    Funci√≥n que APScheduler llama. Ahora es inteligente y encuentra la sala
    incluso si el objeto est√° en el inventario de un personaje.
    """
    async with async_session_factory() as session:
        entity = await get_entity_by_id(session, entity_id, entity_type)
        if not entity:
            return

        # --- CAMBIO CLAVE: L√≥gica para encontrar la sala ---
        room = None
        if hasattr(entity, 'room') and entity.room:
            # Opci√≥n 1: El objeto est√° en una sala.
            room = entity.room
        elif hasattr(entity, 'character') and entity.character and entity.character.room:
            # Opci√≥n 2: El objeto lo lleva un personaje, usamos la sala de ese personaje.
            room = entity.character.room

        if not room:
            # Si no hay sala por ninguno de los dos m√©todos, abortamos.
            return

        char_ids_in_room_query = select(Character.id).where(Character.room_id == room.id)
        result = await session.execute(char_ids_in_room_query)
        char_ids_in_room = result.scalars().all()

        for char_id in char_ids_in_room:
            is_online = await online_service.is_character_online(char_id)
            if category == "ambient" and not is_online:
                continue

            full_character = await player_service.get_character_with_relations_by_id(session, char_id)
            if not full_character:
                continue

            context = {
                "target": entity,
                "room": full_character.room,
                "character": full_character
            }

            await script_service.execute_script(
                script_string=script_string,
                session=session,
                **context
            )
# === FIN: src/services/ticker_service.py ===


# === INICIO: src/services/world_loader_service.py ===
# src/services/world_loader_service.py
import logging
# --- ¬°Importaci√≥n clave a√±adida! ---
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Room, Exit
from game_data.room_prototypes import ROOM_PROTOTYPES

# Mapa de direcciones opuestas para conexiones bidireccionales
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def sync_world_from_prototypes(session: AsyncSession):
    """
    Sincroniza la base de datos con los prototipos de salas.
    Es idempotente: crea salas si no existen y las actualiza si existen.
    """
    logging.info(" sincronizando el mundo desde los prototipos...")

    # Paso 1: Sincronizar todas las salas para asegurar que existen y obtener sus IDs.
    room_key_to_id_map = {}

    existing_rooms_query = await session.execute(select(Room))
    existing_rooms = {room.key: room for room in existing_rooms_query.scalars().all()}

    for key, data in ROOM_PROTOTYPES.items():
        room = existing_rooms.get(key)
        if not room:
            logging.info(f"  -> Creando sala '{key}'...")
            room = Room(key=key, name=data['name'], description=data['description'])
            session.add(room)
        else:
            room.name = data['name']
            room.description = data['description']

        await session.flush()
        room_key_to_id_map[key] = room.id

    # Paso 2: Limpiar salidas viejas. Es m√°s f√°cil borrarlas y recrearlas.
    logging.info("  -> Limpiando todas las salidas existentes para reconstruir...")

    # --- L√çNEA CORREGIDA ---
    # La forma correcta de borrar todos los registros de una tabla es usando la instrucci√≥n `delete()`.
    await session.execute(delete(Exit))
    # --- FIN DE LA CORRECCI√ìN ---

    # Paso 3: Crear todas las salidas de nuevo.
    for key, data in ROOM_PROTOTYPES.items():
        from_room_id = room_key_to_id_map[key]
        for direction, to_room_key in data.get("exits", {}).items():
            if to_room_key in room_key_to_id_map:
                to_room_id = room_key_to_id_map[to_room_key]

                exit_forward = Exit(name=direction.lower(), from_room_id=from_room_id, to_room_id=to_room_id)
                session.add(exit_forward)

                opposite = OPPOSITE_DIRECTIONS.get(direction.lower())
                if opposite:
                    exit_backward = Exit(name=opposite, from_room_id=to_room_id, to_room_id=from_room_id)
                    session.add(exit_backward)
            else:
                logging.warning(f"  -> La sala de destino '{to_room_key}' definida en '{key}' no existe.")

    await session.commit()
    logging.info("¬°Sincronizaci√≥n del mundo completada!")
# === FIN: src/services/world_loader_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit # <-- Importa el nuevo modelo

# Mapa de direcciones opuestas para conexiones bidireccionales
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """Busca y devuelve una sala por su ID."""
    result = await session.execute(select(Room).where(Room.id == room_id))
    return result.scalar_one_or_none()

async def create_room(session: AsyncSession, name: str) -> Room:
    """Crea una nueva sala en la base de datos."""
    if not name:
        raise ValueError("El nombre de la sala no puede estar vac√≠o.")

    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """Actualiza la descripci√≥n de una sala existente."""
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """Crea una salida (y opcionalmente su opuesta) entre dos salas."""
    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    # Crear la salida principal
    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    # Crear la salida de vuelta si es bidireccional
    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===
# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py

from aiogram import types
from collections import Counter

from src.models.room import Room
# La importaci√≥n de Item ya no es estrictamente necesaria aqu√≠, pero es buena pr√°ctica mantenerla
# por si en el futuro se a√±aden m√°s funciones de formato relacionadas con items.
from src.models.item import Item
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripci√≥n completa de una sala para ser mostrada al jugador.
    Esta funci√≥n est√° dise√±ada para ser f√°cilmente extensible.
    """
    parts = []

    # 1. T√≠tulo de la Sala (en negrita)
    parts.append(f"<b>{room.name}</b>")

    # 2. Descripci√≥n principal
    # Usamos strip() para quitar espacios en blanco al inicio/final que puedan venir de la BD
    parts.append(room.description.strip())

    # 3. Items en la sala
    if room.items:
        # Ahora llamamos al m√©todo .get_name() directamente desde cada objeto Item
        item_names = [item.get_name() for item in room.items]

        # Agrupamos items id√©nticos para mostrarlos de forma compacta (ej: una moneda de oro (3))
        item_counts = Counter(item_names)
        formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
        items_str = ", ".join(formatted_items)
        parts.append(f"\n<b>Ves aqu√≠:</b> {items_str}.")

    # 4. Salidas
    if room.exits_from:
        exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
        exits_str = ", ".join(exits_list)
        parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
    else:
        parts.append("\n<b>Salidas:</b> [ Ninguna ]")

    description_body = "\n".join(parts)

    # Envolvemos el resultado final en etiquetas <pre> para un formato de monoespaciado
    return f"<pre>{description_body}</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripci√≥n formateada.
    Esta funci√≥n centraliza la l√≥gica de "mirar" el entorno.
    """
    async with async_session_factory() as session:
        # Usamos el servicio para obtener la cuenta y sus relaciones precargadas
        account = await player_service.get_or_create_account(session, message.from_user.id)

        if not account.character or not account.character.room:
            # Esta es una salvaguarda.
            await message.answer("Parece que est√°s perdido en el vac√≠o. Te hemos llevado a un lugar seguro.")
            return

        room = account.character.room
        # Usamos nuestro formateador para construir el texto de la sala
        formatted_room = await format_room(room)

        # Usamos parse_mode="HTML" para que Telegram entienda las etiquetas <pre> y <b>
        await message.answer(formatted_room, parse_mode="HTML")
# === FIN: src/utils/presenters.py ===


