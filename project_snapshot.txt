# === INICIO: .gitignore ===
project_snapshot.txt
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¡Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Caché de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Caché de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querrás subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de código
# Configuraciones específicas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena práctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: Dockerfile ===
# Dockerfile para la Aplicación Runegram MUD
#
# Este archivo define los pasos para construir la imagen Docker que contendrá
# y ejecutará la aplicación del bot. Docker utiliza esta "receta" para crear un
# entorno autocontenido y reproducible.
#
# El proceso de construcción sigue estos pasos:
# 1. FROM: Se parte de una imagen base oficial de Python sobre Alpine Linux.
# 2. RUN (apk): Se instalan las dependencias a nivel de sistema operativo que
#    necesita nuestra aplicación (ej: librerías de PostgreSQL, herramientas de red).
# 3. WORKDIR: Se establece el directorio de trabajo dentro del contenedor.
# 4. COPY / RUN (pip): Se copia primero el archivo de dependencias de Python y se
#    instalan. Este paso se hace por separado para aprovechar la caché de Docker.
#    Si el `requirements.txt` no cambia, Docker no volverá a ejecutar este paso,
#    acelerando construcciones futuras.
# 5. COPY (código fuente): Se copia el resto del código de la aplicación.
# 6. CMD: Se define el comando por defecto que se ejecutará al iniciar el contenedor,
#    el cual es interceptado y gestionado por nuestro `entrypoint.sh`.

# 1. Imagen Base
# Usamos la imagen oficial de Python 3.11 basada en Alpine Linux.
# Alpine es una distribución muy ligera, lo que resulta en una imagen final más pequeña.
FROM python:3.11-alpine

# 2. Dependencias del Sistema
# Usamos el gestor de paquetes de Alpine (`apk`) para instalar software necesario.
# --no-cache: No guarda el índice de paquetes, manteniendo la imagen ligera.
# - postgresql-libs: Librerías C requeridas por el driver `psycopg2-binary`.
# - netcat-openbsd: Herramienta de red utilizada en `entrypoint.sh` para esperar a PostgreSQL.
# - git: Puede ser útil para instalar dependencias de Python directamente desde repositorios.
RUN apk add --no-cache postgresql-libs netcat-openbsd git

# 3. Directorio de Trabajo
# Establece el directorio de trabajo por defecto dentro del contenedor.
# Todos los comandos `RUN`, `CMD`, `ENTRYPOINT`, `COPY` y `ADD` posteriores
# se ejecutarán en este directorio.
WORKDIR /app

# 4. Dependencias de Python
# Copiamos solo el archivo de requerimientos primero. Esto es una optimización
# de la caché de Docker. Si nuestro código cambia pero `requirements.txt` no,
# Docker reutilizará la capa de imagen ya existente donde se instalaron las
# dependencias, haciendo que la reconstrucción sea mucho más rápida.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. Código Fuente de la Aplicación
# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable.
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

# Copiamos el resto del código fuente del proyecto al directorio de trabajo (`/app`).
COPY . .

# 6. Comando de Ejecución
# Define el comando por defecto que se ejecutará al iniciar un contenedor
# a partir de esta imagen.
# IMPORTANTE: Este comando se pasa como argumento a nuestro `entrypoint.sh`
# (definido en `docker-compose.yml`), que lo ejecuta al final con `exec "$@"`.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: NOTAS.md ===
## Telegram

### Mi ID de usuario (benabbhi)

1648877346

## Postgres

### Conectarse

```shell
docker-compose exec postgres psql -U runegram -d runegram_db
```
### Ver tablas

```
\dt
```

## Docker

### Prune

```shell
docker system prune -a --volumes
```

## TODO

* Las salas no muestran los objetos caidos
* Como se determina que comando le corresponde a quie?
* No se actualizan ambos extremos de las salidas
# === FIN: NOTAS.md ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

Runegram es un proyecto para crear un juego de rol textual multijugador (MUD - Multi-User Dungeon) que se juega a través de la interacción con un bot de Telegram. Este repositorio contiene el motor de un juego funcional, con una arquitectura escalable lista para la expansión masiva de contenido.

## Filosofía de Diseño: Motor vs. Contenido

La arquitectura del proyecto se divide en dos conceptos clave para máxima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **código fuente** de la aplicación. Es la maquinaria genérica que hace que el juego funcione (conexión a la base de datos, comunicación con Telegram, ejecución de lógica). No sabe qué es una "espada", solo sabe cómo manejar un "Ítem".
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** que dan vida al mundo. Aquí se define qué es una "espada", qué hace el comando "atacar", o qué monstruos existen. Está diseñado para que los diseñadores de juego puedan añadir contenido sin tocar el motor principal.

## Sistemas Clave Implementados

### 1. Carga del Mundo Dirigida por Datos
El mundo estático del juego ya no se construye con comandos de administrador, sino que se define enteramente en archivos de datos.

*   **Definición (`game_data/room_prototypes.py`):** Todas las salas, sus descripciones y las conexiones entre ellas se definen en un diccionario de Python. Esto actúa como el "mapa maestro" del mundo.
*   **Sincronización (`world_loader_service.py`):** Al iniciar el bot, un servicio dedicado lee estos prototipos, comprueba el estado de la base de datos y crea o actualiza las salas y salidas para que coincidan con la "fuente de la verdad". Esto garantiza un mundo consistente en cada reinicio.

### 2. Sistema de Comandos Dinámicos y Contextuales
La lista de comandos disponibles para un jugador no es estática; cambia en tiempo real según su contexto.

*   **Múltiples Fuentes:** Un `command_service` centralizado construye la lista de `CommandSets` activos para un jugador a partir de:
    1.  **Base:** Comandos innatos del personaje, guardados en la base de datos.
    2.  **Equipo:** Objetos en el inventario que otorgan `CommandSets` (ej: unas ganzúas que otorgan el set `thievery`).
    3.  **Entorno:** La sala actual, que puede otorgar `CommandSets` (ej: una forja que otorga el set `smithing`).
    4.  **Rol:** Los administradores reciben sets de comandos especiales.
*   **Actualización en Telegram:** El motor actualiza la lista de comandos (`/`) en el cliente de Telegram del jugador en tiempo real, cada vez que su contexto cambia (al moverse de sala, coger un objeto, etc.), proporcionando una experiencia de usuario fluida e intuitiva.

### 3. Sistema Dual de Scripts: Eventos y Tickers
El motor permite que el contenido del juego ejecute lógica a través de dos sistemas complementarios.

*   **Scripts Reactivos (Eventos):** Son disparados por acciones del jugador.
    *   **Trigger:** `"on_look": "script_nombre(...)"` en el prototipo de un objeto.
    *   **Ejecución:** Cuando un jugador mira el objeto, el `script_service` ejecuta la función correspondiente.
*   **Scripts Proactivos (Tickers):** Se ejecutan de forma programada, independientemente de la acción del jugador, haciendo que el mundo se sienta vivo.
    *   **Definición:** `"tickers": [{"schedule": "*/5 * * * *", "script": "...", "category": "ambient"}]`
    *   **Ejecución:** Un `ticker_service` (usando `APScheduler`) se encarga de ejecutar estos scripts según su horario (cron o intervalo).
    *   **Inteligencia:** Los tickers de categoría `"ambient"` solo se ejecutan para jugadores considerados "activos", evitando notificar a usuarios que no están jugando.

### 4. Sistema de Canales y Presencia
Para facilitar la comunicación y la inmersión social, el juego implementa un sistema de canales y seguimiento de actividad.

*   **Seguimiento de Actividad (`online_service.py`):** Utilizando **Redis** para máxima velocidad, el motor registra un timestamp cada vez que un jugador envía un comando. Si la última actividad fue hace menos de 5 minutos, se le considera "online".
*   **Canales (`channel_service.py`):**
    *   Se definen en `game_data/channel_prototypes.py`.
    *   Los jugadores pueden suscribirse o desuscribirse (`/canal activar/desactivar`).
    *   Permiten comunicación global (ej: `/novato [mensaje]`) entre todos los jugadores suscritos.
    *   El comando `/quien` utiliza el `online_service` para mostrar una lista de los jugadores activos.

## Estructura del Proyecto

```
runegram/
├── alembic/              # Migraciones de la base de datos
├── commands/             # DEFINICIÓN de los comandos (clases Command)
│   ├── admin/
│   └── player/
├── game_data/            # DEFINICIÓN del contenido del juego
│   ├── channel_prototypes.py # Define los canales de chat
│   ├── item_prototypes.py    # Define los prototipos de objetos
│   └── room_prototypes.py    # Define el mapa del mundo (salas y salidas)
├── scripts/              # Scripts de utilidad (ej: full_reset.bat)
├── src/                  # CÓDIGO FUENTE del motor de la aplicación
│   ├── bot/
│   ├── handlers/
│   │   └── player/
│   │       └── dispatcher.py # El router de comandos principal
│   ├── models/           # Modelos de datos de SQLAlchemy
│   ├── services/         # Lógica de negocio y acceso a datos
│   │   ├── broadcaster_service.py
│   │   ├── channel_service.py
│   │   ├── command_service.py
│   │   ├── online_service.py
│   │   ├── script_service.py
│   │   ├── ticker_service.py
│   │   └── world_loader_service.py
│   └── utils/
├── .env                  # Archivo de variables de entorno (ignorado)
├── docker-compose.yml    # Orquestación de los contenedores
├── Dockerfile            # Definición de la imagen Docker de la app
├── entrypoint.sh         # Script de arranque
└── run.py                # Punto de entrada
```

## Puesta en Marcha

Se necesita Docker y Docker Compose.

1.  **Configurar el Entorno:** Crea un archivo `.env` en la raíz del proyecto a partir del `.env.example`.
2.  **Ejecutar el Script de Reinicio:** Para asegurar un entorno limpio, usa el script automatizado.
    ```bash
    # En Windows
    scripts\full_reset.bat
    ```
    Este script reconstruirá la imagen, levantará los servicios y aplicará todas las migraciones.
3.  **Jugar:** Abre Telegram y envía `/start` a tu bot.

---

## Visión a Futuro y Tareas Pendientes (TODO)

Esta sección documenta las próximas mejoras para evolucionar de un motor robusto a un juego completo y pulido.

### 🚀 **Próximas Grandes Funcionalidades**

*   #### **Sistema de Combate y Habilidades**
    *   **Visión:** Crear un sistema de combate y progresión de habilidades basado en una mecánica de d100 (tirada de 100 caras).
    *   **Tareas:**
        1.  **Modelos de Datos:** Crear los modelos `Skill` y `CharacterSkill`. Añadir atributos de combate (Salud, Maná, etc.) al modelo `Character`.
        2.  **Mecánica d100:** Implementar la lógica de "aprender haciendo": una acción tiene éxito si `d100 <= nivel_de_habilidad`, y al tener éxito, se gana experiencia.
        3.  **PNJs y Spawners:** Crear `npc_prototypes.py`, un modelo `NPC` y un `npc_service` para poder "spawnear" monstruos en el mundo y gestionar su IA (agresiva, pasiva) y sus "respawns".
        4.  **Comandos de Combate:** Crear el `CommandSet` de combate (`/atacar`, `/huir`, etc.).

*   #### **Completar el Sistema de Locks y Permisos**
    *   **Visión:** Crear un sistema de permisos granular para controlar el acceso a salidas, objetos y comandos, yendo más allá del simple `rol()`.
    *   **Tareas:**
        1.  **Expandir el Parser:** Mejorar `permission_service` para que entienda una sintaxis rica: `tiene_objeto(llave_oxidada)`, `habilidad(forzar_cerraduras)>25`, `clase(guerrero)`. Implementar operadores lógicos `y` / `o`.
        2.  **Integración:** Aplicar la verificación de `locks` en el `CmdMove` para las salidas y en el `dispatcher` para los comandos.

### ✨ **Mejoras del Motor y Calidad de Vida**

*   **Bandeja de Entrada para Notificaciones:** Para los tickers de categoría `important` o `quest`, guardar los mensajes para los jugadores inactivos y presentárselos cuando vuelvan a conectarse ("Mientras no estabas...").
*   **Sistema de Contenedores:** Expandir los ítems para que puedan ser contenedores (mochilas, cofres) con su propio inventario, capacidad y `locks`.
*   **Sistema de Clases y Razas:** Usar una **Máquina de Estados Finitos (FSM)** para guiar al jugador a través de una creación de personaje por pasos, permitiéndole elegir clase y raza, lo que a su vez establecerá sus `CommandSets` base en la BD.
*   **Mejorar Comando `/decir`:** Hacer que el comando `/decir` y las acciones de combate envíen mensajes a todos los jugadores *online* en la misma sala, creando una verdadera interacción social.

### 🌍 **Contenido y Expansión del Mundo**

*Gracias a la arquitectura Data-Driven, expandir el mundo es ahora una tarea de diseño, no de programación.*
*   **Crear Nuevos Prototipos:** Diseñar más objetos, monstruos y PNJ en los archivos de `game_data`.
*   **Diseñar Zonas:** Expandir el `room_prototypes.py` para crear nuevas áreas, ciudades y mazmorras.
*   **Escribir Quests:** Implementar PNJ que puedan dar misiones, utilizando el sistema de `FSM` para rastrear el progreso del jugador en una quest.
*   **Crear Habilidades y Clases:** Definir las habilidades disponibles en el juego y los `CommandSets` que cada clase aprenderá a medida que progrese.
# === FIN: README.md ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCIÓN PRINCIPAL DE ALEMBIC
# Aquí se definen las configuraciones más importantes.
# ==============================================================================
[alembic]

# --- Ubicación de los Scripts de Migración ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la raíz del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA LÍNEA MÁS IMPORTANTE.
# Le dice a Alembic cómo conectarse a tu base de datos PostgreSQL.
# La magia aquí es que no ponemos la contraseña directamente.
# El archivo `alembic/env.py` se encargará de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define cómo se nombran los nuevos archivos de migración.
# {rev} es el ID de la revisión, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos después de que se genera un nuevo archivo de migración.
# Es muy útil para formatear automáticamente el código con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACIÓN DE LOGGING
# Define cómo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aquí, la configuración por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml
#
# Este archivo es la pieza central para orquestar los diferentes servicios
# (contenedores) que componen la aplicación Runegram. Docker Compose lee
# este archivo para construir, iniciar, conectar y gestionar todos los
# contenedores de forma conjunta.
#
# Servicios definidos:
# 1. bot:       El contenedor principal de la aplicación Python que ejecuta el bot de Telegram.
# 2. postgres:  El servicio de base de datos PostgreSQL.
# 3. redis:     El servicio de caché en memoria, utilizado para la gestión de estados
#               de Aiogram y el seguimiento de actividad de los jugadores.

services:
  # --- Servicio de la Aplicación Principal del Bot ---
  bot:
    # `build: .` le dice a Docker Compose que construya una imagen para este servicio
    # utilizando el Dockerfile que se encuentra en el directorio actual ('.').
    build: .

    # `entrypoint`: Sobrescribe el ENTRYPOINT por defecto de la imagen. Aquí especificamos
    # nuestro script `entrypoint.sh`, que se encargará de las tareas de preparación
    # (esperar a la BD, ejecutar migraciones) antes de lanzar la aplicación principal.
    entrypoint: /app/entrypoint.sh

    # `command`: Especifica el comando que se pasa como argumento al `entrypoint`.
    # Nuestro `entrypoint.sh` ejecuta este comando al final con `exec "$@"`.
    command: python run.py

    # `environment`: Define variables de entorno dentro del contenedor.
    # `PYTHONPATH=/app` asegura que Python pueda encontrar nuestros módulos en `src/`.
    environment:
      - PYTHONPATH=/app

    # `env_file`: Carga las variables de entorno desde el archivo `.env` en la raíz
    # del proyecto. Esto mantiene las credenciales y configuraciones fuera del código.
    env_file:
      - .env

    # `depends_on`: Asegura que los servicios `postgres` y `redis` se inicien
    # *antes* de que se inicie el servicio `bot`. No garantiza que estén "listos",
    # por eso nuestro `entrypoint.sh` se encarga de esperar activamente.
    depends_on:
      - postgres
      - redis

    # `volumes`: Mapea directorios de nuestra máquina local al interior del contenedor.
    # Esto es crucial para el desarrollo, ya que cualquier cambio en nuestro código
    # se refleja instantáneamente dentro del contenedor sin necesidad de reconstruir la imagen.
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      - ./entrypoint.sh:/app/entrypoint.sh

  # --- Servicio de la Base de Datos ---
  postgres:
    # `image`: Utiliza una imagen preconstruida oficial de PostgreSQL desde Docker Hub.
    # La etiqueta `:15-alpine` especifica la versión 15 sobre Alpine Linux, que es ligera.
    image: postgres:15-alpine

    # `environment`: Configura las credenciales y el nombre de la base de datos
    # inicial. Los valores `${...}` se leen del archivo `.env` en nuestra máquina.
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}

    # `volumes`: Mapea un "volumen nombrado" de Docker (`postgres_data`) al directorio
    # donde PostgreSQL guarda sus datos. Esto hace que los datos de la base de datos
    # sean persistentes, sobreviviendo a reinicios o eliminaciones del contenedor.
    volumes:
      - postgres_data:/var/lib/postgresql/data/

    # `ports`: Mapea el puerto 5432 del contenedor al puerto 5432 de nuestra máquina local.
    # Esto nos permite conectarnos a la base de datos desde herramientas locales si es necesario.
    ports:
      - "5432:5432"

  # --- Servicio de Caché en Memoria ---
  redis:
    # Utiliza la imagen oficial de Redis, versión 7 sobre Alpine.
    image: redis:7-alpine

    # Mapea el puerto por defecto de Redis para permitir conexiones locales.
    ports:
      - "6379:6379"

# Define los volúmenes nombrados que hemos utilizado. Docker se encarga de gestionarlos.
volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: entrypoint.sh ===
#!/bin/sh
#
# Entrypoint para el Contenedor de la Aplicación Runegram
#
# Este script se ejecuta cada vez que el contenedor de la aplicación ('bot') se inicia.
# Su principal responsabilidad es preparar el entorno antes de lanzar la aplicación
# de Python principal.
#
# Tareas:
# 1. Esperar a que el servicio de PostgreSQL esté completamente disponible y acepte conexiones.
#    Esto evita que la aplicación falle al arrancar si el contenedor de la base de datos
#    tarda más en iniciarse.
# 2. Ejecutar las migraciones de la base de datos con Alembic para asegurar que el
#    esquema de la base de datos esté actualizado con la última versión del código.
# 3. Ejecutar el comando principal del contenedor (CMD), que en nuestro caso es
#    `python run.py`, para iniciar el bot.
#
# `set -e`: Este comando es crucial. Asegura que el script se detenga inmediatamente
# si cualquier comando falla (devuelve un código de salida distinto de cero).
#
set -e

# --- PASO 1: Esperar a PostgreSQL ---
echo "--- [Entrypoint] Esperando a que PostgreSQL esté disponible... ---"
# El host 'postgres' es el nombre del servicio definido en docker-compose.yml.
# El comando `nc -z` (netcat) intenta establecer una conexión sin enviar datos.
# El bucle `while` se repetirá hasta que el puerto 5432 de 'postgres' esté abierto.
while ! nc -z postgres 5432; do
  sleep 0.1
done
echo "--- [Entrypoint] ✅ PostgreSQL está listo. ---"


# --- PASO 2: Ejecutar Migraciones de la Base de Datos ---
echo "--- [Entrypoint] Ejecutando migraciones de la base de datos con Alembic... ---"
# `alembic upgrade head` aplica todas las migraciones pendientes desde la última
# versión registrada en la base de datos hasta la última versión en los archivos.
alembic upgrade head
echo "--- [Entrypoint] ✅ Migraciones completadas. ---"


# --- PASO 3: Ejecutar el Comando Principal ---
echo "--- [Entrypoint] Iniciando la aplicación principal del bot... ---"
# `exec "$@"` es una construcción de shell especial.
# 'exec' reemplaza el proceso actual del script con el nuevo comando, lo que es
# más eficiente y permite que las señales del sistema (como un 'docker stop')
# lleguen directamente a la aplicación de Python.
# `"$@"` expande todos los argumentos que se pasaron al script. En nuestro caso,
# `docker-compose.yml` pasa `python run.py`, por lo que este comando se convierte en
# `exec python run.py`.
exec "$@"
# === FIN: entrypoint.sh ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
APScheduler==3.10.1
python-dateutil
psycopg2-binary==2.9.9
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
"""
Punto de Entrada Principal de la Aplicación Runegram MUD.

Este script es el responsable de orquestar el arranque del bot. Sus tareas principales son:
1. Configurar el sistema de logging global para toda la aplicación.
2. Definir y registrar las funciones `on_startup` y `on_shutdown` que se ejecutarán
   al iniciar y detener el bot, respectivamente.
3. Iniciar el "polling" de Aiogram, que es el bucle principal que escucha los
   mensajes de Telegram.

Para ejecutar la aplicación, se llama a este script desde el `entrypoint.sh`
dentro del contenedor Docker.
"""

import logging
import asyncio
import sys
from aiogram import executor

from src.bot.dispatcher import dp
from src.services import world_loader_service, ticker_service, online_service
from src.db import async_session_factory

# Esta importación es crucial para que los manejadores de mensajes se registren.
import src.handlers

async def on_startup(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se inicia con éxito.
    Inicializa todos los sistemas principales del juego.
    """
    logging.info("Iniciando secuencia de arranque del bot...")

    try:
        # 1. Inicia el scheduler. Es importante que se inicie antes de que cualquier
        #    otro servicio intente añadir tareas.
        ticker_service.initialize_scheduler()

        # 2. Crea una sesión de base de datos para las tareas de inicialización.
        async with async_session_factory() as session:
            # Sincroniza el mundo estático (salas, salidas) desde los archivos de prototipos.
            await world_loader_service.sync_world_from_prototypes(session)

            # Carga y programa los tickers de los objetos que ya existen en la base de datos.
            await ticker_service.load_and_schedule_all_tickers(session)

        # 3. Añade el ticker global que se ejecuta periódicamente para comprobar
        #    el estado de inactividad (AFK) de los jugadores.
        ticker_service.scheduler.add_job(
            online_service.check_for_newly_afk_players,
            'interval',
            seconds=60,
            id="global_afk_check",
            replace_existing=True
        )
        logging.info("Ticker global para chequeo de AFK añadido.")

        logging.info("✅ Secuencia de arranque finalizada. El bot está en línea.")

    except Exception:
        # Si algo falla catastróficamente durante el arranque, lo registramos
        # y detenemos la aplicación para evitar un estado inconsistente.
        logging.exception("❌ Error fatal durante la secuencia de arranque. El bot se detendrá.")
        # Obtenemos el bucle de eventos actual y lo detenemos.
        loop = asyncio.get_running_loop()
        loop.stop()


async def on_shutdown(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se detiene.
    Se asegura de que los servicios se apaguen de forma limpia.
    """
    logging.warning("Iniciando secuencia de apagado del bot...")
    if ticker_service.scheduler.running:
        ticker_service.scheduler.shutdown()
        logging.info("Scheduler detenido limpiamente.")
    logging.warning("Bot detenido.")


def main():
    """
    Configura el logging principal y arranca el bot.
    """
    # Configuración de logging para que todos los mensajes (INFO, WARNING, ERROR, etc.)
    # se muestren en la consola del contenedor Docker con un formato claro.
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s [%(levelname)s] - %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # Inicia el bucle de Aiogram que escucha los mensajes de Telegram.
    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)


if __name__ == "__main__":
    main()
# === FIN: run.py ===


# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACIÓN DEL PATH ---
# Añade el directorio raíz del proyecto al sys.path para que Python
# pueda encontrar nuestros módulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACIÓN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneración
# y la configuración (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---
# Aquí sobrescribimos la URL de la base de datos que está en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuración de la aplicación.
# Esto centraliza la configuración y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Función auxiliar que Alembic ejecutará de forma síncrona
    una vez que la conexión asíncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor asíncrono
    # a partir de la URL de nuestra configuración.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma asíncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""Añadir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser más explícitos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # Nota: La columna 'exits' de tipo JSONB será eliminada por una migración posterior,
        # así que la dejamos aquí por ahora para mantener la consistencia histórica.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # Añadimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Rellenamos las filas existentes con un ID de sala por defecto (1).
    # Esto es necesario para que la siguiente línea (nullable=False) no falle en bases de datos existentes.
    # El `create_character` service y el `world_loader` aseguran que la sala con ID 1 (limbo) exista.
    op.execute('UPDATE characters SET room_id = 1 WHERE room_id IS NULL')

    # Ahora sí, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final.
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""Añadir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""Añadir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/abe6da21ae81_añadir_columna_de_estado_a_las_cuentas.py ===
"""Añadir columna de estado a las cuentas

Revision ID: abe6da21ae81
Revises: f17a871c68a1
Create Date: <LA FECHA SE GENERA AUTOMÁTICamente>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'abe6da21ae81'
down_revision = 'f17a871c68a1'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('accounts', sa.Column('status', sa.String(length=20), server_default='ACTIVE', nullable=False))
    # NOTA: Se han eliminado las líneas autogeneradas que intentaban
    # borrar la tabla 'apscheduler_jobs', ya que esa tabla es gestionada
    # por otra migración y no por los modelos de la aplicación.
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('accounts', 'status')
    # NOTA: Se han eliminado las líneas autogeneradas que intentaban
    # recrear la tabla 'apscheduler_jobs' en el downgrade.
    # ### end Alembic commands ###
# === FIN: alembic/versions/abe6da21ae81_añadir_columna_de_estado_a_las_cuentas.py ===


# === INICIO: alembic/versions/cdb486941d55_añadir_key_a_las_salas_para_prototipos.py ===
# alembic/script.py.mako

"""Añadir key a las salas para prototipos

Revision ID: cdb486941d55
Revises: 57531370cbd7
Create Date: 2025-09-30 12:53:43.463923+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cdb486941d55'
down_revision = '57531370cbd7'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('key', sa.String(length=50), nullable=True))
    op.create_index(op.f('ix_rooms_key'), 'rooms', ['key'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_rooms_key'), table_name='rooms')
    op.drop_column('rooms', 'key')
    # ### end Alembic commands ###
# === FIN: alembic/versions/cdb486941d55_añadir_key_a_las_salas_para_prototipos.py ===


# === INICIO: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===
"""Crear tabla para apscheduler jobs

Revision ID: db2dac1704aa
Revises: cdb486941d55
Create Date: <LA FECHA SE GENERA AUTOMÁTICAMENTE>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db2dac1704aa'
down_revision = 'cdb486941d55'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Crea la tabla 'apscheduler_jobs' con el esquema exacto que espera
    la librería APScheduler para su SQLAlchemyJobStore.
    """
    op.create_table(
        'apscheduler_jobs',
        sa.Column('id', sa.Unicode(191), primary_key=True),
        sa.Column('next_run_time', sa.Float(25), index=True),
        sa.Column('job_state', sa.LargeBinary, nullable=False)
    )


def downgrade() -> None:
    """
    Elimina la tabla 'apscheduler_jobs' si se revierte la migración.
    """
    op.drop_table('apscheduler_jobs')
# === FIN: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===


# === INICIO: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===
"""Crear tabla de configuraciones de personaje

Revision ID: f17a871c68a1
Revises: db2dac1704aa
Create Date: 2025-09-30 14:49:51.717892+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'f17a871c68a1'
down_revision = 'db2dac1704aa'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('character_settings',
    sa.Column('character_id', sa.BigInteger(), nullable=False),
    sa.Column('active_channels', postgresql.JSONB(astext_type=sa.Text()), server_default='{}', nullable=False),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.PrimaryKeyConstraint('character_id')
    )
    # --- Las líneas problemáticas han sido eliminadas de aquí ---
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('character_settings')
    # --- Las líneas problemáticas han sido eliminadas de aquí ---
    # ### end Alembic commands ###
# === FIN: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    accounts_table = op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

    # --- INICIO DE LA SECCIÓN DE SEEDING ---
    # Aquí insertamos la cuenta del administrador después de crear la tabla.
    # Usamos op.bulk_insert para añadir datos de forma segura dentro de una migración.
    op.bulk_insert(accounts_table,
        [
            {'telegram_id': 1648877346, 'role': 'ADMINISTRADOR'},
        ]
    )
    # --- FIN DE LA SECCIÓN DE SEEDING ---

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # --- SECCIÓN DE SEEDING (INVERSA) ---
    # Si hacemos downgrade, también eliminamos los datos que añadimos.
    op.execute("DELETE FROM accounts WHERE telegram_id = 1648877346")
    # --- FIN DE LA SECCIÓN DE SEEDING ---

    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===


# === INICIO: commands/__init__.py ===
# === FIN: commands/__init__.py ===


# === INICIO: commands/command.py ===
# commands/command.py
"""
Módulo que define la Clase Base para todos los Comandos.

Este archivo contiene la clase `Command`, que actúa como una plantilla o "contrato"
para todos los comandos del juego. Cada comando, ya sea de jugador o de administrador,
debe heredar de esta clase.

Esto asegura que todos los comandos tengan una estructura consistente y puedan ser
manejados de manera uniforme por el dispatcher principal.
"""

from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character

class Command:
    """
    Clase base abstracta para todos los comandos del juego.

    Atributos:
        names (list[str]): Una lista de alias que pueden invocar este comando.
                           El primer nombre de la lista se considera el principal.
        lock (str): Un string de permisos que el `permission_service` evaluará
                    para determinar si el personaje puede ejecutar el comando.
        description (str): Una breve descripción del propósito del comando, utilizada
                           para actualizar la lista de comandos en el cliente de Telegram.
    """
    lock: str = ""
    description: str = "Un comando sin descripción."

    def __init__(self, names: list[str] = None, description: str = None):
        """
        Inicializador que permite la creación de instancias de comandos
        con alias y descripciones dinámicas.

        Esto es especialmente útil para crear múltiples comandos a partir de una
        sola clase, como los comandos de movimiento (`/norte`, `/sur`, etc.).

        Args:
            names (list[str], optional): La lista de alias para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
            description (str, optional): La descripción para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
        """
        if names:
            self.names = names
        elif not hasattr(self, 'names'):
            self.names = []

        if description:
            self.description = description
        elif not hasattr(self, 'description'):
            # Asegura que siempre haya una descripción por defecto.
            self.description = "Un comando sin descripción."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """
        El método principal que se ejecuta cuando se llama al comando.

        Este método debe ser sobrescrito por cada clase de comando hija.

        Args:
            character (Character): El objeto del personaje que ejecuta el comando,
                                   precargado con todas sus relaciones.
            session (AsyncSession): La sesión de base de datos activa para esta
                                    interacción.
            message (types.Message): El objeto de mensaje de Aiogram que contiene
                                     el texto original, el ID del chat, etc.
            args (list[str]): Una lista de los argumentos proporcionados por el
                              usuario después del nombre del comando.
        """
        # Este método está pensado para ser sobrescrito. Si una subclase no lo
        # implementa, lanzar un NotImplementedError es una buena práctica para
        # detectar errores durante el desarrollo.
        raise NotImplementedError
# === FIN: commands/command.py ===


# === INICIO: commands/admin/__init__.py ===

from . import building
from . import movement
from . import info
# === FIN: commands/admin/__init__.py ===


# === INICIO: commands/admin/building.py ===
# commands/admin/building.py
"""
Módulo de Comandos Administrativos para la Generación de Entidades.

Este archivo contiene los comandos que permiten a los administradores "generar"
o "invocar" (`spawn`) entidades en el mundo a partir de sus prototipos
definidos en `game_data`.

Estos comandos no se usan para construir el mundo estático (eso lo hace el
`world_loader_service`), sino para añadir contenido dinámico durante el juego,
como objetos para un evento o PNJ para una misión.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service
from game_data.item_prototypes import ITEM_PROTOTYPES

class CmdGenerarObjeto(Command):
    """
    Comando para un administrador para crear una instancia de un objeto
    a partir de un prototipo y colocarla en la sala actual.
    """
    names = ["generarobjeto", "genobj"]
    lock = "rol(ADMINISTRADOR)"
    description = "Genera un objeto en la sala a partir de su clave de prototipo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # Validación de entrada
        if not args:
            await message.answer("Uso: /generarobjeto [key_del_prototipo]")
            return

        item_key = args[0].lower()

        try:
            # Llama al servicio para crear la instancia del objeto en la base de datos.
            item = await item_service.spawn_item_in_room(session, character.room_id, item_key)

            # Obtenemos el nombre "bonito" del prototipo para el mensaje de confirmación.
            item_name = ITEM_PROTOTYPES.get(item.key, {}).get("name", "un objeto desconocido")

            await message.answer(f"✅ Objeto '{item_name}' generado en la sala actual.")

        except ValueError as e:
            # Este error se lanza desde `item_service` si la `item_key` no existe.
            await message.answer(f"❌ Error: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creación.
            await message.answer("❌ Ocurrió un error inesperado al generar el objeto.")
            logging.exception(f"Fallo al ejecutar /generarobjeto con la clave '{item_key}'")

# Exportamos la lista de comandos de este módulo.
# En el futuro, aquí se podrían añadir comandos como /generarnpc.
SPAWN_COMMANDS = [
    CmdGenerarObjeto(),
]
# === FIN: commands/admin/building.py ===


# === INICIO: commands/admin/info.py ===
# commands/admin/info.py
"""
Módulo de Comandos Administrativos de Información.

Este archivo contiene comandos diseñados para que los administradores puedan
consultar el estado interno del juego. Son herramientas de solo lectura
que ayudan a supervisar, depurar y obtener una visión general del mundo
sin modificarlo.

Ejemplos futuros podrían incluir: /donde [jugador], /infoobjeto [id], etc.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character, Room

class CmdListarSalas(Command):
    """
    Comando que muestra una lista de todas las salas existentes en el mundo,
    incluyendo su ID, su clave de prototipo y su nombre.
    """
    names = ["listarsalas", "lsalas"]
    lock = "rol(ADMINISTRADOR)"
    description = "Muestra ID, Clave y Nombre de todas las salas del mundo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """Ejecuta la consulta y formatea la lista de salas."""
        try:
            # 1. Realizar la consulta a la base de datos para obtener todas las salas.
            # Se ordenan por ID para una visualización consistente.
            result = await session.execute(select(Room).order_by(Room.id))
            all_rooms = result.scalars().all()

            if not all_rooms:
                await message.answer("No se encontraron salas en la base de datos.")
                return

            # 2. Construir el mensaje de respuesta línea por línea.
            response_lines = ["<b>Lista de Salas del Mundo:</b>"]
            for room in all_rooms:
                # El formato con `<` alinea el texto a la izquierda, rellenando con espacios.
                # `room.id:<4}` -> ID, alineado a la izquierda, 4 caracteres de ancho.
                # `room.key:<20}` -> Key, alineado a la izquierda, 20 caracteres de ancho.
                response_lines.append(f"ID: {room.id:<4} | Key: {room.key:<20} | Nombre: {room.name}")

            body = "\n".join(response_lines)

            # 3. Envolver el cuerpo completo en una etiqueta <pre> para asegurar
            #    un formato de monoespaciado y una alineación perfecta de las columnas.
            response_text = f"<pre>{body}</pre>"

            await message.answer(response_text, parse_mode="HTML")

        except Exception:
            # Captura cualquier error inesperado durante la consulta a la base de datos.
            await message.answer("❌ Ocurrió un error al intentar listar las salas.")
            logging.exception("Fallo al ejecutar /listarsalas")

# Exportamos la lista de comandos de este módulo.
INFO_COMMANDS = [
    CmdListarSalas(),
]
# === FIN: commands/admin/info.py ===


# === INICIO: commands/admin/movement.py ===
# commands/admin/movement.py
"""
Módulo de Comandos Administrativos para el Movimiento.

Este archivo contiene comandos que otorgan a los administradores capacidades
de movimiento especiales, que no están sujetas a las reglas normales del juego
(como las salidas definidas en una sala).

Son herramientas esenciales para la construcción, supervisión y depuración del mundo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service
from src.utils.presenters import show_current_room

class CmdTeleport(Command):
    """
    Comando para teletransportar al administrador a cualquier sala del juego
    especificando su ID numérico.
    """
    names = ["teleport", "tp"]
    lock = "rol(ADMINISTRADOR)"
    description = "Teletranspórtate a cualquier sala usando su ID."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario.
        if not args:
            await message.answer("Uso: /teleport [ID_sala]")
            return

        try:
            # Intentamos convertir el primer argumento a un número entero.
            to_room_id = int(args[0])
        except (ValueError, IndexError):
            # Falla si no hay argumentos o si el argumento no es un número.
            await message.answer("El ID de la sala debe ser un número válido.")
            return

        try:
            # 2. Llamar al servicio que contiene la lógica de negocio.
            await player_service.teleport_character(session, character.id, to_room_id)

            # 3. Notificar al administrador del éxito y mostrar la nueva ubicación.
            await message.answer(f"🚀 Teletransportado a la sala {to_room_id}.")
            await show_current_room(message)

        except Exception as e:
            # Capturamos cualquier error que pueda ocurrir durante el teletransporte,
            # como un ID de sala que no existe (manejado por `player_service`).
            await message.answer(f"❌ Error al teletransportar: {e}")
            logging.warning(f"Fallo al ejecutar /teleport a la sala {args[0]}: {e}")

# Exportamos la lista de comandos de este módulo.
ADMIN_MOVEMENT_COMMANDS = [
    CmdTeleport(),
]
# === FIN: commands/admin/movement.py ===


# === INICIO: commands/player/__init__.py ===
from . import general
from . import character
from . import interaction
from . import movement
from . import channels
# === FIN: commands/player/__init__.py ===


# === INICIO: commands/player/channels.py ===
# commands/player/channels.py
"""
Módulo de Comandos para la Interacción con Canales de Chat.

Este archivo contiene los comandos que permiten a los jugadores gestionar
sus suscripciones a canales y comunicarse a través de ellos.

Incluye:
- Comandos de gestión (ej: /canales, /canal).
- Un comando específico por cada canal de tipo 'CHAT' (ej: /novato).
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdChannel(Command):
    """
    Comando para que un jugador active o desactive un canal.
    """
    names = ["canal"]
    description = "Activa o desactiva un canal. Uso: /canal [activar|desactivar] [nombre]."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario (acción y nombre del canal).
        if not args or len(args) < 2 or args[0].lower() not in ["activar", "desactivar"]:
            await message.answer("Uso: /canal [activar|desactivar] [nombre_canal]")
            return

        action = args[0].lower()
        channel_key = args[1].lower()

        try:
            # 2. Llamar al servicio para persistir el cambio en la configuración del personaje.
            await channel_service.set_channel_status(session, character, channel_key, activate=(action == "activar"))
            await message.answer(f"✅ Has {action}do el canal '{channel_key}'.")
        except ValueError as e:
            # Captura el error si el `channel_key` no existe.
            await message.answer(f"❌ Error: {e}")
        except Exception:
            await message.answer("❌ Ocurrió un error al modificar el estado del canal.")
            logging.exception(f"Fallo al ejecutar /canal para {character.name}")

class CmdChannels(Command):
    """
    Comando para listar todos los canales disponibles y el estado de suscripción del jugador.
    """
    names = ["canales"]
    description = "Muestra los canales disponibles y su estado (activado/desactivado)."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # 1. Obtener la configuración de canales del jugador.
            settings = await channel_service.get_or_create_settings(session, character)
            user_channels = settings.active_channels.get("active_channels", [])

            # 2. Construir la lista formateada para el mensaje.
            response = ["<b>Estado de tus Canales:</b>"]
            for key, proto in CHANNEL_PROTOTYPES.items():
                status = "✅ Activado" if key in user_channels else "❌ Desactivado"
                response.append(f"- <b>{proto['name']}</b> ({key}): {status}\n  <i>{proto['description']}</i>")

            await message.answer("\n".join(response), parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al listar los canales.")
            logging.exception(f"Fallo al ejecutar /canales para {character.name}")


class CmdNovato(Command):
    """
    Comando para enviar un mensaje al canal 'novato'.
    """
    names = ["novato"]
    lock = ""
    description = "Envía un mensaje por el canal de ayuda para novatos."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("Uso: /novato [mensaje]")
                return

            # 1. Verificar si el jugador tiene el canal activado.
            settings = await channel_service.get_or_create_settings(session, character)
            if not await channel_service.is_channel_active(settings, "novato"):
                await message.answer("Tienes el canal 'novato' desactivado. Actívalo con:\n/canal activar novato")
                return

            # 2. Formatear y transmitir el mensaje a través del servicio.
            channel_message = f"[{character.name}] {' '.join(args)}"
            await channel_service.broadcast_to_channel(session, "novato", channel_message, exclude_character_id=character.id)

            # 3. Enviar una confirmación al propio jugador para que vea su mensaje.
            await message.answer(f"📢 <b>Novato:</b> {channel_message}", parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al enviar tu mensaje al canal.")
            logging.exception(f"Fallo al ejecutar /novato para {character.name}")

# Exportamos la lista de comandos de este módulo.
CHANNEL_COMMANDS = [
    CmdChannel(),
    CmdChannels(),
    CmdNovato(),
]
# === FIN: commands/player/channels.py ===


# === INICIO: commands/player/character.py ===
# commands/player/character.py
"""
Módulo de Comandos para la Gestión del Personaje.

Este archivo contiene los comandos que permiten a los jugadores gestionar
el ciclo de vida de su personaje en el juego.

El comando principal aquí es `/crearpersonaje`, que es el primer comando que
un nuevo jugador debe usar para entrar al mundo de Runegram.

Futuros comandos como `/borrarpersonaje` o `/descripcion` también pertenecerían
a este módulo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service

class CmdCreateCharacter(Command):
    """
    Comando para que un nuevo usuario cree su personaje.
    """
    names = ["crearpersonaje"]
    description = "Crea tu personaje para empezar a jugar."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """
        Gestiona la lógica de creación de un nuevo personaje.
        """
        # 1. Comprobar si el jugador ya tiene un personaje.
        # El objeto 'character' solo es None si la cuenta no tiene un personaje asociado.
        if character:
            await message.answer("Ya tienes un personaje.")
            return

        # 2. Validar el nombre proporcionado por el usuario.
        character_name = " ".join(args)
        if not character_name or len(character_name) > 50:
            await message.answer("Por favor, proporciona un nombre válido (máx 50 caracteres). Uso: /crearpersonaje [nombre]")
            return

        try:
            # 3. Llamar al servicio que contiene la lógica de negocio para la creación.
            new_char = await player_service.create_character(session, message.from_user.id, character_name)

            # 4. Enviar un mensaje de éxito al jugador.
            await message.answer(
                f"¡Tu personaje, {new_char.name}, ha sido creado con éxito!\n"
                "Ahora estás listo para explorar el mundo de Runegram. ¡Envía /start para comenzar!"
            )
        except ValueError as e:
            # Captura errores de negocio específicos lanzados por `player_service`,
            # como "El nombre ya está en uso".
            await message.answer(f"No se pudo crear el personaje: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creación.
            # Gracias al `logging.exception`, veremos el traceback completo en los logs
            # del contenedor, lo que es vital para depurar errores sutiles de la base de datos.
            await message.answer("Ocurrió un error inesperado al crear tu personaje.")
            logging.exception(f"Error finalizando la creación del personaje para {message.from_user.id}")

# Exportamos la lista de comandos de este módulo.
CHARACTER_COMMANDS = [
    CmdCreateCharacter(),
]
# === FIN: commands/player/character.py ===


# === INICIO: commands/player/general.py ===
# commands/player/general.py
"""
Módulo de Comandos Generales del Jugador.

Este archivo agrupa los comandos más básicos y fundamentales que un jugador
utiliza para interactuar con el mundo y obtener información esencial sobre su
entorno y su personaje.

Estos comandos están disponibles para todos los jugadores en todo momento.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.utils.presenters import show_current_room
from src.services import script_service, online_service

class CmdLook(Command):
    """
    Comando para observar el entorno actual (la sala) o un objeto o
    personaje específico dentro de ella.
    """
    names = ["mirar", "m", "l"]
    lock = ""
    description = "Observa tu entorno o un objeto/personaje específico."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # Si no se proporcionan argumentos, el jugador mira la sala.
            if not args:
                await show_current_room(message)
                return

            target_name = " ".join(args).lower()
            found_target = None

            # 1. Buscar en los objetos de la sala.
            if character.room.items:
                for item in character.room.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # 2. Si no se encontró, buscar en el inventario del personaje.
            if not found_target and character.items:
                for item in character.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # Futuro: 3. Buscar otros personajes en la sala.
            # Futuro: 4. Buscar NPCs en la sala.

            if not found_target:
                await message.answer("No ves eso por aquí.")
                return

            # Mostramos la descripción del objeto encontrado.
            await message.answer(f"<pre>{found_target.get_description()}</pre>", parse_mode="HTML")

            # Finalmente, disparamos el evento on_look si el objeto tiene un script asociado.
            if "on_look" in found_target.prototype.get("scripts", {}):
                await script_service.execute_script(
                    script_string=found_target.prototype["scripts"]["on_look"],
                    session=session,
                    character=character,
                    target=found_target
                )
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar mirar.")
            logging.exception(f"Fallo al ejecutar /mirar para {character.name}")

class CmdSay(Command):
    """
    Comando para que el personaje hable a otros en la misma sala.
    """
    names = ["decir", "'"]
    lock = ""
    description = "Habla con las personas que están en tu misma sala."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("¿Qué quieres decir?")
            return

        # Futuro: Este mensaje debería ser transmitido a otros jugadores en la sala.
        say_text = " ".join(args)
        await message.answer(f"Dices: {say_text}")

class CmdInventory(Command):
    """
    Comando para mostrar al jugador los objetos que lleva en su inventario.
    """
    names = ["inventario", "inv", "i"]
    lock = ""
    description = "Muestra los objetos que llevas en tu inventario."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            inventory = character.items
            if not inventory:
                response = "No llevas nada."
            else:
                items_list = [f" - {item.get_name()}" for item in inventory]
                items_str = "\n".join(items_list)
                response = f"<b>Llevas lo siguiente:</b>\n{items_str}"

            await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al mostrar tu inventario.")
            logging.exception(f"Fallo al ejecutar /inventario para {character.name}")

class CmdHelp(Command):
    """
    Comando para mostrar un mensaje de ayuda básico con los comandos principales.
    """
    names = ["ayuda", "help"]
    lock = ""
    description = "Muestra una lista con los comandos básicos del juego."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        help_text = (
            "<b>Comandos Básicos de Runegram</b>\n"
            "---------------------------------\n"
            "/mirar - Muestra la descripción de tu entorno.\n"
            "/inventario - Muestra los objetos que llevas.\n"
            "/decir [mensaje] - Hablas a la gente en tu misma sala.\n"
            "/coger [objeto] - Recoges un objeto del suelo.\n"
            "/dejar [objeto] - Dejas un objeto que llevas.\n"
            "/quien - Muestra quién está conectado.\n"
            "/canales - Gestiona tus suscripciones a canales.\n\n"
            "Para moverte, usa /norte, /sur, etc."
        )
        await message.answer(f"<pre>{help_text}</pre>", parse_mode="HTML")

class CmdWho(Command):
    """
    Comando social que muestra una lista de todos los personajes que
    están actualmente conectados al juego.
    """
    names = ["quien", "who"]
    lock = ""
    description = "Muestra una lista de los jugadores conectados."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            online_characters = await online_service.get_online_characters(session)

            # Si la lista está vacía o solo contiene al jugador actual, se muestra
            # un mensaje indicando que está solo.
            if not online_characters or (len(online_characters) == 1 and online_characters[0].id == character.id):
                await message.answer("Eres la única alma aventurera en este mundo ahora mismo.")
                return

            response_lines = [f"<b>Hay {len(online_characters)} aventureros en Runegram:</b>"]
            # Ordenamos la lista alfabéticamente por nombre para una visualización clara.
            for char in sorted(online_characters, key=lambda c: c.name):
                response_lines.append(f"- {char.name}")

            response_text = "\n".join(response_lines)
            await message.answer(f"<pre>{response_text}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al obtener la lista de jugadores.")
            logging.exception(f"Fallo al ejecutar /quien para {character.name}")

# Exportamos la lista de comandos de este módulo.
GENERAL_COMMANDS = [
    CmdLook(),
    CmdSay(),
    CmdInventory(),
    CmdHelp(),
    CmdWho(),
]
# === FIN: commands/player/general.py ===


# === INICIO: commands/player/interaction.py ===
# commands/player/interaction.py
"""
Módulo de Comandos de Interacción con Objetos.

Este archivo contiene los comandos que permiten al jugador manipular directamente
los objetos (`Items`) en el mundo del juego.

Incluye acciones fundamentales como coger objetos del entorno y dejar
objetos del inventario.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service, command_service, player_service

class CmdGet(Command):
    """
    Comando para que un jugador recoja un objeto del suelo en su sala actual
    y lo añada a su inventario.
    """
    names = ["coger", "g"]
    lock = ""
    description = "Recoge un objeto del suelo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¿Qué quieres coger?")
                return

            item_name_to_get = " ".join(args).lower()
            item_to_get = None

            # Buscamos el objeto en la lista de items de la sala actual.
            for item in character.room.items:
                if item_name_to_get in item.get_name().lower():
                    item_to_get = item
                    break

            if not item_to_get:
                await message.answer("No ves eso por aquí.")
                return

            # Llamamos al servicio para actualizar la ubicación del objeto en la BD.
            await item_service.move_item_to_character(session, item_to_get.id, character.id)

            # Si el objeto que cogimos otorga un CommandSet, debemos actualizar la
            # lista de comandos del jugador en Telegram.
            if item_to_get.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has cogido: {item_to_get.get_name()}")
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar coger el objeto.")
            logging.exception(f"Fallo al ejecutar /coger para {character.name}")


class CmdDrop(Command):
    """
    Comando para que un jugador deje un objeto de su inventario en el suelo
    de su sala actual.
    """
    names = ["dejar", "d"]
    lock = ""
    description = "Deja un objeto de tu inventario en el suelo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¿Qué quieres dejar?")
                return

            item_name_to_drop = " ".join(args).lower()
            item_to_drop = None

            # Buscamos el objeto en el inventario del personaje.
            for item in character.items:
                if item_name_to_drop in item.get_name().lower():
                    item_to_drop = item
                    break

            if not item_to_drop:
                await message.answer("No llevas eso.")
                return

            # Llamamos al servicio para actualizar la ubicación del objeto en la BD.
            await item_service.move_item_to_room(session, item_to_drop.id, character.room_id)

            # Si el objeto que dejamos otorgaba un CommandSet, debemos actualizar la
            # lista de comandos del jugador en Telegram.
            if item_to_drop.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has dejado: {item_to_drop.get_name()}")
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar dejar el objeto.")
            logging.exception(f"Fallo al ejecutar /dejar para {character.name}")


# Exportamos la lista de comandos de este módulo.
INTERACTION_COMMANDS = [
    CmdGet(),
    CmdDrop(),
]
# === FIN: commands/player/interaction.py ===


# === INICIO: commands/player/movement.py ===
# commands/player/movement.py
"""
Módulo de Comandos de Movimiento del Jugador.

Este archivo centraliza toda la lógica relacionada con el desplazamiento del
personaje por el mundo del juego.

Utiliza una única clase genérica, `CmdMove`, que se instancia para cada una de
las direcciones posibles (norte, sur, etc.), cada una con sus propios alias.
Esto evita la duplicación de código y mantiene la lógica de movimiento en un
solo lugar.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service
from src.utils.presenters import show_current_room

class CmdMove(Command):
    """
    Comando genérico que gestiona el movimiento del jugador en una dirección.
    La dirección específica se determina por el nombre principal del comando
    (el primer elemento en la lista `names`).
    """
    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            # 1. Determinar la dirección basándose en el comando invocado.
            #    Por ejemplo, si se usa `/n`, self.names[0] será "norte".
            direction = self.names[0]

            # 2. Buscar si existe una salida válida en esa dirección desde la sala actual.
            target_exit = next(
                (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == direction),
                None
            )

            if not target_exit:
                await message.answer("No puedes ir en esa dirección.")
                return

            # Futuro: Aquí se integrará la lógica de `permission_service` para
            # comprobar si la salida (`target_exit`) tiene un `lock`.

            # 3. Mover al personaje a la nueva sala.
            await player_service.teleport_character(session, character.id, target_exit.to_room_id)

            # 4. Actualizar la lista de comandos del jugador en Telegram.
            #    Esto es crucial porque la nueva sala podría otorgar o quitar CommandSets.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            await command_service.update_telegram_commands(refreshed_character)

            # 5. Mostrar al jugador la descripción de su nueva ubicación.
            await show_current_room(message)

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar moverte.")
            logging.exception(f"Fallo al ejecutar /mover ({self.names[0]}) para {character.name}")

# --- Creación del Command Set con descripciones ---
# Se crea una instancia de `CmdMove` para cada dirección, asignando sus alias
# y una descripción clara para la lista de comandos de Telegram.
MOVEMENT_COMMANDS = [
    CmdMove(names=["norte", "n"], description="Moverse hacia el norte."),
    CmdMove(names=["sur", "s"], description="Moverse hacia el sur."),
    CmdMove(names=["este", "e"], description="Moverse hacia el este."),
    CmdMove(names=["oeste", "o"], description="Moverse hacia el oeste."),
    CmdMove(names=["arriba", "ar"], description="Moverse hacia arriba."),
    CmdMove(names=["abajo", "ab"], description="Moverse hacia abajo."),
    CmdMove(names=["noreste", "ne"], description="Moverse hacia el noreste."),
    CmdMove(names=["noroeste", "no"], description="Moverse hacia el noroeste."),
    CmdMove(names=["sureste", "se"], description="Moverse hacia el sureste."),
    CmdMove(names=["suroeste", "so"], description="Moverse hacia el suroeste."),
]
# === FIN: commands/player/movement.py ===


# === INICIO: game_data/__init__.py ===
# === FIN: game_data/__init__.py ===


# === INICIO: game_data/channel_prototypes.py ===
# game_data/channel_prototypes.py
"""
Definición de Prototipos de Canales de Chat.

Este archivo actúa como la "Fuente de la Verdad" para todos los canales de
comunicación globales disponibles en el juego. El `channel_service` utiliza
esta información para gestionar las suscripciones y formatear los mensajes.

Añadir un nuevo canal al juego es tan simple como añadir una nueva entrada
a este diccionario.

Estructura de un Prototipo de Canal:
- <clave_unica>: (ej: "novato")
    - "name": (str) El nombre del canal que ven los jugadores.
    - "icon": (str) Un icono emoji que precede a los mensajes del canal.
    - "description": (str) Una breve explicación que se muestra en el comando /canales.
    - "type": (str) Define el comportamiento del canal:
        - "CHAT": Los jugadores pueden enviar mensajes a través de un comando (ej: /novato).
        - "BROADCAST": Solo el sistema puede enviar mensajes (ej: anuncios).
    - "default_on": (bool) Si es `True`, los nuevos personajes se suscriben
                    automáticamente a este canal al ser creados.
"""

CHANNEL_PROTOTYPES = {
    # Canal para que los nuevos jugadores puedan hacer preguntas.
    "novato": {
        "name": "Novato",
        "icon": "📢",
        "description": "Un canal para que los nuevos aventureros pidan ayuda.",
        "type": "CHAT",
        "default_on": True,
    },

    # Canal para notificaciones automáticas del juego.
    "sistema": {
        "name": "Sistema",
        "icon": "⚙️",
        "description": "Anuncios automáticos del juego, como estados de actividad.",
        "type": "BROADCAST",
        "default_on": True,
    },

    # --- Futuros canales podrían ir aquí ---
    # "comercio": {
    #     "name": "Comercio",
    #     "icon": "💰",
    #     "description": "Para comprar y vender objetos con otros jugadores.",
    #     "type": "CHAT",
    #     "default_on": True,
    # },
    # "anuncios": {
    #     "name": "Anuncios",
    #     "icon": "📜",
    #     "description": "Noticias y eventos importantes del mundo.",
    #     "type": "BROADCAST",
    #     "default_on": True,
    # }
}
# === FIN: game_data/channel_prototypes.py ===


# === INICIO: game_data/item_prototypes.py ===
# game_data/item_prototypes.py
"""
Definición de Prototipos de Objetos (Items).

Este archivo es el catálogo central de todos los objetos que pueden existir
en el mundo de Runegram. Sigue un sistema de prototipos, lo que significa que
este archivo define las "plantillas" o "planos" de los objetos, mientras que
la base de datos solo almacena las "instancias" individuales de esos objetos
(su ubicación, si tienen un nombre personalizado, etc.).

Esta separación es clave para la filosofía de diseño del motor, permitiendo
añadir cientos de objetos nuevos sin modificar el código fuente ni la
estructura de la base de datos.

Estructura de un Prototipo de Objeto:
- <clave_unica>: (ej: "espada_viviente")
    - "name": (str) El nombre que ven los jugadores (ej: "una espada viviente").
    - "keywords": (list[str]) Palabras clave para que los jugadores puedan interactuar
                    con el objeto (ej: /mirar espada).
    - "description": (str) El texto que se muestra al mirar el objeto.
    - "scripts": (dict, opcional) Define scripts reactivos a eventos.
        - "on_look": (str) El script a ejecutar cuando un jugador mira el objeto.
    - "tickers": (list[dict], opcional) Define scripts proactivos que se ejecutan
                 periódicamente.
        - "schedule": (str) El horario (cron o intervalo).
        - "script": (str) El script a ejecutar.
        - "category": (str) La categoría del ticker (ej: "ambient").
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que este
                             objeto otorga al personaje que lo posea.
"""

ITEM_PROTOTYPES = {
    # Un objeto mágico que susurra secretos periódicamente.
    "espada_viviente": {
        "name": "una espada viviente",
        "description": "La hoja de acero parece retorcerse y susurrarte secretos.",
        "keywords": ["espada", "viviente"],
        "scripts": {
            # Cuando se mira, emite un brillo rojo.
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        },
        "tickers": [
            {
                # Cada 2 minutos, ejecuta el script de susurrar.
                "schedule": "*/2 * * * *",
                "script": "script_espada_susurra_secreto",
                # Se categoriza como "ambient" para no molestar a jugadores inactivos.
                "category": "ambient"
            }
        ]
    },

    # Un objeto decorativo con un ticker de intervalo.
    "corazon_sangrante": {
        "name": "un corazón sangrante",
        "description": "Late débilmente y gotea un icor oscuro.",
        "keywords": ["corazon", "sangrante"],
        "tickers": [
            {
                # Cada 30 segundos, ejecuta un script (aún por definir).
                "schedule": "interval:30",
                "script": "script_objeto_sangra_en_el_suelo",
                "category": "ambient"
            }
        ]
    },

    # --- Futuros objetos podrían ir aquí ---
    # "ganzuas_maestras": {
    #     "name": "unas ganzúas maestras",
    #     "keywords": ["ganzuas", "herramientas"],
    #     "description": "Unas herramientas de precisión para el ladrón experto.",
    #     # Este objeto otorga acceso al CommandSet "thievery" mientras se posea.
    #     "grants_command_sets": ["thievery"]
    # },
}
# === FIN: game_data/item_prototypes.py ===


# === INICIO: game_data/room_prototypes.py ===
# game_data/room_prototypes.py
"""
Definición de Prototipos de Salas (Rooms).

Este archivo es el "mapa maestro" del mundo de Runegram. Define todas las
salas estáticas, sus descripciones y, lo más importante, cómo se conectan
entre sí.

El `world_loader_service` lee este archivo al arrancar el bot para construir
o sincronizar el mundo en la base de datos.

Estructura de un Prototipo de Sala:
- <clave_unica>: (ej: "plaza_central") Un identificador único para la sala que
                 nunca debe cambiar. Se usa para las conexiones.
    - "name": (str) El nombre de la sala que ven los jugadores.
    - "description": (str) El texto principal que se muestra al entrar o mirar la sala.
    - "exits": (dict, opcional) Define las salidas desde esta sala.
        - "<direccion>": (str) La clave única de la sala de destino.
          (ej: "norte": "camino_del_bosque"). El `world_loader_service` se
          encarga de crear automáticamente la salida de vuelta (sur).
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que esta
                             sala otorga a cualquier personaje que se encuentre en ella.
"""

ROOM_PROTOTYPES = {
    # La sala de inicio, donde aparecen todos los nuevos personajes.
    "limbo": {
        "name": "El Limbo",
        "description": "Te encuentras en una habitación vacía, suspendida en la nada. Es el comienzo de tu aventura y un refugio seguro.",
        "exits": {
            # "dirección": "clave_de_la_sala_destino"
            "norte": "plaza_central"
        }
    },

    # Un nexo central desde el que parten varios caminos.
    "plaza_central": {
        "name": "Plaza Central de Runegard",
        "description": "Estás en el corazón de la ciudad. El bullicio de mercaderes y aventureros llena el aire. Varios caminos parten desde aquí.",
        "exits": {
            # El cargador creará automáticamente la salida 'sur' de vuelta al 'limbo'.
            "este": "calle_mercaderes"
        }
    },

    # Una sala temática.
    "calle_mercaderes": {
        "name": "Calle de los Mercaderes",
        "description": "Decenas de puestos se alinean en esta calle, ofreciendo todo tipo de mercancías exóticas.",
        "exits": {
            # El cargador creará automáticamente la salida 'oeste' de vuelta a 'plaza_central'.
        }
    },

    # --- Futuras salas podrían ir aquí ---
    # "forja_del_enano": {
    #     "name": "La Forja del Enano Errante",
    #     "description": "El calor del fuego y el rítmico martilleo sobre el yunque llenan esta sala.",
    #     "exits": {
    #         "sur": "plaza_central"
    #     },
    #     # Cualquier jugador en esta sala obtiene acceso a los comandos de herrería.
    #     "grants_command_sets": ["smithing"]
    # }
}
# === FIN: game_data/room_prototypes.py ===


# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
REM ##################################################################
REM #                                                                #
REM #           SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM              #
REM #                                                                #
REM #  Este script automatiza el proceso de limpiar por completo el  #
REM #  entorno de desarrollo de Docker y reconstruirlo desde cero.   #
REM #                                                                #
REM #  Es la herramienta principal para asegurar un estado limpio    #
REM #  después de cambios en dependencias, migraciones o si algo     #
REM #  se ha corrompido.                                             #
REM #                                                                #
REM ##################################################################

TITLE Reinicio Completo de Runegram

CLS
ECHO.
ECHO  ##################################################################
ECHO  #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO  ##################################################################
ECHO.
ECHO  ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES DE FORMA DESTRUCTIVA:
ECHO.
ECHO    1. Detendra todos los contenedores de la aplicacion.
ECHO    2. Eliminara los contenedores detenidos.
ECHO    3. [!] Eliminara el VOLUMEN de la base de datos, borrando TODOS los datos.
ECHO    4. Reconstruira la imagen Docker de la aplicacion desde cero.
ECHO    5. Levantara todos los servicios en segundo plano.
ECHO.
ECHO  Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.
ECHO  Presiona cualquier tecla para continuar o cierra esta ventana para cancelar.
PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen de datos... ---
ECHO.
REM `docker-compose down` detiene y elimina los contenedores.
REM La bandera `-v` (o `--volumes`) es crucial, ya que elimina los volúmenes
REM nombrados asociados, como `postgres_data`, asegurando un borrado total.
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo la imagen y levantando servicios... ---
ECHO.
REM `docker-compose up` levanta los servicios.
REM La bandera `--build` fuerza la reconstrucción de la imagen 'bot' desde el Dockerfile.
REM La bandera `-d` (o `--detach`) ejecuta los contenedores en segundo plano.
docker-compose up --build -d

ECHO.
ECHO  ##################################################################
ECHO  #                ¡PROCESO COMPLETADO CON EXITO!                  #
ECHO  #----------------------------------------------------------------#
ECHO  #  Los contenedores estan corriendo en segundo plano.            #
ECHO  #  Puedes ver los logs con: docker-compose logs -f bot            #
ECHO  ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/generate_snapshot.py ===
# scripts/generate_snapshot.py

import os
from pathlib import Path

# --- CONFIGURACIÓN ---

# Directorio raíz del proyecto (sube dos niveles desde este script)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# Nombre del archivo de salida
OUTPUT_FILENAME = "project_snapshot.txt"

# --- LISTA NEGRA: Directorios y archivos a IGNORAR SIEMPRE ---
# Usamos sets para una búsqueda más eficiente.
EXCLUDED_DIRS = {
    ".git",
    ".idea",
    ".vscode",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    "postgres_data",
    "node_modules",
}

EXCLUDED_FILES = {
    ".env",
    OUTPUT_FILENAME,
    "poetry.lock",
    "Pipfile.lock",
}

# Extensiones de archivo a ignorar (ej: binarios, compilados)
EXCLUDED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".egg-info",
    ".swp",
    ".db",
    ".sqlite3",
}

# --- FIN DE LA CONFIGURACIÓN ---


def write_file_content(output_file, file_path):
    """Escribe el contenido de un archivo en el archivo de salida, con un encabezado."""
    # Obtenemos la ruta relativa usando el estándar POSIX (barras /)
    relative_path = file_path.relative_to(PROJECT_ROOT).as_posix()
    print(f"  -> Añadiendo: {relative_path}")

    header = f"# === INICIO: {relative_path} ===\n"
    footer = f"# === FIN: {relative_path} ===\n\n\n"

    output_file.write(header)
    try:
        # Leemos el contenido del archivo
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            # Añadimos un salto de línea al final si no lo tiene, para un formato limpio
            if content and not content.endswith('\n'):
                content += '\n'
            output_file.write(content)
    except Exception as e:
        output_file.write(f"*** No se pudo leer el archivo: {e} ***\n")
    output_file.write(footer)


def main():
    """Función principal para generar el snapshot del proyecto."""
    output_path = PROJECT_ROOT / OUTPUT_FILENAME
    print(f"Generando snapshot del proyecto en: {output_path}\n")

    # Usaremos una lista para almacenar las rutas de los archivos a incluir
    files_to_process = []

    # os.walk recorre todos los directorios y archivos desde la raíz del proyecto
    for root, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        # Modificamos la lista de directorios 'in-place' para evitar que os.walk entre en ellos
        dirs[:] = [d for d in sorted(dirs) if d not in EXCLUDED_DIRS]

        # Procesamos los archivos del directorio actual
        for filename in sorted(files):
            # Comprobamos si el archivo o su extensión están en la lista negra
            if filename in EXCLUDED_FILES:
                continue

            file_path = Path(root) / filename
            if file_path.suffix in EXCLUDED_EXTENSIONS:
                continue

            # Si el archivo pasa todos los filtros, lo añadimos a la lista
            files_to_process.append(file_path)

    # Escribimos todos los archivos encontrados en el archivo de salida
    with open(output_path, 'w', encoding='utf-8') as output_file:
        for file_path in files_to_process:
            write_file_content(output_file, file_path)

    print(f"\n¡Snapshot generado con éxito! {len(files_to_process)} archivos procesados.")


if __name__ == "__main__":
    main()
# === FIN: scripts/generate_snapshot.py ===


# === INICIO: scripts/run_migrations.sh ===
# === FIN: scripts/run_migrations.sh ===


# === INICIO: src/__init__.py ===
# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===
# src/config.py
"""
Módulo de Configuración Centralizado.

Este archivo define la clase `Settings` que utiliza Pydantic para cargar, validar
y gestionar todas las variables de entorno necesarias para la aplicación.

Pydantic se encarga de:
1. Leer las variables desde un archivo `.env`.
2. Validar que las variables existan y tengan el tipo de dato correcto (ej: int, str).
3. Proveer un objeto `settings` único y fuertemente tipado que puede ser importado
   y utilizado en cualquier parte del proyecto.

Esto evita la dispersión de `os.getenv()` por el código y asegura que la aplicación
no arranque si falta una configuración crítica.
"""

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    """
    Define y carga todas las variables de entorno de la aplicación.
    """
    # Telegram
    bot_token: SecretStr

    # Database (PostgreSQL)
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Cache y Estados (Redis)
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        """
        Genera la URL de conexión a la base de datos para el motor ASÍNCRONO.
        Utiliza el driver 'asyncpg', que es el principal para la aplicación.
        """
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @property
    def sync_database_url(self) -> str:
        """
        Genera la URL de conexión a la base de datos para operaciones SÍNCRONAS.
        Utiliza el driver 'psycopg2'. Su uso principal es para componentes que no
        son compatibles con asyncio, como el `SQLAlchemyJobStore` de APScheduler.
        """
        return (
            f"postgresql+psycopg2://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        """
        Configuración interna de Pydantic para indicarle cómo cargar las variables.
        """
        # Nombre del archivo del que se leerán las variables de entorno.
        env_file = '.env'
        # Codificación del archivo .env.
        env_file_encoding = 'utf-8'

# Creamos una instancia única de la configuración que será importada
# por el resto de la aplicación.
settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
"""
Módulo de Configuración de la Base de Datos.

Este archivo es el responsable de crear y configurar la conexión a la base de
datos para toda la aplicación utilizando SQLAlchemy en modo asíncrono.

Componentes Clave:
1. `async_engine`: Una instancia única del motor de base de datos que gestiona
   las conexiones a bajo nivel. Se crea una sola vez cuando se inicia la app.
2. `async_session_factory`: Una "fábrica" que produce objetos de sesión de
   SQLAlchemy (`AsyncSession`). Cada vez que se necesita interactuar con la
   base de datos (ej: dentro de un manejador de comandos), se solicita una nueva
   sesión a esta fábrica.
"""

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Se crea una única instancia del motor asíncrono para toda la aplicación.
# Este objeto gestiona un pool de conexiones a la base de datos.
async_engine = create_async_engine(
    settings.database_url,

    # `echo=True` mostraría todas las sentencias SQL que se ejecutan en la consola.
    # Es muy útil para depurar, pero debe estar en `False` en producción.
    echo=False,
)

# Se crea una fábrica de sesiones. Esta fábrica se usará en toda la aplicación
# para obtener una nueva sesión de corta duración cada vez que se necesite
# realizar una operación en la base de datos.
async_session_factory = async_sessionmaker(
    bind=async_engine,

    # `expire_on_commit=False` es crucial en aplicaciones asíncronas.
    # Evita que SQLAlchemy invalide los objetos (ej: un 'Character') después de un
    # `session.commit()`. Sin esto, acceder a un atributo de un objeto después
    # de un commit podría lanzar un error al intentar recargarlo desde una
    # sesión ya cerrada.
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===
# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
# src/bot/bot.py
"""
Módulo para la Instanciación del Objeto Bot de Aiogram.

Este archivo tiene una única y simple responsabilidad: crear una instancia
global del objeto `Bot` de Aiogram.

Centralizar la creación de esta instancia aquí permite que cualquier otro
módulo en la aplicación (como los servicios) pueda importarla para interactuar
directamente con la API de Telegram (por ejemplo, para enviar mensajes
proactivos fuera del flujo normal de un comando).
"""

from aiogram import Bot

from src.config import settings

# Se crea una instancia única del Bot para toda la aplicación.
# El token se lee de forma segura desde el objeto de configuración `settings`,
# que a su vez lo carga desde las variables de entorno.
# `settings.bot_token.get_secret_value()` es la forma correcta de acceder
# al valor de un `SecretStr` de Pydantic.
bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py
"""
Módulo para la Instanciación del Dispatcher de Aiogram.

Este archivo crea y configura la instancia global del `Dispatcher`, que es el
componente central de Aiogram para el procesamiento de actualizaciones (mensajes,
callbacks, etc.).

Responsabilidades:
1.  **Enrutamiento:** El `Dispatcher` (`dp`) es el objeto al que se registran
    todos los manejadores de mensajes (handlers). Se encarga de decidir qué
    función debe procesar cada mensaje entrante.
2.  **Gestión de Estados (FSM):** Configura el almacenamiento de estados finitos
    (Finite State Machine), que permite crear conversaciones de varios pasos
    (ej: creación de personaje, menús interactivos).
"""

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# 1. Configuración del Almacenamiento de Estados (FSM - Finite State Machine)
# Se utiliza Redis (`RedisStorage2`) como backend para almacenar el estado de
# la conversación de cada usuario. Esto es esencial para funcionalidades
# de varios pasos, como la creación de personajes.
#
# `pool_size` se establece explícitamente para evitar el error 'Too many connections'
# que puede ocurrir si muchos usuarios interactúan con el bot simultáneamente.
storage = RedisStorage2(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    pool_size=20,
)

# 2. Creación de la Instancia del Dispatcher
# Se crea una instancia única del `Dispatcher` para toda la aplicación,
# vinculándola con la instancia del `bot` y el `storage` configurado.
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
"""
Módulo del Dispatcher Principal de Comandos.

Este archivo contiene el manejador (`handler`) más importante de la aplicación.
La función `main_command_dispatcher` está registrada para interceptar **todos**
los mensajes de texto enviados por los jugadores.

Actúa como el "cerebro" del juego, orquestando el siguiente flujo para cada mensaje:
1. Obtiene el contexto del jugador (Cuenta, Personaje) desde la base de datos.
2. Actualiza el estado de actividad del jugador (online/AFK).
3. Maneja casos especiales como el comando `/start`.
4. Utiliza el `command_service` para determinar dinámicamente qué `CommandSets`
   están activos para el jugador en ese preciso momento.
5. Busca el comando invocado dentro de los sets activos.
6. Verifica los permisos (`permission_service`).
7. Ejecuta el método `.execute()` del comando encontrado.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service, online_service, command_service
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.player.movement import MOVEMENT_COMMANDS
from commands.player.channels import CHANNEL_COMMANDS
from commands.admin.building import SPAWN_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from commands.admin.info import INFO_COMMANDS
from src.utils.presenters import show_current_room

# El diccionario `COMMAND_SETS` es el catálogo maestro que contiene una instancia
# de cada comando disponible en el juego, agrupados por funcionalidad.
COMMAND_SETS = {
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "movement": MOVEMENT_COMMANDS,
    "channels": CHANNEL_COMMANDS,
    "spawning": SPAWN_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
    "admin_info": INFO_COMMANDS,
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Manejador principal que intercepta todos los mensajes de texto y los
    enruta al comando correspondiente.
    """
    async with async_session_factory() as session:
        try:
            # 1. Obtener el contexto del jugador.
            account = await player_service.get_or_create_account(session, message.from_user.id)
            if not account:
                # Si no se puede obtener la cuenta, es un error grave.
                await message.answer("Error crítico al acceder a tu cuenta.")
                return
            character = account.character
            input_text = message.text.strip()

            # 2. Actualizar estado de actividad (online/AFK).
            if character:
                await online_service.update_last_seen(session, character)

            # 3. Manejo especial para el comando /start.
            if input_text.lower().startswith('/start'):
                if character is None:
                    await message.answer(
                        "¡Bienvenido a Runegram! Veo que eres nuevo por aquí.\n"
                        "Para empezar, necesitas crear tu personaje. Usa el comando:\n"
                        "/crearpersonaje [nombre]"
                    )
                else:
                    await command_service.update_telegram_commands(character)
                    await show_current_room(message)
                return

            # 4. Validar que el jugador tenga un personaje para comandos que no sean de creación.
            if not character:
                if not input_text.lower().startswith('/crearpersonaje'):
                    await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                # Permitimos que solo /crearpersonaje continúe si no hay personaje.

            # 5. Parsear el comando y sus argumentos.
            if not input_text.startswith('/'):
                await message.answer("Comando desconocido. Los comandos deben empezar con / (ej: /mirar, /norte).")
                return

            cmd_name = message.get_command(pure=True).lower()
            args = message.get_args().split() if message.get_args() else []

            # 6. Obtener la lista dinámica de CommandSets activos.
            active_sets_names = await command_service.get_active_command_sets_for_character(character)

            # 7. Buscar y ejecutar el comando.
            found_cmd = None
            for set_name in active_sets_names:
                for cmd_instance in COMMAND_SETS.get(set_name, []):
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
                if found_cmd:
                    break

            if not found_cmd:
                await message.answer("No conozco ese comando.")
                return

            # Si el jugador no tiene personaje, solo puede ejecutar comandos sin lock.
            if not character and found_cmd.lock:
                await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                return

            can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
            if not can_run:
                await message.answer(error_message or "No puedes hacer eso.")
                return

            await found_cmd.execute(character, session, message, args)

        except Exception:
            # Captura final para cualquier error no manejado en las capas inferiores.
            # Esto evita que el bot se caiga y registra el problema para depuración.
            await message.answer("Ocurrió un error inesperado al procesar tu comando.")
            logging.exception(f"Error crítico no manejado en el dispatcher principal para el usuario {message.from_user.id}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
from .character_setting import CharacterSetting
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
"""
Módulo que define el Modelo de Datos para una Cuenta de Usuario.

Este archivo contiene la clase `Account`, que se mapea a la tabla `accounts`
en la base de datos. Una cuenta representa a un usuario real a nivel de aplicación,
identificado de forma única por su `telegram_id`.

La cuenta es la entidad "propietaria" de un personaje (`Character`) y almacena
metadatos sobre el usuario, como su rol (JUGADOR, ADMINISTRADOR) y su estado
(ACTIVO, BLOQUEADO).
"""

from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    """

    Representa una cuenta de usuario en la base de datos.
    """
    __tablename__ = 'accounts'

    # Identificador único de la cuenta en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El ID de usuario único proporcionado por Telegram.
    # Es crucial para vincular nuestra cuenta interna con el usuario de Telegram.
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)

    # El rol del usuario en el juego (ej: 'JUGADOR', 'ADMINISTRADOR').
    # Determina el acceso a comandos y funcionalidades especiales.
    role = Column(String, default='JUGADOR', nullable=False)

    # El estado de la cuenta (ej: 'ACTIVE', 'BLOCKED').
    # Permite gestionar el acceso de los usuarios a nivel de cuenta.
    status = Column(String(20), default='ACTIVE', nullable=False, server_default='ACTIVE')

    # --- Relaciones de SQLAlchemy ---

    # Relación uno-a-uno con el personaje del juego.
    # `uselist=False` indica que una cuenta solo puede tener un personaje.
    # `back_populates` asegura que la relación sea bidireccional, permitiendo
    # acceder a `character.account`.
    # SQLAlchemy es lo suficientemente inteligente como para encontrar la clase "Character"
    # entre los modelos que heredan de la misma Base.
    character = relationship("Character", back_populates="account", uselist=False)

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Account(id={self.id}, telegram_id={self.telegram_id}, role='{self.role}')>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
"""
Módulo que define la Base Declarativa para todos los Modelos de SQLAlchemy.

Este archivo contiene un único pero crucial objeto: `Base`.

SQLAlchemy utiliza un sistema "declarativo" donde las clases de Python se mapean
directamente a tablas de la base de datos. Para que esto funcione, todas las
clases de modelo (como `Account`, `Character`, `Room`, etc.) deben heredar de
una clase base común.

Esta clase `Base` actúa como un registro central que recopila metadatos sobre
todas las clases de modelo que heredan de ella. Herramientas como Alembic
utilizan estos metadatos para comparar los modelos con el estado de la base
de datos y generar así las migraciones automáticamente.
"""

from sqlalchemy.orm import declarative_base

# `declarative_base()` es una función de fábrica que construye la clase base.
# Todos nuestros modelos de datos en el proyecto heredarán de este objeto `Base`.
Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
"""
Módulo que define el Modelo de Datos para un Personaje del Juego.

Este archivo contiene la clase `Character`, que se mapea a la tabla `characters`
en la base de datos. Un personaje es el "avatar" o la entidad con la que un
jugador interactúa dentro del mundo de Runegram.

El personaje está vinculado a una `Account` (el usuario real) y actúa como el
punto central para las relaciones de juego, como su ubicación (`Room`), su
inventario (`Item`), y sus configuraciones (`CharacterSetting`).
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class Character(Base):
    """
    Representa un personaje jugable en la base de datos.
    """
    __tablename__ = 'characters'

    # --- Atributos Principales ---

    # Identificador único del personaje en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El nombre del personaje, que debe ser único en todo el juego.
    name = Column(String(50), unique=True, nullable=False)

    # --- Claves Foráneas ---

    # Vínculo a la cuenta propietaria de este personaje.
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)

    # Vínculo a la sala donde se encuentra actualmente el personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Atributos de Juego (Datos Estructurados) ---

    # Almacena la lista de CommandSets base que el personaje conoce.
    # Por ejemplo: ["general", "interaction", "movement", "channels"].
    # Este campo es la base para el sistema de comandos dinámicos.
    command_sets = Column(
        JSONB,
        nullable=False,
        server_default='["general", "interaction", "movement", "channels"]',
        default=["general", "interaction", "movement", "channels"]
    )

    # --- Relaciones de SQLAlchemy ---

    # Relación uno-a-uno con la cuenta.
    # Permite acceder al objeto `Account` desde el personaje vía `character.account`.
    account = relationship("Account", back_populates="character")

    # Relación muchos-a-uno con la sala.
    # Permite acceder al objeto `Room` desde el personaje vía `character.room`.
    room = relationship("Room")

    # Relación uno-a-muchos con los objetos del inventario.
    # Permite acceder a una lista de objetos `Item` vía `character.items`.
    items = relationship("Item", back_populates="character")

    # Relación uno-a-uno con las configuraciones del personaje.
    # Permite acceder al objeto `CharacterSetting` vía `character.settings`.
    # `cascade="all, delete-orphan"` asegura que si se borra un personaje,
    # su fila de configuraciones asociada también se borre automáticamente.
    settings = relationship(
        "CharacterSetting",
        back_populates="character",
        uselist=False,
        cascade="all, delete-orphan"
    )

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Character(id={self.id}, name='{self.name}')>"
# === FIN: src/models/character.py ===


# === INICIO: src/models/character_setting.py ===
# src/models/character_setting.py
"""
Módulo que define el Modelo de Datos para las Configuraciones de un Personaje.

Este archivo contiene la clase `CharacterSetting`, que se mapea a la tabla
`character_settings`. Esta tabla almacena configuraciones personalizables
para cada personaje, manteniendo el modelo `Character` principal más limpio.

El uso de una columna `JSONB` (`active_channels`) permite añadir futuras
configuraciones (ej: colores, flags de tutorial) sin necesidad de modificar
el esquema de la base de datos, lo que hace que el sistema sea muy flexible
y extensible.
"""

from sqlalchemy import BigInteger, Column, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class CharacterSetting(Base):
    """
    Representa una fila de configuraciones para un personaje específico.
    """
    __tablename__ = 'character_settings'

    # --- Clave Primaria y Foránea ---

    # Usamos el ID del personaje como clave primaria (`primary_key=True`).
    # Esto impone una relación estricta de uno-a-uno a nivel de base de datos:
    # no puede haber más de una fila de configuraciones por personaje.
    character_id = Column(BigInteger, ForeignKey('characters.id'), primary_key=True)

    # --- Atributos de Configuración ---

    # Columna JSONB para guardar una lista de los canales a los que el personaje
    # está suscrito. Usar JSONB es muy flexible.
    # Ejemplo de contenido: `{"active_channels": ["novato", "comercio"]}`
    active_channels = Column(JSONB, nullable=False, server_default='{}')

    # --- Relaciones de SQLAlchemy ---

    # Relación inversa uno-a-uno con el personaje.
    # Permite acceder al objeto `Character` desde la configuración vía `settings.character`.
    character = relationship("Character", back_populates="settings")

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<CharacterSetting(character_id={self.character_id})>"
# === FIN: src/models/character_setting.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py
"""
Módulo que define el Modelo de Datos para una Salida entre Salas.

Este archivo contiene la clase `Exit`, que se mapea a la tabla `exits`.
Cada fila en esta tabla representa una conexión UNIDIRECCIONAL desde una sala
de origen (`from_room_id`) hacia una sala de destino (`to_room_id`).

Una conexión bidireccional (ej: una puerta entre la sala A y la sala B) se
representa como dos filas separadas en esta tabla:
1. Una salida desde A hacia B (ej: "norte").
2. Una salida desde B hacia A (ej: "sur").
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    # --- Atributos Principales ---

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta").
    name = Column(String(50), nullable=False, index=True)

    # El string de permisos para esta salida específica.
    locks = Column(String, nullable=False, default="")

    # --- Claves Foráneas ---

    # El ID de la sala desde la que parte esta salida.
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El ID de la sala a la que lleva esta salida.
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Relaciones de SQLAlchemy ---

    # Relación para poder acceder al objeto `Room` de origen.
    # `foreign_keys=[from_room_id]` es necesario para que SQLAlchemy sepa cuál de
    # las dos claves foráneas a 'rooms.id' debe usar para esta relación.
    # `back_populates="exits_from"` la conecta con la lista de salidas en el modelo Room.
    from_room = relationship("Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relación para poder acceder al objeto `Room` de destino.
    # `back_populates="exits_to"` la conecta con la lista de "llegadas" en el modelo Room.
    to_room = relationship("Room", foreign_keys=[to_room_id], back_populates="exits_to")

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Exit(id={self.id}, name='{self.name}', from={self.from_room_id}, to={self.to_room_id})>"
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py
"""
Módulo que define el Modelo de Datos para una Instancia de Objeto (Item).

Este archivo contiene la clase `Item`, que se mapea a la tabla `items`.
Es fundamental entender que este modelo NO representa un tipo de objeto, sino
una INSTANCIA única de un objeto en el mundo.

Este modelo es deliberadamente "ligero". La mayoría de sus propiedades (nombre,
descripción, scripts, etc.) no se almacenan en la base de datos, sino que se
obtienen en tiempo de ejecución a través de la columna `key`, que lo vincula
a su prototipo correspondiente en `game_data/item_prototypes.py`.
"""

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship

from game_data.item_prototypes import ITEM_PROTOTYPES
from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo del juego.
    """
    __tablename__ = 'items'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ITEM_PROTOTYPES.
    # Por ejemplo: "espada_viviente".
    key = Column(String(50), nullable=False, index=True)

    # Atributos `_override`: Permiten que una instancia específica tenga
    # un nombre o descripción diferente a la de su prototipo, creando objetos únicos.
    # Si son `NULL`, se usarán los valores del prototipo.
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)

    # --- Ubicación del Objeto ---

    # El ID de la sala donde se encuentra el objeto.
    # Es `NULL` si el objeto está en el inventario de un personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)

    # El ID del personaje que lleva el objeto.
    # Es `NULL` si el objeto está en el suelo de una sala.
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    # --- Relaciones de SQLAlchemy ---

    # Relación muchos-a-uno con la sala. Permite acceder a `item.room`.
    room = relationship("Room", back_populates="items")

    # Relación muchos-a-uno con el personaje. Permite acceder a `item.character`.
    character = relationship("Character", back_populates="items")

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para este objeto desde `game_data`. Es el puente entre la instancia
        de la base de datos y su definición de contenido.
        """
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """
        Obtiene el nombre del item.
        Prioriza el `name_override` si existe; de lo contrario,
        recurre al nombre definido en el prototipo.
        """
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """
        Obtiene la descripción del item.
        Prioriza el `description_override` si existe; de lo contrario,
        recurre a la descripción definida en el prototipo.
        """
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """
        Obtiene las palabras clave del item, que siempre provienen del prototipo.
        """
        return self.prototype.get("keywords", [])

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Item(id={self.id}, key='{self.key}')>"
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py
"""
Módulo que define el Modelo de Datos para una Sala del Mundo.

Este archivo contiene la clase `Room`, que se mapea a la tabla `rooms`.
Cada fila en esta tabla representa una ubicación única en el juego.

Siguiendo la filosofía de diseño del motor, una `Room` en la base de datos
es principalmente una instancia que se corresponde con un prototipo definido en
`game_data/room_prototypes.py`, vinculado a través de la columna `key`.
"""

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base
from game_data.room_prototypes import ROOM_PROTOTYPES

class Room(Base):
    """
    Representa una sala o ubicación en el mundo del juego.
    """
    __tablename__ = 'rooms'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ROOM_PROTOTYPES.
    # Por ejemplo: "plaza_central". Es único y no debería cambiar.
    key = Column(String(50), unique=True, nullable=True, index=True)

    # El nombre y la descripción pueden ser actualizados desde los prototipos
    # por el `world_loader_service`.
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")

    # String de permisos para la sala en sí (ej: para impedir la entrada).
    locks = Column(String, nullable=False, default="")

    # --- Relaciones de SQLAlchemy ---

    # Relación uno-a-muchos con los objetos que se encuentran en esta sala.
    # Permite acceder a una lista de `Item` vía `room.items`.
    items = relationship("Item", back_populates="room")

    # Relación uno-a-muchos con las salidas QUE PARTEN DESDE ESTA SALA.
    # Permite acceder a una lista de `Exit` vía `room.exits_from`.
    # `cascade="all, delete-orphan"` asegura que si se borra una sala,
    # todas sus salidas asociadas también se eliminen.
    exits_from = relationship(
        "Exit",
        foreign_keys="[Exit.from_room_id]",
        back_populates="from_room",
        cascade="all, delete-orphan"
    )

    # Relación uno-a-muchos con las salidas QUE LLEGAN A ESTA SALA.
    # Es útil para comprobaciones inversas (ej: "¿qué salas conectan aquí?").
    exits_to = relationship(
        "Exit",
        foreign_keys="[Exit.to_room_id]",
        back_populates="to_room",
        cascade="all, delete-orphan"
    )

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para esta sala desde `game_data`.
        """
        if not self.key:
            return {}
        return ROOM_PROTOTYPES.get(self.key, {})

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Room(id={self.id}, key='{self.key}', name='{self.name}')>"
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===
# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster_service.py ===
# src/services/broadcaster_service.py
"""
Módulo de Servicio de Transmisión (Broadcasting).

Este archivo centraliza toda la lógica para enviar mensajes a los jugadores
a través del bot de Telegram. Actúa como una capa de abstracción sobre la API
directa del bot.

Centralizar la comunicación aquí ofrece varias ventajas:
1.  **Consistencia:** Todos los mensajes enviados por el juego pueden tener un
    formato y comportamiento consistentes.
2.  **Manejo de Errores Unificado:** La lógica para manejar errores de la API de
    Telegram (ej: un usuario bloquea el bot) se encuentra en un solo lugar.
3.  **Desacoplamiento:** El resto de los servicios (scripts, canales, etc.) no
    necesitan saber los detalles de cómo se envía un mensaje; simplemente
    llaman a una función en este servicio.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.bot.bot import bot
from src.models import Character


async def send_message_to_character(
    character: Character,
    message_text: str,
    parse_mode: str = "HTML"
):
    """
    Envía un mensaje formateado a un personaje específico.

    Args:
        character (Character): La instancia del modelo Character a la que se enviará el mensaje.
                               Es crucial que este objeto tenga su relación `.account` precargada.
        message_text (str): El contenido del mensaje a enviar.
        parse_mode (str): El modo de parseo de Telegram (por defecto 'HTML').
    """
    if not character:
        logging.warning("BROADCASTER: Se intentó enviar un mensaje a un personaje nulo.")
        return

    # Salvaguarda para asegurar que la relación con la cuenta está cargada.
    if not character.account:
        logging.error(f"BROADCASTER: El personaje {character.name} (ID: {character.id}) no tiene su cuenta cargada. No se puede enviar mensaje.")
        return

    try:
        logging.info(f"[BROADCASTER DEBUG] Intentando enviar mensaje a {character.name} (Chat ID: {character.account.telegram_id})")
        await bot.send_message(
            chat_id=character.account.telegram_id,
            text=message_text,
            parse_mode=parse_mode
        )
        logging.info(f"[BROADCASTER DEBUG] Mensaje enviado con éxito a {character.name}")
    except Exception:
        # Usamos logging.exception para obtener un traceback completo si el envío falla.
        # Esto es común si un usuario ha bloqueado el bot. No debe detener el juego.
        logging.exception(f"BROADCASTER: No se pudo enviar mensaje a {character.name} (ID: {character.id})")


async def send_message_to_room(
    session: AsyncSession,
    room_id: int,
    message_text: str,
    exclude_character_id: int | None = None,
    parse_mode: str = "HTML"
):
    """
    Envía un mensaje a todos los personajes presentes en una sala específica.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        room_id (int): El ID de la sala a la que se enviará el mensaje.
        message_text (str): El contenido del mensaje a enviar.
        exclude_character_id (int, optional): El ID de un personaje a excluir de la transmisión.
        parse_mode (str): El modo de parseo de Telegram.
    """
    if not room_id:
        logging.warning("BROADCASTER: Se intentó enviar un mensaje a un room_id nulo.")
        return

    # 1. Obtenemos todos los personajes en la sala.
    #    Usamos `selectinload(Character.account)` para cargar eficientemente la
    #    información de la cuenta de todos los personajes en una sola consulta.
    query = (
        select(Character)
        .where(Character.room_id == room_id)
        .options(selectinload(Character.account))
    )
    result = await session.execute(query)
    characters_in_room = result.scalars().all()

    # 2. Iteramos y enviamos el mensaje a cada personaje.
    for char in characters_in_room:
        if char.id == exclude_character_id:
            continue

        # Reutilizamos nuestra propia función para mantener la lógica de envío en un solo lugar.
        await send_message_to_character(
            character=char,
            message_text=message_text,
            parse_mode=parse_mode
        )
# === FIN: src/services/broadcaster_service.py ===


# === INICIO: src/services/channel_service.py ===
# src/services/channel_service.py
"""
Módulo de Servicio para la Gestión de Canales de Chat.

Este servicio encapsula toda la lógica de negocio relacionada con los canales
de comunicación globales. Sus responsabilidades incluyen:
- Gestionar la configuración de canales por personaje (suscripciones).
- Formatear y transmitir mensajes a todos los jugadores suscritos a un canal.
- Proveer funciones de ayuda para comprobar el estado de los canales.

Depende de `broadcaster_service` para el envío final de mensajes y de
`game_data/channel_prototypes.py` como fuente de la verdad sobre los
canales disponibles.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Character, CharacterSetting
from src.services import broadcaster_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

async def get_or_create_settings(session: AsyncSession, character: Character) -> CharacterSetting:
    """
    Obtiene las configuraciones para un personaje. Si no existen, las crea con
    los valores por defecto definidos en los prototipos de canal.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        character (Character): El personaje para el que se obtienen las configuraciones.

    Returns:
        CharacterSetting: El objeto de configuración del personaje.
    """
    # Si las settings ya están cargadas en el objeto character, las devolvemos directamente.
    if character.settings:
        return character.settings

    # Si no, las creamos.
    logging.info(f"Creando configuraciones por defecto para el personaje {character.name}")

    # Leemos los prototipos para ver qué canales deben estar activados por defecto.
    default_channels = [
        key for key, data in CHANNEL_PROTOTYPES.items() if data.get("default_on", False)
    ]

    new_settings = CharacterSetting(
        character_id=character.id,
        active_channels={"active_channels": default_channels}
    )
    session.add(new_settings)
    await session.commit()

    # Refrescamos el objeto 'character' para que la relación 'settings' se cargue.
    await session.refresh(character, attribute_names=["settings"])

    return character.settings

async def is_channel_active(settings: CharacterSetting, channel_key: str) -> bool:
    """Comprueba si un canal está en la lista de canales activos de un jugador."""
    if not settings:
        return False
    return channel_key in settings.active_channels.get("active_channels", [])

async def broadcast_to_channel(session: AsyncSession, channel_key: str, message: str, exclude_character_id: int | None = None):
    """
    Envía un mensaje a todos los jugadores que estén suscritos a un canal.
    """
    try:
        if channel_key not in CHANNEL_PROTOTYPES:
            logging.warning(f"Intento de transmitir a un canal desconocido: {channel_key}")
            return

        # 1. Formatear el mensaje con el ícono y nombre del canal.
        proto = CHANNEL_PROTOTYPES[channel_key]
        formatted_message = f"{proto['icon']} <b>{proto['name']}:</b> {message}"

        # 2. Obtener todos los personajes del juego.
        #    Precargamos sus settings y cuentas para evitar consultas adicionales en el bucle.
        query = select(Character).options(selectinload(Character.settings), selectinload(Character.account))
        result = await session.execute(query)
        all_characters = result.scalars().all()

        # 3. Iterar y enviar el mensaje a los que estén suscritos.
        for char in all_characters:
            if char.id == exclude_character_id:
                continue

            settings = await get_or_create_settings(session, char)
            if await is_channel_active(settings, channel_key):
                await broadcaster_service.send_message_to_character(char, formatted_message)
    except Exception:
        logging.exception(f"Error al transmitir al canal '{channel_key}'")

async def set_channel_status(session: AsyncSession, character: Character, channel_key: str, activate: bool):
    """Activa o desactiva un canal para un personaje."""
    if channel_key not in CHANNEL_PROTOTYPES:
        raise ValueError("El canal especificado no existe.")

    settings = await get_or_create_settings(session, character)

    # SQLAlchemy es capaz de detectar cambios en listas dentro de un JSONB "mutable".
    # Obtenemos la lista actual de canales activos.
    active_channels_list = settings.active_channels.get("active_channels", [])

    if activate:
        # Añadir el canal si no está ya en la lista.
        if channel_key not in active_channels_list:
            active_channels_list.append(channel_key)
    else: # Desactivar
        # Quitar el canal si está en la lista.
        if channel_key in active_channels_list:
            active_channels_list.remove(channel_key)

    # Reasignamos la lista modificada al campo JSONB.
    settings.active_channels["active_channels"] = active_channels_list

    # Marcamos el objeto como "modificado" para que SQLAlchemy sepa que debe guardarlo.
    from sqlalchemy.orm.attributes import flag_modified
    flag_modified(settings, "active_channels")

    await session.commit()
# === FIN: src/services/channel_service.py ===


# === INICIO: src/services/command_service.py ===
# src/services/command_service.py
"""
Módulo de Servicio para la Gestión de Comandos.

Este servicio es el cerebro detrás del sistema de comandos dinámicos.
No define los comandos en sí, sino que orquesta cuáles están disponibles
para un jugador en un momento dado y cómo se presentan en la interfaz.

Responsabilidades Clave:
1. Calcular la lista de `CommandSets` activos para un personaje basándose
   en su estado, equipo y ubicación (contexto).
2. Sincronizar la lista de comandos disponibles con la interfaz del cliente
   de Telegram, proporcionando una experiencia de usuario (UX) reactiva.
"""

import logging
from aiogram.types import BotCommand, BotCommandScopeChat
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.bot import bot
from src.models import Character

def get_command_sets() -> dict:
    """
    Obtiene el diccionario `COMMAND_SETS` del dispatcher de forma segura.

    Este es un patrón para evitar una "importación circular", ya que el dispatcher
    importa este servicio, y este servicio necesita acceso al diccionario que
    el dispatcher define. La importación se realiza dentro de la función para
    retrasar su ejecución hasta que todos los módulos estén cargados.
    """
    from src.handlers.player.dispatcher import COMMAND_SETS
    return COMMAND_SETS

async def get_active_command_sets_for_character(character: Character) -> list[str]:
    """
    Construye la lista de nombres de CommandSets activos para un personaje
    basándose en su contexto actual (base, equipo, sala, rol).
    """
    # Si no hay personaje (durante la creación), solo están disponibles los
    # comandos de creación de personaje.
    if not character:
        return ["character_creation"]

    # 1. Empezamos con los sets base del personaje desde la BD (ej: "general", "movement").
    active_sets = set(character.command_sets)

    # 2. Añadimos sets otorgados por los objetos en el inventario.
    for item in character.items:
        granted_sets = item.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 3. Añadimos sets otorgados por la sala actual.
    if character.room and character.room.prototype:
        granted_sets = character.room.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 4. Añadimos sets de administrador si el rol de la cuenta es el adecuado.
    if character.account and character.account.role == "ADMINISTRADOR":
        active_sets.update(["spawning", "admin_movement", "admin_info"])

    return sorted(list(active_sets))


async def update_telegram_commands(character: Character):
    """
    Actualiza la lista de comandos visibles en el menú '/' del cliente de Telegram
    para un personaje específico.
    """
    if not character or not character.account:
        return

    try:
        COMMAND_SETS = get_command_sets()
        active_set_names = await get_active_command_sets_for_character(character)

        telegram_commands = []
        seen_commands = set() # Para evitar duplicados si un comando está en varios sets.

        # Construimos la lista de objetos BotCommand que la API de Telegram espera.
        for set_name in active_set_names:
            for command_instance in COMMAND_SETS.get(set_name, []):
                # Usamos el primer alias como el comando principal (ej: "norte" de ["norte", "n"]).
                main_name = command_instance.names[0]
                if main_name not in seen_commands:
                    telegram_commands.append(
                        BotCommand(command=main_name, description=command_instance.description)
                    )
                    seen_commands.add(main_name)

        # Usamos un `BotCommandScopeChat` para aplicar estos comandos únicamente
        # al chat con este jugador específico, y no globalmente.
        scope = BotCommandScopeChat(chat_id=character.account.telegram_id)
        await bot.set_my_commands(commands=telegram_commands, scope=scope)

        logging.info(f"Actualizados {len(telegram_commands)} comandos de Telegram para {character.name}.")

    except Exception as e:
        # Los errores al actualizar comandos no son críticos y no deben detener el juego.
        # Por ejemplo, si el usuario ha bloqueado al bot.
        logging.warning(f"No se pudieron actualizar los comandos de Telegram para {character.name}: {e}")
# === FIN: src/services/command_service.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py
"""
Módulo de Servicio para la Gestión de Objetos (Items).

Este servicio encapsula la lógica de negocio para crear y manipular instancias
de objetos en el mundo del juego. Se encarga de la interacción directa con el
modelo `Item`.

Responsabilidades:
- Crear nuevas instancias de objetos a partir de prototipos (`spawn`).
- Mover objetos entre salas y los inventarios de los personajes.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
from game_data.item_prototypes import ITEM_PROTOTYPES
from src.services import ticker_service


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto, la coloca en una sala
    y registra sus tickers.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        room_id (int): El ID de la sala donde se creará el objeto.
        item_key (str): La clave del prototipo del objeto a crear.

    Returns:
        Item: La nueva instancia del objeto `Item` creada.

    Raises:
        ValueError: Si la `item_key` no corresponde a ningún prototipo definido.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    try:
        # 1. Crear la instancia del modelo Item, vinculándola a la sala.
        new_item = Item(room_id=room_id, key=item_key)
        session.add(new_item)
        await session.commit()
        await session.refresh(new_item)

        # 2. Notificar al ticker_service para que programe los tickers de este nuevo objeto.
        await ticker_service.schedule_tickers_for_entity(new_item)

        return new_item
    except Exception:
        logging.exception(f"Error inesperado al intentar generar el objeto con clave '{item_key}' en la sala {room_id}")
        # Relanzamos la excepción para que la capa superior (el comando) la maneje.
        raise


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """
    Mueve un objeto desde una sala (o de ningún sitio) al inventario de un personaje.
    Actualiza el `room_id` a NULL y establece el `character_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=None, character_id=character_id)
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """
    Mueve un objeto desde el inventario de un personaje al suelo de una sala.
    Actualiza el `character_id` a NULL y establece el `room_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=room_id, character_id=None)
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/online_service.py ===
# src/services/online_service.py
"""
Módulo de Servicio para el Seguimiento de Actividad (Presencia).

Este servicio gestiona el estado de "online" o "AFK" (Away From Keyboard) de los
personajes. Utiliza Redis para un almacenamiento y recuperación de datos de alta
velocidad, lo cual es ideal para datos volátiles como el timestamp de la última
actividad.

Responsabilidades:
- Registrar la última vez que un jugador envía un comando.
- Determinar si un jugador está "online" basándose en un umbral de inactividad.
- Gestionar las notificaciones cuando un jugador pasa a estado AFK o vuelve.
- Proveer una tarea global (`check_for_newly_afk_players`) para ser ejecutada
  periódicamente por el `ticker_service`.
"""

import time
import logging
import redis.asyncio as redis
from datetime import timedelta

from src.config import settings
from src.models import Character
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from src.db import async_session_factory


# --- Configuración del Servicio ---
ONLINE_THRESHOLD = timedelta(minutes=5)

redis_client = redis.Redis(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    decode_responses=True
)

# Variable global en memoria para rastrear quién estaba online en el último chequeo.
PREVIOUSLY_ONLINE_IDS = set()


# --- Funciones de Ayuda (Internas) ---

def _get_last_seen_key(character_id: int) -> str:
    """Genera la clave de Redis estandarizada para el timestamp de un personaje."""
    return f"last_seen:{character_id}"

def _get_afk_notified_key(character_id: int) -> str:
    """Genera la clave de Redis para el flag que indica si ya se notificó el estado AFK."""
    return f"afk_notified:{character_id}"


# --- Funciones Principales del Servicio ---

async def update_last_seen(session: AsyncSession, character: Character):
    """
    Actualiza la última actividad de un personaje y notifica si vuelve de estar AFK.
    Esta función es llamada por el dispatcher en cada mensaje.
    """
    from src.services import channel_service

    char_id = character.id

    # 1. Actualizar el timestamp de "última vez visto" en Redis.
    key = _get_last_seen_key(char_id)
    await redis_client.set(key, time.time())
    await redis_client.expire(key, timedelta(days=7))

    # 2. Comprobar si el personaje estaba marcado como AFK.
    afk_notified_key = _get_afk_notified_key(char_id)
    # Usamos `getdel` para obtener y borrar la clave atómicamente si existe.
    was_afk = await redis_client.getdel(afk_notified_key)

    if was_afk:
        # El personaje estaba AFK y acaba de volver. Notificamos.
        logging.info(f"Personaje {character.name} ha vuelto de su inactividad (AFK).")
        await channel_service.broadcast_to_channel(
            session,
            "sistema",
            f"<i>{character.name} ha vuelto de su inactividad.</i>"
        )


async def is_character_online(character_id: int) -> bool:
    """
    Verifica si un personaje se considera "online" (activo recientemente).
    """
    key = _get_last_seen_key(character_id)
    last_seen_timestamp_str = await redis_client.get(key)
    if not last_seen_timestamp_str:
        return False

    try:
        elapsed_time = time.time() - float(last_seen_timestamp_str)
        return elapsed_time < ONLINE_THRESHOLD.total_seconds()
    except (ValueError, TypeError):
        return False

async def get_online_characters(session: AsyncSession) -> list[Character]:
    """
    Devuelve una lista de todos los objetos Character que se consideran "online".
    """
    result = await session.execute(select(Character))
    all_characters = result.scalars().all()

    online_characters = []
    for char in all_characters:
        if await is_character_online(char.id):
            online_characters.append(char)

    return online_characters

async def check_for_newly_afk_players():
    """
    Tarea global periódica para detectar y notificar sobre personajes que se
    han vuelto inactivos (AFK).
    """
    from src.services import channel_service, player_service
    global PREVIOUSLY_ONLINE_IDS
    logging.info("[AFK CHECK] Ejecutando chequeo de jugadores inactivos...")

    async with async_session_factory() as session:
        try:
            result = await session.execute(select(Character.id))
            all_char_ids = set(result.scalars().all())

            currently_online_ids = set()
            for char_id in all_char_ids:
                if await is_character_online(char_id):
                    currently_online_ids.add(char_id)

            newly_afk_ids = PREVIOUSLY_ONLINE_IDS - currently_online_ids

            for char_id in newly_afk_ids:
                afk_notified_key = _get_afk_notified_key(char_id)
                # Solo notificamos si no lo hemos hecho ya.
                if not await redis_client.exists(afk_notified_key):
                    character = await player_service.get_character_with_relations_by_id(session, char_id)
                    if character:
                        logging.info(f"Personaje {character.name} ha entrado en inactividad (AFK).")
                        await channel_service.broadcast_to_channel(
                            session,
                            "sistema",
                            f"<i>{character.name} ha entrado en inactividad.</i>"
                        )
                        # Marcamos que ya fue notificado para no spamear.
                        await redis_client.set(afk_notified_key, "1", ex=timedelta(days=1))
        except Exception:
            logging.exception("[AFK CHECK] Ocurrió un error durante el chequeo de AFK.")

    PREVIOUSLY_ONLINE_IDS = currently_online_ids
    logging.info(f"[AFK CHECK] Chequeo finalizado. {len(PREVIOUSLY_ONLINE_IDS)} jugadores online.")
# === FIN: src/services/online_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
"""
Módulo de Servicio para la Gestión de Permisos y Locks.

Este servicio es el responsable de interpretar los "lock strings" (cadenas de
permisos) que se encuentran en varias entidades del juego (comandos, salidas,
objetos) y determinar si un personaje tiene permiso para realizar una acción.

Actualmente, solo implementa la función de lock `rol()`, pero está diseñado
para ser fácilmente expandible con funciones más complejas como `habilidad()`,
`tiene_objeto()`, etc.
"""

import logging
from src.models.character import Character


def _check_role(character: Character, required_role: str) -> bool:
    """
    Función de lock interna: Verifica si el personaje tiene el rol requerido.
    Compara de forma insensible a mayúsculas.
    """
    if not character or not character.account:
        return False
    return character.account.role.upper() == required_role.upper()


async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Evalúa un `lock_string` contra un personaje para ver si puede pasar el lock.

    Args:
        character (Character): El personaje que intenta la acción.
        lock_string (str): La cadena de permisos a evaluar (ej: "rol(ADMINISTRADOR)").

    Returns:
        tuple[bool, str]: Una tupla conteniendo:
                          - `True` si puede pasar, `False` si no.
                          - Una cadena con el mensaje de error si falla, o vacía si tiene éxito.
    """
    try:
        # Un lock vacío siempre se puede pasar. Es la forma de definir una acción "pública".
        if not lock_string:
            return True, ""

        # Por ahora, el parser es simple y solo soporta la lógica 'Y' (AND).
        # "rol(A) y tiene_objeto(B)" se divide en una lista de dos funciones.
        lock_functions = lock_string.lower().split(' y ')

        for func_str in lock_functions:
            # Futuro: Aquí iría un parser más avanzado para manejar funciones
            # con argumentos y operadores lógicos complejos.

            # Implementación actual: `rol(argumento)`
            if func_str.startswith('rol(') and func_str.endswith(')'):
                required_role = func_str[4:-1]
                if not _check_role(character, required_role):
                    return False, "No tienes el rango necesario para hacer eso."

            # Si encontramos una función de lock que no entendemos, por seguridad, denegamos el acceso.
            else:
                logging.warning(f"Función de lock desconocida encontrada: {func_str} en lock string: '{lock_string}'")
                return False, "Esa acción está bloqueada por una fuerza desconocida."

        # Si el personaje pasó todos los chequeos de la cadena, tiene permiso.
        return True, ""

    except Exception:
        logging.exception(f"Error al parsear el lock_string: '{lock_string}'")
        # En caso de cualquier error de parseo, siempre fallamos de forma segura.
        return False, "Error interno al comprobar los permisos."
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py
"""
Módulo de Servicio para la Gestión de Jugadores y Personajes.

Este es uno de los servicios centrales de la aplicación. Encapsula toda la
lógica de negocio para crear, recuperar y modificar las entidades `Account` y
`Character`.

Actúa como la única capa que interactúa directamente con los modelos de jugador,
asegurando que toda la lógica de negocio esté centralizada y sea consistente.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.services import channel_service, command_service


async def get_character_with_relations_by_id(session: AsyncSession, character_id: int) -> Character | None:
    """
    Busca un personaje por su ID y carga explícitamente todas sus relaciones
    críticas (sala, inventario, cuenta, configuraciones) en una sola consulta.

    Esta es una función de ayuda crucial para evitar errores de "carga perezosa"
    (lazy loading) en un entorno asíncrono.
    """
    try:
        query = (
            select(Character)
            .where(Character.id == character_id)
            .options(
                selectinload(Character.room).selectinload(Room.items),
                selectinload(Character.room).selectinload(Room.exits_from),
                selectinload(Character.items),
                selectinload(Character.account),
                selectinload(Character.settings)
            )
        )
        result = await session.execute(query)
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al obtener el personaje completo con ID {character_id}")
        return None

async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Garantiza que el objeto `Account` devuelto contenga un `Character` completamente
    cargado si este existe.
    """
    try:
        # 1. Buscar la cuenta y su personaje asociado.
        account_query = select(Account).where(Account.telegram_id == telegram_id).options(selectinload(Account.character))
        result = await session.execute(account_query)
        account = result.scalar_one_or_none()

        # 2. Si la cuenta no existe, crearla y devolverla.
        if not account:
            logging.info(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
            new_account = Account(telegram_id=telegram_id)
            session.add(new_account)
            await session.commit()
            await session.refresh(new_account)
            return new_account

        # 3. Si la cuenta existe pero no tiene personaje, devolverla tal cual.
        if not account.character:
            return account

        # 4. Si la cuenta y el personaje existen, usar nuestra función de ayuda para
        #    asegurarnos de que el personaje está completamente cargado con todas sus relaciones.
        full_character = await get_character_with_relations_by_id(session, account.character.id)
        account.character = full_character
        return account
    except Exception:
        logging.exception(f"Error al obtener o crear la cuenta para telegram_id {telegram_id}")
        # En caso de un fallo crítico, es más seguro devolver None.
        return None

async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje, lo asocia a una cuenta, y dispara los hooks de bienvenida.
    """
    account = await get_or_create_account(session, telegram_id)
    if not account:
        raise RuntimeError("No se pudo obtener o crear una cuenta de usuario.")

    # Validaciones de negocio
    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya está en uso. Por favor, elige otro.")

    # Creación y persistencia
    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1 # Asigna a la sala de inicio "limbo"
    )
    session.add(new_character)
    await session.commit()

    # Recargamos el personaje por completo para tener todas las relaciones disponibles.
    full_character = await get_character_with_relations_by_id(session, new_character.id)
    if not full_character:
        raise RuntimeError("No se pudo recargar el personaje recién creado.")

    # Hooks de post-creación
    await channel_service.get_or_create_settings(session, full_character)
    welcome_message = (
        f"¡Bienvenido al mundo, {full_character.name}! "
        "Usa los comandos de movimiento como <b>/norte</b> o <b>/sur</b> para explorar. "
        "Si necesitas ayuda, puedes preguntar en este canal usando <b>/novato [tu pregunta]</b>. "
        "Para una lista de comandos más detallada, escribe <b>/ayuda</b>."
    )
    await channel_service.broadcast_to_channel(session, "novato", welcome_message)

    await command_service.update_telegram_commands(full_character)

    return full_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala actualizando su `room_id`."""
    # Validación: asegurar que la sala de destino existe.
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    # Actualización atómica
    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py
"""
Módulo de Servicio para la Ejecución de Scripts.

Este servicio actúa como el "traductor" entre el contenido del juego (definido
como strings en los archivos de prototipos) y la lógica del motor (código Python).
Permite que los diseñadores de contenido invoquen funcionalidades del motor
sin necesidad de escribir código.

Funciona con un sistema de registro:
1.  Las funciones de script se definen en este archivo.
2.  Se registran en el diccionario `SCRIPT_REGISTRY` con un nombre único.
3.  Los archivos de prototipos en `game_data` usan ese nombre para referirse a ellas.
4.  El método `execute_script` se encarga de parsear el string, buscar la
    función en el registro y ejecutarla con el contexto adecuado.
"""

import re
import random
import logging
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.character import Character
from src.models.item import Item
from src.models.room import Room
from src.services import broadcaster_service


# ==============================================================================
# SECCIÓN 1: DEFINICIONES DE LAS FUNCIONES DE SCRIPT
#
# Cada función aquí es una "habilidad" que el motor ofrece a los diseñadores
# de contenido. Deben ser genéricas y reutilizables.
# ==============================================================================

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Notifica al jugador que un objeto brilla al ser mirado.

    - Disparador Típico: `on_look` en un prototipo de objeto.
    - Contexto Esperado: `character` (quien mira), `target` (el objeto mirado).
    - Argumentos: `color` (str, opcional) - el color del brillo.
    """
    color = kwargs.get("color", "una luz misteriosa")
    message = f"🌟 Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."
    await broadcaster_service.send_message_to_character(character, message)


async def script_espada_susurra_secreto(session: AsyncSession, target: Item, character: Character, **kwargs):
    """
    Script de ticker: Hace que un objeto emita un susurro a un personaje activo
    que se encuentre en la misma sala.

    - Disparador Típico: `tickers` en un prototipo de objeto.
    - Contexto Esperado: `target` (el objeto que susurra), `character` (el jugador que escucha).
    - Argumentos: Ninguno.
    """
    secretos = [
        "El tesoro se encuentra bajo la sombra del roble marchito...",
        "La llave oxidada no abre una puerta, sino un corazón...",
        "Cuidado con el que no proyecta sombra...",
    ]
    secreto_elegido = random.choice(secretos)
    mensaje = f"<i>Un susurro escalofriante parece emanar de {target.get_name()}: \"{secreto_elegido}\"</i>"
    await broadcaster_service.send_message_to_character(character, mensaje)


# ==============================================================================
# SECCIÓN 2: REGISTRO DE SCRIPTS
#
# Este diccionario es el puente entre los nombres de los scripts (strings)
# y las funciones de Python reales. Para que un script pueda ser llamado
# desde `game_data`, DEBE estar registrado aquí.
# ==============================================================================

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,
    # Futuros scripts se añadirían aquí.
}


# ==============================================================================
# SECCIÓN 3: EL MOTOR DE EJECUCIÓN
#
# Lógica interna del servicio para interpretar y ejecutar los scripts.
# ==============================================================================

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre(clave=valor, ...)' y devuelve
    el nombre de la función y un diccionario de argumentos.

    Limitación actual: solo soporta argumentos simples de tipo `clave=valor`.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        # Si el script no tiene paréntesis, se asume que no tiene argumentos.
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            logging.warning(f"Argumentos de script mal formados en '{script_string}'. Ignorando argumentos.")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El corazón del motor de scripts. Parsea el string, busca la función en
    el registro y la ejecuta con el contexto proporcionado.

    Args:
        script_string (str): El string del script a ejecutar (ej: "mi_script(arg=val)").
        session (AsyncSession): La sesión de base de datos activa.
        **context: Un diccionario con las entidades relevantes al evento
                   (ej: `character`, `target`, `room`).
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        try:
            # Ejecutamos la función encontrada, pasando el contexto y los argumentos parseados.
            await script_function(session=session, **context, **kwargs)
        except Exception:
            # Si un script falla, registramos el error con un traceback completo
            # pero no detenemos la ejecución del resto del juego.
            logging.exception(f"Ocurrió un error al ejecutar el script '{script_name}'")
    else:
        logging.warning(f"ADVERTENCIA: Se intentó ejecutar un script desconocido: '{script_name}'")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/ticker_service.py ===
# src/services/ticker_service.py
"""
Módulo de Servicio para Tareas Programadas (Tickers).

Este servicio es el "corazón" que hace que el mundo de Runegram se sienta vivo.
Utiliza la librería APScheduler para ejecutar scripts de forma periódica,
independientemente de las acciones de los jugadores.

Responsabilidades:
- Inicializar y configurar el scheduler global (APScheduler).
- Cargar las definiciones de tickers desde los prototipos de `game_data`.
- Programar, ejecutar y gestionar el ciclo de vida de estas tareas.
- Determinar el contexto correcto para un ticker (ej: la sala de un objeto)
  y filtrar su ejecución (ej: solo para jugadores activos).
"""

import logging
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.db import async_session_factory
from src.services import script_service, online_service, player_service
from src.models import Item, Room, Character

# Instancia única del scheduler para toda la aplicación.
scheduler = AsyncIOScheduler()


# ==============================================================================
# SECCIÓN DE FUNCIONES AUXILIARES
# ==============================================================================

def parse_schedule(schedule_str: str) -> tuple[str, dict]:
    """
    Parsea el string de schedule del prototipo y lo convierte en argumentos para APScheduler.
    """
    if schedule_str.startswith("interval:"):
        seconds = int(schedule_str.split(':')[1])
        return 'interval', {'seconds': seconds}
    if schedule_str.startswith("date:"):
        date_val = schedule_str.split(':', 1)[1]
        return 'date', {'run_date': date_val}
    cron_expr = schedule_str
    if schedule_str.startswith("cron:"):
        cron_expr = schedule_str.split(':', 1)[1]
    parts = cron_expr.strip().split()
    if len(parts) != 5:
        logging.warning(f"ADVERTENCIA: Expresión cron mal formada en '{schedule_str}'. Se ignora.")
        return 'cron', {}
    cron_args = { 'minute': parts[0], 'hour': parts[1], 'day': parts[2], 'month': parts[3], 'day_of_week': parts[4] }
    return 'cron', cron_args


async def get_entity_by_id(session: AsyncSession, entity_id: int, entity_type: str):
    """
    Busca una entidad por su ID y tipo, cargando explícitamente las relaciones
    necesarias para evitar errores de carga perezosa.
    """
    MODEL_MAP = {"Item": Item, "Room": Room, "Character": Character}
    model_class = MODEL_MAP.get(entity_type)
    if not model_class:
        logging.warning(f"ADVERTENCIA: Tipo de entidad desconocido '{entity_type}' para ticker.")
        return None

    query = select(model_class)
    if model_class is Item:
        query = query.options(
            selectinload(Item.room),
            selectinload(Item.character).selectinload(Character.room)
        )
    elif model_class is Character:
        query = query.options(selectinload(Character.room), selectinload(Character.account))

    query = query.where(model_class.id == entity_id)
    result = await session.execute(query)
    return result.scalar_one_or_none()


# ==============================================================================
# SECCIÓN DE INICIALIZACIÓN Y CARGA
# ==============================================================================

def initialize_scheduler():
    """Configura y arranca el scheduler global. Debe llamarse al iniciar el bot."""
    jobstores = {'default': SQLAlchemyJobStore(url=settings.sync_database_url)}
    scheduler.configure(jobstores=jobstores)
    scheduler.start()
    logging.info("⏰ Ticker Service iniciado y listo para programar tareas.")

async def load_and_schedule_all_tickers(session: AsyncSession):
    """
    Busca todas las entidades con tickers en la base de datos (actualmente solo Items)
    y las programa. Debe llamarse una vez al iniciar el bot para asegurar la persistencia.
    """
    logging.info("Cargando y programando tickers para todas las entidades existentes...")
    try:
        result = await session.execute(select(Item))
        all_items = result.scalars().all()
        for item in all_items:
            if item.prototype.get("tickers"):
                logging.info(f"  -> Programando tickers para el item '{item.key}' (ID: {item.id})")
                await schedule_tickers_for_entity(item)
        logging.info("Carga de tickers existentes finalizada.")
    except Exception:
        logging.exception("Error al cargar los tickers de entidades existentes.")


# ==============================================================================
# SECCIÓN DE EJECUCIÓN DE TAREAS
# ==============================================================================

async def schedule_tickers_for_entity(entity):
    """
    Lee los tickers del prototipo de una entidad y los añade al scheduler.
    """
    prototype_tickers = entity.prototype.get("tickers", [])
    for ticker_data in prototype_tickers:
        schedule_str = ticker_data.get("schedule")
        script_str = ticker_data.get("script")
        category = ticker_data.get("category", "ambient")

        if not schedule_str or not script_str:
            continue
        trigger_type, trigger_args = parse_schedule(schedule_str)
        if not trigger_args:
            continue

        job_id = f"ticker_{type(entity).__name__}_{entity.id}_{schedule_str}_{script_str}"
        scheduler.add_job(
            execute_ticker_script, trigger=trigger_type,
            args=[entity.id, type(entity).__name__, script_str, category],
            id=job_id, replace_existing=True, **trigger_args
        )

async def execute_ticker_script(entity_id: int, entity_type: str, script_string: str, category: str):
    """
    Función que APScheduler llama. Prepara el contexto, comprueba la actividad
    del jugador y delega la ejecución al script_service.
    """
    async with async_session_factory() as session:
        try:
            entity = await get_entity_by_id(session, entity_id, entity_type)
            if not entity: return

            # 1. Determinar la sala de contexto del ticker.
            room = None
            if hasattr(entity, 'room') and entity.room:
                room = entity.room
            elif hasattr(entity, 'character') and entity.character and entity.character.room:
                room = entity.character.room

            if not room: return

            # 2. Encontrar los IDs de los personajes en esa sala.
            char_ids_query = select(Character.id).where(Character.room_id == room.id)
            result = await session.execute(char_ids_query)
            char_ids_in_room = result.scalars().all()

            # 3. Iterar sobre cada personaje, aplicar filtros y ejecutar el script.
            for char_id in char_ids_in_room:
                is_online = await online_service.is_character_online(char_id)
                if category == "ambient" and not is_online:
                    continue

                full_character = await player_service.get_character_with_relations_by_id(session, char_id)
                if not full_character:
                    continue

                context = {
                    "target": entity,
                    "room": full_character.room,
                    "character": full_character
                }

                await script_service.execute_script(
                    script_string=script_string,
                    session=session,
                    **context
                )
        except Exception:
            logging.exception(f"Error crítico en la ejecución del ticker para {entity_type} {entity_id}")
# === FIN: src/services/ticker_service.py ===


# === INICIO: src/services/world_loader_service.py ===
# src/services/world_loader_service.py
"""
Módulo de Servicio para la Carga del Mundo.

Este servicio es el responsable de construir y sincronizar el mundo estático del
juego (salas y salidas) con la base de datos. Se ejecuta una sola vez durante
el arranque de la aplicación.

Lee las definiciones de contenido desde `game_data/room_prototypes.py` y se
asegura de que el estado de la base de datos refleje fielmente esa "fuente de
la verdad".
"""

import logging
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Room, Exit
from game_data.room_prototypes import ROOM_PROTOTYPES

# Mapa de direcciones opuestas para crear automáticamente las salidas bidireccionales.
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def sync_world_from_prototypes(session: AsyncSession):
    """
    Sincroniza la base de datos con los prototipos de salas. Esta función es
    idempotente: se puede ejecutar de forma segura en cada arranque.

    Su lógica es:
    1. Crea las salas que no existen y actualiza los datos de las que sí existen.
    2. Borra por completo todas las salidas existentes.
    3. Recrea todas las salidas basándose en las definiciones actuales.
    """
    logging.info("Sincronizando el mundo estático desde los prototipos...")
    try:
        # --- PASO 1: Sincronizar Salas ---
        # Se asegura de que todas las salas definidas en los prototipos existan en la BD
        # y actualiza su nombre/descripción. Guarda un mapa de `key` a `id` para el siguiente paso.
        room_key_to_id_map = {}

        # Obtenemos todas las salas existentes de la BD para compararlas.
        existing_rooms_query = await session.execute(select(Room))
        existing_rooms = {room.key: room for room in existing_rooms_query.scalars().all()}

        for key, data in ROOM_PROTOTYPES.items():
            room = existing_rooms.get(key)
            if not room:
                # La sala no existe en la BD, la creamos.
                logging.info(f"  -> Creando sala '{key}'...")
                room = Room(key=key, name=data['name'], description=data['description'])
                session.add(room)
            else:
                # La sala ya existe, actualizamos sus datos por si cambiaron.
                room.name = data['name']
                room.description = data['description']

            # `flush` envía los cambios a la BD sin cerrar la transacción, lo que
            # nos permite obtener el ID de las nuevas salas antes del commit final.
            await session.flush()
            room_key_to_id_map[key] = room.id

        # --- PASO 2: Limpiar Salidas Viejas ---
        # Es más simple y seguro borrar todas las salidas y recrearlas que intentar
        # parchear las existentes. Esto asegura que las salidas eliminadas de los
        # prototipos también se eliminen de la BD.
        logging.info("  -> Limpiando todas las salidas existentes para reconstruir...")
        await session.execute(delete(Exit))

        # --- PASO 3: Crear Salidas Nuevas ---
        # Itera de nuevo sobre los prototipos y crea las filas en la tabla `exits`.
        for key, data in ROOM_PROTOTYPES.items():
            from_room_id = room_key_to_id_map[key]
            for direction, to_room_key in data.get("exits", {}).items():
                if to_room_key in room_key_to_id_map:
                    to_room_id = room_key_to_id_map[to_room_key]

                    # Crear la salida principal (ej: A -> B, "norte")
                    exit_forward = Exit(name=direction.lower(), from_room_id=from_room_id, to_room_id=to_room_id)
                    session.add(exit_forward)

                    # Crear la salida de vuelta automáticamente (ej: B -> A, "sur")
                    opposite = OPPOSITE_DIRECTIONS.get(direction.lower())
                    if opposite:
                        exit_backward = Exit(name=opposite, from_room_id=to_room_id, to_room_id=from_room_id)
                        session.add(exit_backward)
                else:
                    logging.warning(f"  -> La sala de destino '{to_room_key}' definida en la sala '{key}' no existe. Se ignora la salida.")

        await session.commit()
        logging.info("¡Sincronización del mundo completada!")
    except Exception:
        # Un fallo aquí es crítico para el arranque del bot.
        logging.exception("Error fatal durante la sincronización del mundo.")
        # Relanzamos la excepción para que la función on_startup la capture y detenga el bot.
        raise
# === FIN: src/services/world_loader_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py
"""
Módulo de Servicio con Utilidades para el Mundo.

Este servicio contiene funciones de ayuda de bajo nivel para interactuar
con las entidades del mundo, principalmente el modelo `Room`.

A diferencia del `world_loader_service` que construye el mundo al arrancar,
las funciones aquí presentes son utilidades genéricas que pueden ser llamadas
desde otras partes del código, como los comandos.

NOTA: Varias funciones en este archivo (`create_room`, `link_rooms`) han quedado
obsoletas por el sistema de carga de mundo basado en prototipos, pero se
mantienen por si son de utilidad para futuras herramientas de administración
o para depuración.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit


async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """
    Busca y devuelve una sala por su ID numérico.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        room_id (int): El ID de la sala a buscar.

    Returns:
        Room | None: El objeto de la sala si se encuentra, de lo contrario None.
    """
    try:
        result = await session.execute(select(Room).where(Room.id == room_id))
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al buscar la sala con ID {room_id}")
        return None

# ==============================================================================
# Las siguientes funciones han sido mayormente reemplazadas por el sistema de
# carga de mundo (`world_loader_service`) y ya no se usan en el flujo principal.
# Se conservan para posible uso futuro en herramientas de administración.
# ==============================================================================

async def create_room(session: AsyncSession, name: str) -> Room:
    """
    (Obsoleto) Crea una nueva sala en la base de datos.
    """
    if not name:
        raise ValueError("El nombre de la sala no puede estar vacío.")
    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """
    (Obsoleto) Actualiza la descripción de una sala existente.
    """
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """
    (Obsoleto) Crea una salida (y opcionalmente su opuesta) entre dos salas.
    """
    # Mapa de direcciones opuestas, duplicado aquí para que la función sea autónoma.
    OPPOSITE_DIRECTIONS = {
        "norte": "sur", "sur": "norte", "este": "oeste", "oeste": "este",
        "arriba": "abajo", "abajo": "arriba", "dentro": "fuera", "fuera": "dentro",
        "noreste": "suroeste", "suroeste": "noreste", "noroeste": "sureste", "sureste": "noroeste",
    }

    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===
# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py
"""
Módulo de Utilidades de Presentación (Presenters).

Este archivo contiene funciones cuya única responsabilidad es tomar los objetos
de datos del juego (como `Room`, `Item`, `Character`) y convertirlos en texto
formateado listo para ser mostrado al jugador en Telegram.

Esta capa de "presentación" separa la lógica de cómo se ven las cosas (formato
HTML, colores, etc.) de la lógica de negocio del juego (que reside en los
servicios).
"""

import logging
from aiogram import types
from collections import Counter

from src.models.room import Room
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripción completa de una sala para ser
    mostrada al jugador.

    Args:
        room (Room): El objeto de la sala a formatear, con sus relaciones
                     (`items`, `exits_from`) ya cargadas.

    Returns:
        str: Un string formateado con HTML (`<pre>`, `<b>`) listo para ser enviado.
    """
    try:
        parts = []

        # 1. Título de la Sala
        parts.append(f"<b>{room.name}</b>")

        # 2. Descripción principal
        parts.append(room.description.strip())

        # 3. Objetos en la sala
        if room.items:
            # Usamos `collections.Counter` para agrupar objetos idénticos.
            # Por ejemplo, tres objetos con `get_name()`="una moneda de oro"
            # se mostrarán como "una moneda de oro (3)".
            item_names = [item.get_name() for item in room.items]
            item_counts = Counter(item_names)
            formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
            items_str = ", ".join(formatted_items)
            parts.append(f"\n<b>Ves aquí:</b> {items_str}.")

        # 4. Salidas
        if room.exits_from:
            # Ordenamos las salidas alfabéticamente para una visualización consistente.
            exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
            exits_str = ", ".join(exits_list)
            parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
        else:
            parts.append("\n<b>Salidas:</b> [ Ninguna ]")

        # Unimos todas las partes y las envolvemos en una etiqueta <pre>
        # para mantener el formato de monoespaciado y los saltos de línea.
        description_body = "\n".join(parts)
        return f"<pre>{description_body}</pre>"

    except Exception:
        logging.exception(f"Error al formatear la descripción de la sala ID {room.id}")
        return "<pre><b>Error:</b> No se pudo mostrar la descripción de la sala.</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripción formateada.
    Esta función centraliza la lógica común de "mirar" el entorno.
    """
    try:
        async with async_session_factory() as session:
            # Usamos el servicio para obtener la cuenta y sus relaciones precargadas.
            account = await player_service.get_or_create_account(session, message.from_user.id)

            if not account or not account.character or not account.character.room:
                # Esta es una salvaguarda. No debería ocurrir en un flujo normal.
                await message.answer("Parece que estás perdido en el vacío. Te hemos llevado a un lugar seguro.")
                # Futuro: Aquí podríamos teletransportar al jugador a la sala de inicio.
                return

            room = account.character.room
            # Usamos nuestro formateador para construir el texto de la sala.
            formatted_room = await format_room(room)

            await message.answer(formatted_room, parse_mode="HTML")

    except Exception:
        await message.answer("❌ Ocurrió un error al mostrar tu ubicación actual.")
        logging.exception(f"Fallo en show_current_room para el usuario {message.from_user.id}")
# === FIN: src/utils/presenters.py ===


