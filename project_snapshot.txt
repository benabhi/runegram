# === INICIO: .gitignore ===
project_snapshot.txt
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¬°Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Cach√© de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Cach√© de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querr√°s subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de c√≥digo
# Configuraciones espec√≠ficas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena pr√°ctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: Dockerfile ===
# Dockerfile para la Aplicaci√≥n Runegram MUD
#
# Este archivo define los pasos para construir la imagen Docker que contendr√°
# y ejecutar√° la aplicaci√≥n del bot. Docker utiliza esta "receta" para crear un
# entorno autocontenido y reproducible.
#
# El proceso de construcci√≥n sigue estos pasos:
# 1. FROM: Se parte de una imagen base oficial de Python sobre Alpine Linux.
# 2. RUN (apk): Se instalan las dependencias a nivel de sistema operativo que
#    necesita nuestra aplicaci√≥n (ej: librer√≠as de PostgreSQL, herramientas de red).
# 3. WORKDIR: Se establece el directorio de trabajo dentro del contenedor.
# 4. COPY / RUN (pip): Se copia primero el archivo de dependencias de Python y se
#    instalan. Este paso se hace por separado para aprovechar la cach√© de Docker.
#    Si el `requirements.txt` no cambia, Docker no volver√° a ejecutar este paso,
#    acelerando construcciones futuras.
# 5. COPY (c√≥digo fuente): Se copia el resto del c√≥digo de la aplicaci√≥n.
# 6. CMD: Se define el comando por defecto que se ejecutar√° al iniciar el contenedor,
#    el cual es interceptado y gestionado por nuestro `entrypoint.sh`.

# 1. Imagen Base
# Usamos la imagen oficial de Python 3.11 basada en Alpine Linux.
# Alpine es una distribuci√≥n muy ligera, lo que resulta en una imagen final m√°s peque√±a.
FROM python:3.11-alpine

# 2. Dependencias del Sistema
# Usamos el gestor de paquetes de Alpine (`apk`) para instalar software necesario.
# --no-cache: No guarda el √≠ndice de paquetes, manteniendo la imagen ligera.
# - postgresql-libs: Librer√≠as C requeridas por el driver `psycopg2-binary`.
# - netcat-openbsd: Herramienta de red utilizada en `entrypoint.sh` para esperar a PostgreSQL.
# - git: Puede ser √∫til para instalar dependencias de Python directamente desde repositorios.
RUN apk add --no-cache postgresql-libs netcat-openbsd git

# 3. Directorio de Trabajo
# Establece el directorio de trabajo por defecto dentro del contenedor.
# Todos los comandos `RUN`, `CMD`, `ENTRYPOINT`, `COPY` y `ADD` posteriores
# se ejecutar√°n en este directorio.
WORKDIR /app

# 4. Dependencias de Python
# Copiamos solo el archivo de requerimientos primero. Esto es una optimizaci√≥n
# de la cach√© de Docker. Si nuestro c√≥digo cambia pero `requirements.txt` no,
# Docker reutilizar√° la capa de imagen ya existente donde se instalaron las
# dependencias, haciendo que la reconstrucci√≥n sea mucho m√°s r√°pida.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. C√≥digo Fuente de la Aplicaci√≥n
# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable.
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

# Copiamos el resto del c√≥digo fuente del proyecto al directorio de trabajo (`/app`).
COPY . .

# 6. Comando de Ejecuci√≥n
# Define el comando por defecto que se ejecutar√° al iniciar un contenedor
# a partir de esta imagen.
# IMPORTANTE: Este comando se pasa como argumento a nuestro `entrypoint.sh`
# (definido en `docker-compose.yml`), que lo ejecuta al final con `exec "$@"`.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: NOTAS.md ===
## Telegram

### Mi ID de usuario (benabbhi)

1648877346

## Postgres

### Conectarse

```shell
docker-compose exec postgres psql -U runegram -d runegram_db
```
### Ver tablas

```
\dt
```

## Docker

### Prune

```shell
docker system prune -a --volumes
```

## TODO

* Las salas no muestran los objetos caidos
* Como se determina que comando le corresponde a quie?
* No se actualizan ambos extremos de las salidas
# === FIN: NOTAS.md ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

Runegram es un proyecto para crear un juego de rol textual multijugador (MUD - Multi-User Dungeon) que se juega a trav√©s de la interacci√≥n con un bot de Telegram. Este repositorio contiene el motor de un juego funcional, con una arquitectura escalable lista para la expansi√≥n masiva de contenido.

## Filosof√≠a de Dise√±o: Motor vs. Contenido

La arquitectura del proyecto se divide en dos conceptos clave para m√°xima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **c√≥digo fuente** de la aplicaci√≥n. Es la maquinaria gen√©rica que hace que el juego funcione (conexi√≥n a la base de datos, comunicaci√≥n con Telegram, ejecuci√≥n de l√≥gica). No sabe qu√© es una "espada", solo sabe c√≥mo manejar un "√çtem".
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** que dan vida al mundo. Aqu√≠ se define qu√© es una "espada", qu√© hace el comando "atacar", o qu√© monstruos existen. Est√° dise√±ado para que los dise√±adores de juego puedan a√±adir contenido sin tocar el motor principal.

## Sistemas Clave Implementados

### 1. Carga del Mundo Dirigida por Datos
El mundo est√°tico del juego ya no se construye con comandos de administrador, sino que se define enteramente en archivos de datos.

*   **Definici√≥n (`game_data/room_prototypes.py`):** Todas las salas, sus descripciones y las conexiones entre ellas se definen en un diccionario de Python. Esto act√∫a como el "mapa maestro" del mundo.
*   **Sincronizaci√≥n (`world_loader_service.py`):** Al iniciar el bot, un servicio dedicado lee estos prototipos, comprueba el estado de la base de datos y crea o actualiza las salas y salidas para que coincidan con la "fuente de la verdad". Esto garantiza un mundo consistente en cada reinicio.

### 2. Sistema de Comandos Din√°micos y Contextuales
La lista de comandos disponibles para un jugador no es est√°tica; cambia en tiempo real seg√∫n su contexto.

*   **M√∫ltiples Fuentes:** Un `command_service` centralizado construye la lista de `CommandSets` activos para un jugador a partir de:
    1.  **Base:** Comandos innatos del personaje, guardados en la base de datos.
    2.  **Equipo:** Objetos en el inventario que otorgan `CommandSets` (ej: unas ganz√∫as que otorgan el set `thievery`).
    3.  **Entorno:** La sala actual, que puede otorgar `CommandSets` (ej: una forja que otorga el set `smithing`).
    4.  **Rol:** Los administradores reciben sets de comandos especiales.
*   **Actualizaci√≥n en Telegram:** El motor actualiza la lista de comandos (`/`) en el cliente de Telegram del jugador en tiempo real, cada vez que su contexto cambia (al moverse de sala, coger un objeto, etc.), proporcionando una experiencia de usuario fluida e intuitiva.

### 3. Sistema Dual de Scripts: Eventos y Tickers
El motor permite que el contenido del juego ejecute l√≥gica a trav√©s de dos sistemas complementarios.

*   **Scripts Reactivos (Eventos):** Son disparados por acciones del jugador.
    *   **Trigger:** `"on_look": "script_nombre(...)"` en el prototipo de un objeto.
    *   **Ejecuci√≥n:** Cuando un jugador mira el objeto, el `script_service` ejecuta la funci√≥n correspondiente.
*   **Scripts Proactivos (Tickers):** Se ejecutan de forma programada, independientemente de la acci√≥n del jugador, haciendo que el mundo se sienta vivo.
    *   **Definici√≥n:** `"tickers": [{"schedule": "*/5 * * * *", "script": "...", "category": "ambient"}]`
    *   **Ejecuci√≥n:** Un `ticker_service` (usando `APScheduler`) se encarga de ejecutar estos scripts seg√∫n su horario (cron o intervalo).
    *   **Inteligencia:** Los tickers de categor√≠a `"ambient"` solo se ejecutan para jugadores considerados "activos", evitando notificar a usuarios que no est√°n jugando.

### 4. Sistema de Canales y Presencia
Para facilitar la comunicaci√≥n y la inmersi√≥n social, el juego implementa un sistema de canales y seguimiento de actividad.

*   **Seguimiento de Actividad (`online_service.py`):** Utilizando **Redis** para m√°xima velocidad, el motor registra un timestamp cada vez que un jugador env√≠a un comando. Si la √∫ltima actividad fue hace menos de 5 minutos, se le considera "online".
*   **Canales (`channel_service.py`):**
    *   Se definen en `game_data/channel_prototypes.py`.
    *   Los jugadores pueden suscribirse o desuscribirse (`/canal activar/desactivar`).
    *   Permiten comunicaci√≥n global (ej: `/novato [mensaje]`) entre todos los jugadores suscritos.
    *   El comando `/quien` utiliza el `online_service` para mostrar una lista de los jugadores activos.

## Estructura del Proyecto

```
runegram/
‚îú‚îÄ‚îÄ alembic/              # Migraciones de la base de datos
‚îú‚îÄ‚îÄ commands/             # DEFINICI√ìN de los comandos (clases Command)
‚îÇ   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îî‚îÄ‚îÄ player/
‚îú‚îÄ‚îÄ game_data/            # DEFINICI√ìN del contenido del juego
‚îÇ   ‚îú‚îÄ‚îÄ channel_prototypes.py # Define los canales de chat
‚îÇ   ‚îú‚îÄ‚îÄ item_prototypes.py    # Define los prototipos de objetos
‚îÇ   ‚îî‚îÄ‚îÄ room_prototypes.py    # Define el mapa del mundo (salas y salidas)
‚îú‚îÄ‚îÄ scripts/              # Scripts de utilidad (ej: full_reset.bat)
‚îú‚îÄ‚îÄ src/                  # C√ìDIGO FUENTE del motor de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ bot/
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ player/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ dispatcher.py # El router de comandos principal
‚îÇ   ‚îú‚îÄ‚îÄ models/           # Modelos de datos de SQLAlchemy
‚îÇ   ‚îú‚îÄ‚îÄ services/         # L√≥gica de negocio y acceso a datos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ broadcaster_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ channel_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ online_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ script_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticker_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ world_loader_service.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ .env                  # Archivo de variables de entorno (ignorado)
‚îú‚îÄ‚îÄ docker-compose.yml    # Orquestaci√≥n de los contenedores
‚îú‚îÄ‚îÄ Dockerfile            # Definici√≥n de la imagen Docker de la app
‚îú‚îÄ‚îÄ entrypoint.sh         # Script de arranque
‚îî‚îÄ‚îÄ run.py                # Punto de entrada
```

## Puesta en Marcha

Se necesita Docker y Docker Compose.

1.  **Configurar el Entorno:** Crea un archivo `.env` en la ra√≠z del proyecto a partir del `.env.example`.
2.  **Ejecutar el Script de Reinicio:** Para asegurar un entorno limpio, usa el script automatizado.
    ```bash
    # En Windows
    scripts\full_reset.bat
    ```
    Este script reconstruir√° la imagen, levantar√° los servicios y aplicar√° todas las migraciones.
3.  **Jugar:** Abre Telegram y env√≠a `/start` a tu bot.

---

## Visi√≥n a Futuro y Tareas Pendientes (TODO)

Esta secci√≥n documenta las pr√≥ximas mejoras para evolucionar de un motor robusto a un juego completo y pulido.

### üöÄ **Pr√≥ximas Grandes Funcionalidades**

*   #### **Sistema de Combate y Habilidades**
    *   **Visi√≥n:** Crear un sistema de combate y progresi√≥n de habilidades basado en una mec√°nica de d100 (tirada de 100 caras).
    *   **Tareas:**
        1.  **Modelos de Datos:** Crear los modelos `Skill` y `CharacterSkill`. A√±adir atributos de combate (Salud, Man√°, etc.) al modelo `Character`.
        2.  **Mec√°nica d100:** Implementar la l√≥gica de "aprender haciendo": una acci√≥n tiene √©xito si `d100 <= nivel_de_habilidad`, y al tener √©xito, se gana experiencia.
        3.  **PNJs y Spawners:** Crear `npc_prototypes.py`, un modelo `NPC` y un `npc_service` para poder "spawnear" monstruos en el mundo y gestionar su IA (agresiva, pasiva) y sus "respawns".
        4.  **Comandos de Combate:** Crear el `CommandSet` de combate (`/atacar`, `/huir`, etc.).

*   #### **Completar el Sistema de Locks y Permisos**
    *   **Visi√≥n:** Crear un sistema de permisos granular para controlar el acceso a salidas, objetos y comandos, yendo m√°s all√° del simple `rol()`.
    *   **Tareas:**
        1.  **Expandir el Parser:** Mejorar `permission_service` para que entienda una sintaxis rica: `tiene_objeto(llave_oxidada)`, `habilidad(forzar_cerraduras)>25`, `clase(guerrero)`. Implementar operadores l√≥gicos `y` / `o`.
        2.  **Integraci√≥n:** Aplicar la verificaci√≥n de `locks` en el `CmdMove` para las salidas y en el `dispatcher` para los comandos.

### ‚ú® **Mejoras del Motor y Calidad de Vida**

*   **Bandeja de Entrada para Notificaciones:** Para los tickers de categor√≠a `important` o `quest`, guardar los mensajes para los jugadores inactivos y present√°rselos cuando vuelvan a conectarse ("Mientras no estabas...").
*   **Sistema de Contenedores:** Expandir los √≠tems para que puedan ser contenedores (mochilas, cofres) con su propio inventario, capacidad y `locks`.
*   **Sistema de Clases y Razas:** Usar una **M√°quina de Estados Finitos (FSM)** para guiar al jugador a trav√©s de una creaci√≥n de personaje por pasos, permiti√©ndole elegir clase y raza, lo que a su vez establecer√° sus `CommandSets` base en la BD.
*   **Mejorar Comando `/decir`:** Hacer que el comando `/decir` y las acciones de combate env√≠en mensajes a todos los jugadores *online* en la misma sala, creando una verdadera interacci√≥n social.

### üåç **Contenido y Expansi√≥n del Mundo**

*Gracias a la arquitectura Data-Driven, expandir el mundo es ahora una tarea de dise√±o, no de programaci√≥n.*
*   **Crear Nuevos Prototipos:** Dise√±ar m√°s objetos, monstruos y PNJ en los archivos de `game_data`.
*   **Dise√±ar Zonas:** Expandir el `room_prototypes.py` para crear nuevas √°reas, ciudades y mazmorras.
*   **Escribir Quests:** Implementar PNJ que puedan dar misiones, utilizando el sistema de `FSM` para rastrear el progreso del jugador en una quest.
*   **Crear Habilidades y Clases:** Definir las habilidades disponibles en el juego y los `CommandSets` que cada clase aprender√° a medida que progrese.
# === FIN: README.md ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCI√ìN PRINCIPAL DE ALEMBIC
# Aqu√≠ se definen las configuraciones m√°s importantes.
# ==============================================================================
[alembic]

# --- Ubicaci√≥n de los Scripts de Migraci√≥n ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la ra√≠z del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA L√çNEA M√ÅS IMPORTANTE.
# Le dice a Alembic c√≥mo conectarse a tu base de datos PostgreSQL.
# La magia aqu√≠ es que no ponemos la contrase√±a directamente.
# El archivo `alembic/env.py` se encargar√° de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define c√≥mo se nombran los nuevos archivos de migraci√≥n.
# {rev} es el ID de la revisi√≥n, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos despu√©s de que se genera un nuevo archivo de migraci√≥n.
# Es muy √∫til para formatear autom√°ticamente el c√≥digo con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACI√ìN DE LOGGING
# Define c√≥mo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aqu√≠, la configuraci√≥n por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml
#
# Este archivo es la pieza central para orquestar los diferentes servicios
# (contenedores) que componen la aplicaci√≥n Runegram. Docker Compose lee
# este archivo para construir, iniciar, conectar y gestionar todos los
# contenedores de forma conjunta.
#
# Servicios definidos:
# 1. bot:       El contenedor principal de la aplicaci√≥n Python que ejecuta el bot de Telegram.
# 2. postgres:  El servicio de base de datos PostgreSQL.
# 3. redis:     El servicio de cach√© en memoria, utilizado para la gesti√≥n de estados
#               de Aiogram y el seguimiento de actividad de los jugadores.

services:
  # --- Servicio de la Aplicaci√≥n Principal del Bot ---
  bot:
    # `build: .` le dice a Docker Compose que construya una imagen para este servicio
    # utilizando el Dockerfile que se encuentra en el directorio actual ('.').
    build: .

    # `entrypoint`: Sobrescribe el ENTRYPOINT por defecto de la imagen. Aqu√≠ especificamos
    # nuestro script `entrypoint.sh`, que se encargar√° de las tareas de preparaci√≥n
    # (esperar a la BD, ejecutar migraciones) antes de lanzar la aplicaci√≥n principal.
    entrypoint: /app/entrypoint.sh

    # `command`: Especifica el comando que se pasa como argumento al `entrypoint`.
    # Nuestro `entrypoint.sh` ejecuta este comando al final con `exec "$@"`.
    command: python run.py

    # `environment`: Define variables de entorno dentro del contenedor.
    # `PYTHONPATH=/app` asegura que Python pueda encontrar nuestros m√≥dulos en `src/`.
    environment:
      - PYTHONPATH=/app

    # `env_file`: Carga las variables de entorno desde el archivo `.env` en la ra√≠z
    # del proyecto. Esto mantiene las credenciales y configuraciones fuera del c√≥digo.
    env_file:
      - .env

    # `depends_on`: Asegura que los servicios `postgres` y `redis` se inicien
    # *antes* de que se inicie el servicio `bot`. No garantiza que est√©n "listos",
    # por eso nuestro `entrypoint.sh` se encarga de esperar activamente.
    depends_on:
      - postgres
      - redis

    # `volumes`: Mapea directorios de nuestra m√°quina local al interior del contenedor.
    # Esto es crucial para el desarrollo, ya que cualquier cambio en nuestro c√≥digo
    # se refleja instant√°neamente dentro del contenedor sin necesidad de reconstruir la imagen.
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      - ./entrypoint.sh:/app/entrypoint.sh

  # --- Servicio de la Base de Datos ---
  postgres:
    # `image`: Utiliza una imagen preconstruida oficial de PostgreSQL desde Docker Hub.
    # La etiqueta `:15-alpine` especifica la versi√≥n 15 sobre Alpine Linux, que es ligera.
    image: postgres:15-alpine

    # `environment`: Configura las credenciales y el nombre de la base de datos
    # inicial. Los valores `${...}` se leen del archivo `.env` en nuestra m√°quina.
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}

    # `volumes`: Mapea un "volumen nombrado" de Docker (`postgres_data`) al directorio
    # donde PostgreSQL guarda sus datos. Esto hace que los datos de la base de datos
    # sean persistentes, sobreviviendo a reinicios o eliminaciones del contenedor.
    volumes:
      - postgres_data:/var/lib/postgresql/data/

    # `ports`: Mapea el puerto 5432 del contenedor al puerto 5432 de nuestra m√°quina local.
    # Esto nos permite conectarnos a la base de datos desde herramientas locales si es necesario.
    ports:
      - "5432:5432"

  # --- Servicio de Cach√© en Memoria ---
  redis:
    # Utiliza la imagen oficial de Redis, versi√≥n 7 sobre Alpine.
    image: redis:7-alpine

    # Mapea el puerto por defecto de Redis para permitir conexiones locales.
    ports:
      - "6379:6379"

# Define los vol√∫menes nombrados que hemos utilizado. Docker se encarga de gestionarlos.
volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: entrypoint.sh ===
#!/bin/sh
#
# Entrypoint para el Contenedor de la Aplicaci√≥n Runegram
#
# Este script se ejecuta cada vez que el contenedor de la aplicaci√≥n ('bot') se inicia.
# Su principal responsabilidad es preparar el entorno antes de lanzar la aplicaci√≥n
# de Python principal.
#
# Tareas:
# 1. Esperar a que el servicio de PostgreSQL est√© completamente disponible y acepte conexiones.
#    Esto evita que la aplicaci√≥n falle al arrancar si el contenedor de la base de datos
#    tarda m√°s en iniciarse.
# 2. Ejecutar las migraciones de la base de datos con Alembic para asegurar que el
#    esquema de la base de datos est√© actualizado con la √∫ltima versi√≥n del c√≥digo.
# 3. Ejecutar el comando principal del contenedor (CMD), que en nuestro caso es
#    `python run.py`, para iniciar el bot.
#
# `set -e`: Este comando es crucial. Asegura que el script se detenga inmediatamente
# si cualquier comando falla (devuelve un c√≥digo de salida distinto de cero).
#
set -e

# --- PASO 1: Esperar a PostgreSQL ---
echo "--- [Entrypoint] Esperando a que PostgreSQL est√© disponible... ---"
# El host 'postgres' es el nombre del servicio definido en docker-compose.yml.
# El comando `nc -z` (netcat) intenta establecer una conexi√≥n sin enviar datos.
# El bucle `while` se repetir√° hasta que el puerto 5432 de 'postgres' est√© abierto.
while ! nc -z postgres 5432; do
  sleep 0.1
done
echo "--- [Entrypoint] ‚úÖ PostgreSQL est√° listo. ---"


# --- PASO 2: Ejecutar Migraciones de la Base de Datos ---
echo "--- [Entrypoint] Ejecutando migraciones de la base de datos con Alembic... ---"
# `alembic upgrade head` aplica todas las migraciones pendientes desde la √∫ltima
# versi√≥n registrada en la base de datos hasta la √∫ltima versi√≥n en los archivos.
alembic upgrade head
echo "--- [Entrypoint] ‚úÖ Migraciones completadas. ---"


# --- PASO 3: Ejecutar el Comando Principal ---
echo "--- [Entrypoint] Iniciando la aplicaci√≥n principal del bot... ---"
# `exec "$@"` es una construcci√≥n de shell especial.
# 'exec' reemplaza el proceso actual del script con el nuevo comando, lo que es
# m√°s eficiente y permite que las se√±ales del sistema (como un 'docker stop')
# lleguen directamente a la aplicaci√≥n de Python.
# `"$@"` expande todos los argumentos que se pasaron al script. En nuestro caso,
# `docker-compose.yml` pasa `python run.py`, por lo que este comando se convierte en
# `exec python run.py`.
exec "$@"
# === FIN: entrypoint.sh ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
APScheduler==3.10.1
python-dateutil
psycopg2-binary==2.9.9
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
"""
Punto de Entrada Principal de la Aplicaci√≥n Runegram MUD.

Este script es el responsable de orquestar el arranque del bot. Sus tareas principales son:
1. Configurar el sistema de logging global para toda la aplicaci√≥n.
2. Definir y registrar las funciones `on_startup` y `on_shutdown` que se ejecutar√°n
   al iniciar y detener el bot, respectivamente.
3. Iniciar el "polling" de Aiogram, que es el bucle principal que escucha los
   mensajes de Telegram.

Para ejecutar la aplicaci√≥n, se llama a este script desde el `entrypoint.sh`
dentro del contenedor Docker.
"""

import logging
import asyncio
import sys
from aiogram import executor

from src.bot.dispatcher import dp
from src.services import world_loader_service, ticker_service, online_service
from src.db import async_session_factory

# Esta importaci√≥n es crucial para que los manejadores de mensajes se registren.
import src.handlers

async def on_startup(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se inicia con √©xito.
    Inicializa todos los sistemas principales del juego.
    """
    logging.info("Iniciando secuencia de arranque del bot...")

    try:
        # 1. Inicia el scheduler. Es importante que se inicie antes de que cualquier
        #    otro servicio intente a√±adir tareas.
        ticker_service.initialize_scheduler()

        # 2. Crea una sesi√≥n de base de datos para las tareas de inicializaci√≥n.
        async with async_session_factory() as session:
            # Sincroniza el mundo est√°tico (salas, salidas) desde los archivos de prototipos.
            await world_loader_service.sync_world_from_prototypes(session)

            # Carga y programa los tickers de los objetos que ya existen en la base de datos.
            await ticker_service.load_and_schedule_all_tickers(session)

        # 3. A√±ade el ticker global que se ejecuta peri√≥dicamente para comprobar
        #    el estado de inactividad (AFK) de los jugadores.
        ticker_service.scheduler.add_job(
            online_service.check_for_newly_afk_players,
            'interval',
            seconds=60,
            id="global_afk_check",
            replace_existing=True
        )
        logging.info("Ticker global para chequeo de AFK a√±adido.")

        logging.info("‚úÖ Secuencia de arranque finalizada. El bot est√° en l√≠nea.")

    except Exception:
        # Si algo falla catastr√≥ficamente durante el arranque, lo registramos
        # y detenemos la aplicaci√≥n para evitar un estado inconsistente.
        logging.exception("‚ùå Error fatal durante la secuencia de arranque. El bot se detendr√°.")
        # Obtenemos el bucle de eventos actual y lo detenemos.
        loop = asyncio.get_running_loop()
        loop.stop()


async def on_shutdown(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se detiene.
    Se asegura de que los servicios se apaguen de forma limpia.
    """
    logging.warning("Iniciando secuencia de apagado del bot...")
    if ticker_service.scheduler.running:
        ticker_service.scheduler.shutdown()
        logging.info("Scheduler detenido limpiamente.")
    logging.warning("Bot detenido.")


def main():
    """
    Configura el logging principal y arranca el bot.
    """
    # Configuraci√≥n de logging para que todos los mensajes (INFO, WARNING, ERROR, etc.)
    # se muestren en la consola del contenedor Docker con un formato claro.
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s [%(levelname)s] - %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # Inicia el bucle de Aiogram que escucha los mensajes de Telegram.
    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)


if __name__ == "__main__":
    main()
# === FIN: run.py ===


# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACI√ìN DEL PATH ---
# A√±ade el directorio ra√≠z del proyecto al sys.path para que Python
# pueda encontrar nuestros m√≥dulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACI√ìN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneraci√≥n
# y la configuraci√≥n (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---
# Aqu√≠ sobrescribimos la URL de la base de datos que est√° en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuraci√≥n de la aplicaci√≥n.
# Esto centraliza la configuraci√≥n y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Funci√≥n auxiliar que Alembic ejecutar√° de forma s√≠ncrona
    una vez que la conexi√≥n as√≠ncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor as√≠ncrono
    # a partir de la URL de nuestra configuraci√≥n.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma as√≠ncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""A√±adir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser m√°s expl√≠citos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # Nota: La columna 'exits' de tipo JSONB ser√° eliminada por una migraci√≥n posterior,
        # as√≠ que la dejamos aqu√≠ por ahora para mantener la consistencia hist√≥rica.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # A√±adimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Rellenamos las filas existentes con un ID de sala por defecto (1).
    # Esto es necesario para que la siguiente l√≠nea (nullable=False) no falle en bases de datos existentes.
    # El `create_character` service y el `world_loader` aseguran que la sala con ID 1 (limbo) exista.
    op.execute('UPDATE characters SET room_id = 1 WHERE room_id IS NULL')

    # Ahora s√≠, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final.
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""A√±adir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""A√±adir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/abe6da21ae81_a√±adir_columna_de_estado_a_las_cuentas.py ===
"""A√±adir columna de estado a las cuentas

Revision ID: abe6da21ae81
Revises: f17a871c68a1
Create Date: <LA FECHA SE GENERA AUTOM√ÅTICamente>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'abe6da21ae81'
down_revision = 'f17a871c68a1'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('accounts', sa.Column('status', sa.String(length=20), server_default='ACTIVE', nullable=False))
    # NOTA: Se han eliminado las l√≠neas autogeneradas que intentaban
    # borrar la tabla 'apscheduler_jobs', ya que esa tabla es gestionada
    # por otra migraci√≥n y no por los modelos de la aplicaci√≥n.
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('accounts', 'status')
    # NOTA: Se han eliminado las l√≠neas autogeneradas que intentaban
    # recrear la tabla 'apscheduler_jobs' en el downgrade.
    # ### end Alembic commands ###
# === FIN: alembic/versions/abe6da21ae81_a√±adir_columna_de_estado_a_las_cuentas.py ===


# === INICIO: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===
# alembic/script.py.mako

"""A√±adir key a las salas para prototipos

Revision ID: cdb486941d55
Revises: 57531370cbd7
Create Date: 2025-09-30 12:53:43.463923+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cdb486941d55'
down_revision = '57531370cbd7'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('key', sa.String(length=50), nullable=True))
    op.create_index(op.f('ix_rooms_key'), 'rooms', ['key'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_rooms_key'), table_name='rooms')
    op.drop_column('rooms', 'key')
    # ### end Alembic commands ###
# === FIN: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===


# === INICIO: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===
"""Crear tabla para apscheduler jobs

Revision ID: db2dac1704aa
Revises: cdb486941d55
Create Date: <LA FECHA SE GENERA AUTOM√ÅTICAMENTE>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db2dac1704aa'
down_revision = 'cdb486941d55'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Crea la tabla 'apscheduler_jobs' con el esquema exacto que espera
    la librer√≠a APScheduler para su SQLAlchemyJobStore.
    """
    op.create_table(
        'apscheduler_jobs',
        sa.Column('id', sa.Unicode(191), primary_key=True),
        sa.Column('next_run_time', sa.Float(25), index=True),
        sa.Column('job_state', sa.LargeBinary, nullable=False)
    )


def downgrade() -> None:
    """
    Elimina la tabla 'apscheduler_jobs' si se revierte la migraci√≥n.
    """
    op.drop_table('apscheduler_jobs')
# === FIN: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===


# === INICIO: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===
"""Crear tabla de configuraciones de personaje

Revision ID: f17a871c68a1
Revises: db2dac1704aa
Create Date: 2025-09-30 14:49:51.717892+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'f17a871c68a1'
down_revision = 'db2dac1704aa'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('character_settings',
    sa.Column('character_id', sa.BigInteger(), nullable=False),
    sa.Column('active_channels', postgresql.JSONB(astext_type=sa.Text()), server_default='{}', nullable=False),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.PrimaryKeyConstraint('character_id')
    )
    # --- Las l√≠neas problem√°ticas han sido eliminadas de aqu√≠ ---
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('character_settings')
    # --- Las l√≠neas problem√°ticas han sido eliminadas de aqu√≠ ---
    # ### end Alembic commands ###
# === FIN: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    accounts_table = op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

    # --- INICIO DE LA SECCI√ìN DE SEEDING ---
    # Aqu√≠ insertamos la cuenta del administrador despu√©s de crear la tabla.
    # Usamos op.bulk_insert para a√±adir datos de forma segura dentro de una migraci√≥n.
    op.bulk_insert(accounts_table,
        [
            {'telegram_id': 1648877346, 'role': 'ADMINISTRADOR'},
        ]
    )
    # --- FIN DE LA SECCI√ìN DE SEEDING ---

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # --- SECCI√ìN DE SEEDING (INVERSA) ---
    # Si hacemos downgrade, tambi√©n eliminamos los datos que a√±adimos.
    op.execute("DELETE FROM accounts WHERE telegram_id = 1648877346")
    # --- FIN DE LA SECCI√ìN DE SEEDING ---

    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===


# === INICIO: commands/__init__.py ===
# === FIN: commands/__init__.py ===


# === INICIO: commands/command.py ===
# commands/command.py
"""
M√≥dulo que define la Clase Base para todos los Comandos.

Este archivo contiene la clase `Command`, que act√∫a como una plantilla o "contrato"
para todos los comandos del juego. Cada comando, ya sea de jugador o de administrador,
debe heredar de esta clase.

Esto asegura que todos los comandos tengan una estructura consistente y puedan ser
manejados de manera uniforme por el dispatcher principal.
"""

from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character

class Command:
    """
    Clase base abstracta para todos los comandos del juego.

    Atributos:
        names (list[str]): Una lista de alias que pueden invocar este comando.
                           El primer nombre de la lista se considera el principal.
        lock (str): Un string de permisos que el `permission_service` evaluar√°
                    para determinar si el personaje puede ejecutar el comando.
        description (str): Una breve descripci√≥n del prop√≥sito del comando, utilizada
                           para actualizar la lista de comandos en el cliente de Telegram.
    """
    lock: str = ""
    description: str = "Un comando sin descripci√≥n."

    def __init__(self, names: list[str] = None, description: str = None):
        """
        Inicializador que permite la creaci√≥n de instancias de comandos
        con alias y descripciones din√°micas.

        Esto es especialmente √∫til para crear m√∫ltiples comandos a partir de una
        sola clase, como los comandos de movimiento (`/norte`, `/sur`, etc.).

        Args:
            names (list[str], optional): La lista de alias para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
            description (str, optional): La descripci√≥n para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
        """
        if names:
            self.names = names
        elif not hasattr(self, 'names'):
            self.names = []

        if description:
            self.description = description
        elif not hasattr(self, 'description'):
            # Asegura que siempre haya una descripci√≥n por defecto.
            self.description = "Un comando sin descripci√≥n."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """
        El m√©todo principal que se ejecuta cuando se llama al comando.

        Este m√©todo debe ser sobrescrito por cada clase de comando hija.

        Args:
            character (Character): El objeto del personaje que ejecuta el comando,
                                   precargado con todas sus relaciones.
            session (AsyncSession): La sesi√≥n de base de datos activa para esta
                                    interacci√≥n.
            message (types.Message): El objeto de mensaje de Aiogram que contiene
                                     el texto original, el ID del chat, etc.
            args (list[str]): Una lista de los argumentos proporcionados por el
                              usuario despu√©s del nombre del comando.
        """
        # Este m√©todo est√° pensado para ser sobrescrito. Si una subclase no lo
        # implementa, lanzar un NotImplementedError es una buena pr√°ctica para
        # detectar errores durante el desarrollo.
        raise NotImplementedError
# === FIN: commands/command.py ===


# === INICIO: commands/admin/__init__.py ===

from . import building
from . import movement
from . import info
# === FIN: commands/admin/__init__.py ===


# === INICIO: commands/admin/building.py ===
# commands/admin/building.py
"""
M√≥dulo de Comandos Administrativos para la Generaci√≥n de Entidades.

Este archivo contiene los comandos que permiten a los administradores "generar"
o "invocar" (`spawn`) entidades en el mundo a partir de sus prototipos
definidos en `game_data`.

Estos comandos no se usan para construir el mundo est√°tico (eso lo hace el
`world_loader_service`), sino para a√±adir contenido din√°mico durante el juego,
como objetos para un evento o PNJ para una misi√≥n.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service
from game_data.item_prototypes import ITEM_PROTOTYPES

class CmdGenerarObjeto(Command):
    """
    Comando para un administrador para crear una instancia de un objeto
    a partir de un prototipo y colocarla en la sala actual.
    """
    names = ["generarobjeto", "genobj"]
    lock = "rol(ADMINISTRADOR)"
    description = "Genera un objeto en la sala a partir de su clave de prototipo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # Validaci√≥n de entrada
        if not args:
            await message.answer("Uso: /generarobjeto [key_del_prototipo]")
            return

        item_key = args[0].lower()

        try:
            # Llama al servicio para crear la instancia del objeto en la base de datos.
            item = await item_service.spawn_item_in_room(session, character.room_id, item_key)

            # Obtenemos el nombre "bonito" del prototipo para el mensaje de confirmaci√≥n.
            item_name = ITEM_PROTOTYPES.get(item.key, {}).get("name", "un objeto desconocido")

            await message.answer(f"‚úÖ Objeto '{item_name}' generado en la sala actual.")

        except ValueError as e:
            # Este error se lanza desde `item_service` si la `item_key` no existe.
            await message.answer(f"‚ùå Error: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creaci√≥n.
            await message.answer("‚ùå Ocurri√≥ un error inesperado al generar el objeto.")
            logging.exception(f"Fallo al ejecutar /generarobjeto con la clave '{item_key}'")

# Exportamos la lista de comandos de este m√≥dulo.
# En el futuro, aqu√≠ se podr√≠an a√±adir comandos como /generarnpc.
SPAWN_COMMANDS = [
    CmdGenerarObjeto(),
]
# === FIN: commands/admin/building.py ===


# === INICIO: commands/admin/info.py ===
# commands/admin/info.py
"""
M√≥dulo de Comandos Administrativos de Informaci√≥n.

Este archivo contiene comandos dise√±ados para que los administradores puedan
consultar el estado interno del juego. Son herramientas de solo lectura
que ayudan a supervisar, depurar y obtener una visi√≥n general del mundo
sin modificarlo.

Ejemplos futuros podr√≠an incluir: /donde [jugador], /infoobjeto [id], etc.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character, Room

class CmdListarSalas(Command):
    """
    Comando que muestra una lista de todas las salas existentes en el mundo,
    incluyendo su ID, su clave de prototipo y su nombre.
    """
    names = ["listarsalas", "lsalas"]
    lock = "rol(ADMINISTRADOR)"
    description = "Muestra ID, Clave y Nombre de todas las salas del mundo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """Ejecuta la consulta y formatea la lista de salas."""
        try:
            # 1. Realizar la consulta a la base de datos para obtener todas las salas.
            # Se ordenan por ID para una visualizaci√≥n consistente.
            result = await session.execute(select(Room).order_by(Room.id))
            all_rooms = result.scalars().all()

            if not all_rooms:
                await message.answer("No se encontraron salas en la base de datos.")
                return

            # 2. Construir el mensaje de respuesta l√≠nea por l√≠nea.
            response_lines = ["<b>Lista de Salas del Mundo:</b>"]
            for room in all_rooms:
                # El formato con `<` alinea el texto a la izquierda, rellenando con espacios.
                # `room.id:<4}` -> ID, alineado a la izquierda, 4 caracteres de ancho.
                # `room.key:<20}` -> Key, alineado a la izquierda, 20 caracteres de ancho.
                response_lines.append(f"ID: {room.id:<4} | Key: {room.key:<20} | Nombre: {room.name}")

            body = "\n".join(response_lines)

            # 3. Envolver el cuerpo completo en una etiqueta <pre> para asegurar
            #    un formato de monoespaciado y una alineaci√≥n perfecta de las columnas.
            response_text = f"<pre>{body}</pre>"

            await message.answer(response_text, parse_mode="HTML")

        except Exception:
            # Captura cualquier error inesperado durante la consulta a la base de datos.
            await message.answer("‚ùå Ocurri√≥ un error al intentar listar las salas.")
            logging.exception("Fallo al ejecutar /listarsalas")

# Exportamos la lista de comandos de este m√≥dulo.
INFO_COMMANDS = [
    CmdListarSalas(),
]
# === FIN: commands/admin/info.py ===


# === INICIO: commands/admin/movement.py ===
# commands/admin/movement.py
"""
M√≥dulo de Comandos Administrativos para el Movimiento.

Este archivo contiene comandos que otorgan a los administradores capacidades
de movimiento especiales, que no est√°n sujetas a las reglas normales del juego
(como las salidas definidas en una sala).

Son herramientas esenciales para la construcci√≥n, supervisi√≥n y depuraci√≥n del mundo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service
from src.utils.presenters import show_current_room

class CmdTeleport(Command):
    """
    Comando para teletransportar al administrador a cualquier sala del juego
    especificando su ID num√©rico.
    """
    names = ["teleport", "tp"]
    lock = "rol(ADMINISTRADOR)"
    description = "Teletransp√≥rtate a cualquier sala usando su ID."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario.
        if not args:
            await message.answer("Uso: /teleport [ID_sala]")
            return

        try:
            # Intentamos convertir el primer argumento a un n√∫mero entero.
            to_room_id = int(args[0])
        except (ValueError, IndexError):
            # Falla si no hay argumentos o si el argumento no es un n√∫mero.
            await message.answer("El ID de la sala debe ser un n√∫mero v√°lido.")
            return

        try:
            # 2. Llamar al servicio que contiene la l√≥gica de negocio.
            await player_service.teleport_character(session, character.id, to_room_id)

            # 3. Notificar al administrador del √©xito y mostrar la nueva ubicaci√≥n.
            await message.answer(f"üöÄ Teletransportado a la sala {to_room_id}.")
            await show_current_room(message)

        except Exception as e:
            # Capturamos cualquier error que pueda ocurrir durante el teletransporte,
            # como un ID de sala que no existe (manejado por `player_service`).
            await message.answer(f"‚ùå Error al teletransportar: {e}")
            logging.warning(f"Fallo al ejecutar /teleport a la sala {args[0]}: {e}")

# Exportamos la lista de comandos de este m√≥dulo.
ADMIN_MOVEMENT_COMMANDS = [
    CmdTeleport(),
]
# === FIN: commands/admin/movement.py ===


# === INICIO: commands/player/__init__.py ===
from . import general
from . import character
from . import interaction
from . import movement
from . import channels
# === FIN: commands/player/__init__.py ===


# === INICIO: commands/player/channels.py ===
# commands/player/channels.py
"""
M√≥dulo de Comandos para la Interacci√≥n con Canales de Chat.

Este archivo contiene los comandos que permiten a los jugadores gestionar
sus suscripciones a canales y comunicarse a trav√©s de ellos.

Incluye:
- Comandos de gesti√≥n (ej: /canales, /canal).
- Un comando espec√≠fico por cada canal de tipo 'CHAT' (ej: /novato).
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdChannel(Command):
    """
    Comando para que un jugador active o desactive un canal.
    """
    names = ["canal"]
    description = "Activa o desactiva un canal. Uso: /canal [activar|desactivar] [nombre]."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario (acci√≥n y nombre del canal).
        if not args or len(args) < 2 or args[0].lower() not in ["activar", "desactivar"]:
            await message.answer("Uso: /canal [activar|desactivar] [nombre_canal]")
            return

        action = args[0].lower()
        channel_key = args[1].lower()

        try:
            # 2. Llamar al servicio para persistir el cambio en la configuraci√≥n del personaje.
            await channel_service.set_channel_status(session, character, channel_key, activate=(action == "activar"))
            await message.answer(f"‚úÖ Has {action}do el canal '{channel_key}'.")
        except ValueError as e:
            # Captura el error si el `channel_key` no existe.
            await message.answer(f"‚ùå Error: {e}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al modificar el estado del canal.")
            logging.exception(f"Fallo al ejecutar /canal para {character.name}")

class CmdChannels(Command):
    """
    Comando para listar todos los canales disponibles y el estado de suscripci√≥n del jugador.
    """
    names = ["canales"]
    description = "Muestra los canales disponibles y su estado (activado/desactivado)."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # 1. Obtener la configuraci√≥n de canales del jugador.
            settings = await channel_service.get_or_create_settings(session, character)
            user_channels = settings.active_channels.get("active_channels", [])

            # 2. Construir la lista formateada para el mensaje.
            response = ["<b>Estado de tus Canales:</b>"]
            for key, proto in CHANNEL_PROTOTYPES.items():
                status = "‚úÖ Activado" if key in user_channels else "‚ùå Desactivado"
                response.append(f"- <b>{proto['name']}</b> ({key}): {status}\n  <i>{proto['description']}</i>")

            await message.answer("\n".join(response), parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al listar los canales.")
            logging.exception(f"Fallo al ejecutar /canales para {character.name}")


class CmdNovato(Command):
    """
    Comando para enviar un mensaje al canal 'novato'.
    """
    names = ["novato"]
    lock = ""
    description = "Env√≠a un mensaje por el canal de ayuda para novatos."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("Uso: /novato [mensaje]")
                return

            # 1. Verificar si el jugador tiene el canal activado.
            settings = await channel_service.get_or_create_settings(session, character)
            if not await channel_service.is_channel_active(settings, "novato"):
                await message.answer("Tienes el canal 'novato' desactivado. Act√≠valo con:\n/canal activar novato")
                return

            # 2. Formatear y transmitir el mensaje a trav√©s del servicio.
            channel_message = f"[{character.name}] {' '.join(args)}"
            await channel_service.broadcast_to_channel(session, "novato", channel_message, exclude_character_id=character.id)

            # 3. Enviar una confirmaci√≥n al propio jugador para que vea su mensaje.
            await message.answer(f"üì¢ <b>Novato:</b> {channel_message}", parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al enviar tu mensaje al canal.")
            logging.exception(f"Fallo al ejecutar /novato para {character.name}")

# Exportamos la lista de comandos de este m√≥dulo.
CHANNEL_COMMANDS = [
    CmdChannel(),
    CmdChannels(),
    CmdNovato(),
]
# === FIN: commands/player/channels.py ===


# === INICIO: commands/player/character.py ===
# commands/player/character.py
"""
M√≥dulo de Comandos para la Gesti√≥n del Personaje.

Este archivo contiene los comandos que permiten a los jugadores gestionar
el ciclo de vida de su personaje en el juego.

El comando principal aqu√≠ es `/crearpersonaje`, que es el primer comando que
un nuevo jugador debe usar para entrar al mundo de Runegram.

Futuros comandos como `/borrarpersonaje` o `/descripcion` tambi√©n pertenecer√≠an
a este m√≥dulo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service

class CmdCreateCharacter(Command):
    """
    Comando para que un nuevo usuario cree su personaje.
    """
    names = ["crearpersonaje"]
    description = "Crea tu personaje para empezar a jugar."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """
        Gestiona la l√≥gica de creaci√≥n de un nuevo personaje.
        """
        # 1. Comprobar si el jugador ya tiene un personaje.
        # El objeto 'character' solo es None si la cuenta no tiene un personaje asociado.
        if character:
            await message.answer("Ya tienes un personaje.")
            return

        # 2. Validar el nombre proporcionado por el usuario.
        character_name = " ".join(args)
        if not character_name or len(character_name) > 50:
            await message.answer("Por favor, proporciona un nombre v√°lido (m√°x 50 caracteres). Uso: /crearpersonaje [nombre]")
            return

        try:
            # 3. Llamar al servicio que contiene la l√≥gica de negocio para la creaci√≥n.
            new_char = await player_service.create_character(session, message.from_user.id, character_name)

            # 4. Enviar un mensaje de √©xito al jugador.
            await message.answer(
                f"¬°Tu personaje, {new_char.name}, ha sido creado con √©xito!\n"
                "Ahora est√°s listo para explorar el mundo de Runegram. ¬°Env√≠a /start para comenzar!"
            )
        except ValueError as e:
            # Captura errores de negocio espec√≠ficos lanzados por `player_service`,
            # como "El nombre ya est√° en uso".
            await message.answer(f"No se pudo crear el personaje: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creaci√≥n.
            # Gracias al `logging.exception`, veremos el traceback completo en los logs
            # del contenedor, lo que es vital para depurar errores sutiles de la base de datos.
            await message.answer("Ocurri√≥ un error inesperado al crear tu personaje.")
            logging.exception(f"Error finalizando la creaci√≥n del personaje para {message.from_user.id}")

# Exportamos la lista de comandos de este m√≥dulo.
CHARACTER_COMMANDS = [
    CmdCreateCharacter(),
]
# === FIN: commands/player/character.py ===


# === INICIO: commands/player/general.py ===
# commands/player/general.py
"""
M√≥dulo de Comandos Generales del Jugador.

Este archivo agrupa los comandos m√°s b√°sicos y fundamentales que un jugador
utiliza para interactuar con el mundo y obtener informaci√≥n esencial sobre su
entorno y su personaje.

Estos comandos est√°n disponibles para todos los jugadores en todo momento.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.utils.presenters import show_current_room
from src.services import script_service, online_service

class CmdLook(Command):
    """
    Comando para observar el entorno actual (la sala) o un objeto o
    personaje espec√≠fico dentro de ella.
    """
    names = ["mirar", "m", "l"]
    lock = ""
    description = "Observa tu entorno o un objeto/personaje espec√≠fico."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # Si no se proporcionan argumentos, el jugador mira la sala.
            if not args:
                await show_current_room(message)
                return

            target_name = " ".join(args).lower()
            found_target = None

            # 1. Buscar en los objetos de la sala.
            if character.room.items:
                for item in character.room.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # 2. Si no se encontr√≥, buscar en el inventario del personaje.
            if not found_target and character.items:
                for item in character.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # Futuro: 3. Buscar otros personajes en la sala.
            # Futuro: 4. Buscar NPCs en la sala.

            if not found_target:
                await message.answer("No ves eso por aqu√≠.")
                return

            # Mostramos la descripci√≥n del objeto encontrado.
            await message.answer(f"<pre>{found_target.get_description()}</pre>", parse_mode="HTML")

            # Finalmente, disparamos el evento on_look si el objeto tiene un script asociado.
            if "on_look" in found_target.prototype.get("scripts", {}):
                await script_service.execute_script(
                    script_string=found_target.prototype["scripts"]["on_look"],
                    session=session,
                    character=character,
                    target=found_target
                )
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar mirar.")
            logging.exception(f"Fallo al ejecutar /mirar para {character.name}")

class CmdSay(Command):
    """
    Comando para que el personaje hable a otros en la misma sala.
    """
    names = ["decir", "'"]
    lock = ""
    description = "Habla con las personas que est√°n en tu misma sala."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("¬øQu√© quieres decir?")
            return

        # Futuro: Este mensaje deber√≠a ser transmitido a otros jugadores en la sala.
        say_text = " ".join(args)
        await message.answer(f"Dices: {say_text}")

class CmdInventory(Command):
    """
    Comando para mostrar al jugador los objetos que lleva en su inventario.
    """
    names = ["inventario", "inv", "i"]
    lock = ""
    description = "Muestra los objetos que llevas en tu inventario."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            inventory = character.items
            if not inventory:
                response = "No llevas nada."
            else:
                items_list = [f" - {item.get_name()}" for item in inventory]
                items_str = "\n".join(items_list)
                response = f"<b>Llevas lo siguiente:</b>\n{items_str}"

            await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al mostrar tu inventario.")
            logging.exception(f"Fallo al ejecutar /inventario para {character.name}")

class CmdHelp(Command):
    """
    Comando para mostrar un mensaje de ayuda b√°sico con los comandos principales.
    """
    names = ["ayuda", "help"]
    lock = ""
    description = "Muestra una lista con los comandos b√°sicos del juego."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        help_text = (
            "<b>Comandos B√°sicos de Runegram</b>\n"
            "---------------------------------\n"
            "/mirar - Muestra la descripci√≥n de tu entorno.\n"
            "/inventario - Muestra los objetos que llevas.\n"
            "/decir [mensaje] - Hablas a la gente en tu misma sala.\n"
            "/coger [objeto] - Recoges un objeto del suelo.\n"
            "/dejar [objeto] - Dejas un objeto que llevas.\n"
            "/quien - Muestra qui√©n est√° conectado.\n"
            "/canales - Gestiona tus suscripciones a canales.\n\n"
            "Para moverte, usa /norte, /sur, etc."
        )
        await message.answer(f"<pre>{help_text}</pre>", parse_mode="HTML")

class CmdWho(Command):
    """
    Comando social que muestra una lista de todos los personajes que
    est√°n actualmente conectados al juego.
    """
    names = ["quien", "who"]
    lock = ""
    description = "Muestra una lista de los jugadores conectados."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            online_characters = await online_service.get_online_characters(session)

            # Si la lista est√° vac√≠a o solo contiene al jugador actual, se muestra
            # un mensaje indicando que est√° solo.
            if not online_characters or (len(online_characters) == 1 and online_characters[0].id == character.id):
                await message.answer("Eres la √∫nica alma aventurera en este mundo ahora mismo.")
                return

            response_lines = [f"<b>Hay {len(online_characters)} aventureros en Runegram:</b>"]
            # Ordenamos la lista alfab√©ticamente por nombre para una visualizaci√≥n clara.
            for char in sorted(online_characters, key=lambda c: c.name):
                response_lines.append(f"- {char.name}")

            response_text = "\n".join(response_lines)
            await message.answer(f"<pre>{response_text}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al obtener la lista de jugadores.")
            logging.exception(f"Fallo al ejecutar /quien para {character.name}")

# Exportamos la lista de comandos de este m√≥dulo.
GENERAL_COMMANDS = [
    CmdLook(),
    CmdSay(),
    CmdInventory(),
    CmdHelp(),
    CmdWho(),
]
# === FIN: commands/player/general.py ===


# === INICIO: commands/player/interaction.py ===
# commands/player/interaction.py
"""
M√≥dulo de Comandos de Interacci√≥n con Objetos.

Este archivo contiene los comandos que permiten al jugador manipular directamente
los objetos (`Items`) en el mundo del juego.

Incluye acciones fundamentales como coger objetos del entorno y dejar
objetos del inventario.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service, command_service, player_service

class CmdGet(Command):
    """
    Comando para que un jugador recoja un objeto del suelo en su sala actual
    y lo a√±ada a su inventario.
    """
    names = ["coger", "g"]
    lock = ""
    description = "Recoge un objeto del suelo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¬øQu√© quieres coger?")
                return

            item_name_to_get = " ".join(args).lower()
            item_to_get = None

            # Buscamos el objeto en la lista de items de la sala actual.
            for item in character.room.items:
                if item_name_to_get in item.get_name().lower():
                    item_to_get = item
                    break

            if not item_to_get:
                await message.answer("No ves eso por aqu√≠.")
                return

            # Llamamos al servicio para actualizar la ubicaci√≥n del objeto en la BD.
            await item_service.move_item_to_character(session, item_to_get.id, character.id)

            # Si el objeto que cogimos otorga un CommandSet, debemos actualizar la
            # lista de comandos del jugador en Telegram.
            if item_to_get.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has cogido: {item_to_get.get_name()}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar coger el objeto.")
            logging.exception(f"Fallo al ejecutar /coger para {character.name}")


class CmdDrop(Command):
    """
    Comando para que un jugador deje un objeto de su inventario en el suelo
    de su sala actual.
    """
    names = ["dejar", "d"]
    lock = ""
    description = "Deja un objeto de tu inventario en el suelo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¬øQu√© quieres dejar?")
                return

            item_name_to_drop = " ".join(args).lower()
            item_to_drop = None

            # Buscamos el objeto en el inventario del personaje.
            for item in character.items:
                if item_name_to_drop in item.get_name().lower():
                    item_to_drop = item
                    break

            if not item_to_drop:
                await message.answer("No llevas eso.")
                return

            # Llamamos al servicio para actualizar la ubicaci√≥n del objeto en la BD.
            await item_service.move_item_to_room(session, item_to_drop.id, character.room_id)

            # Si el objeto que dejamos otorgaba un CommandSet, debemos actualizar la
            # lista de comandos del jugador en Telegram.
            if item_to_drop.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has dejado: {item_to_drop.get_name()}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar dejar el objeto.")
            logging.exception(f"Fallo al ejecutar /dejar para {character.name}")


# Exportamos la lista de comandos de este m√≥dulo.
INTERACTION_COMMANDS = [
    CmdGet(),
    CmdDrop(),
]
# === FIN: commands/player/interaction.py ===


# === INICIO: commands/player/movement.py ===
# commands/player/movement.py
"""
M√≥dulo de Comandos de Movimiento del Jugador.

Este archivo centraliza toda la l√≥gica relacionada con el desplazamiento del
personaje por el mundo del juego.

Utiliza una √∫nica clase gen√©rica, `CmdMove`, que se instancia para cada una de
las direcciones posibles (norte, sur, etc.), cada una con sus propios alias.
Esto evita la duplicaci√≥n de c√≥digo y mantiene la l√≥gica de movimiento en un
solo lugar.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service
from src.utils.presenters import show_current_room

class CmdMove(Command):
    """
    Comando gen√©rico que gestiona el movimiento del jugador en una direcci√≥n.
    La direcci√≥n espec√≠fica se determina por el nombre principal del comando
    (el primer elemento en la lista `names`).
    """
    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            # 1. Determinar la direcci√≥n bas√°ndose en el comando invocado.
            #    Por ejemplo, si se usa `/n`, self.names[0] ser√° "norte".
            direction = self.names[0]

            # 2. Buscar si existe una salida v√°lida en esa direcci√≥n desde la sala actual.
            target_exit = next(
                (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == direction),
                None
            )

            if not target_exit:
                await message.answer("No puedes ir en esa direcci√≥n.")
                return

            # Futuro: Aqu√≠ se integrar√° la l√≥gica de `permission_service` para
            # comprobar si la salida (`target_exit`) tiene un `lock`.

            # 3. Mover al personaje a la nueva sala.
            await player_service.teleport_character(session, character.id, target_exit.to_room_id)

            # 4. Actualizar la lista de comandos del jugador en Telegram.
            #    Esto es crucial porque la nueva sala podr√≠a otorgar o quitar CommandSets.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            await command_service.update_telegram_commands(refreshed_character)

            # 5. Mostrar al jugador la descripci√≥n de su nueva ubicaci√≥n.
            await show_current_room(message)

        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar moverte.")
            logging.exception(f"Fallo al ejecutar /mover ({self.names[0]}) para {character.name}")

# --- Creaci√≥n del Command Set con descripciones ---
# Se crea una instancia de `CmdMove` para cada direcci√≥n, asignando sus alias
# y una descripci√≥n clara para la lista de comandos de Telegram.
MOVEMENT_COMMANDS = [
    CmdMove(names=["norte", "n"], description="Moverse hacia el norte."),
    CmdMove(names=["sur", "s"], description="Moverse hacia el sur."),
    CmdMove(names=["este", "e"], description="Moverse hacia el este."),
    CmdMove(names=["oeste", "o"], description="Moverse hacia el oeste."),
    CmdMove(names=["arriba", "ar"], description="Moverse hacia arriba."),
    CmdMove(names=["abajo", "ab"], description="Moverse hacia abajo."),
    CmdMove(names=["noreste", "ne"], description="Moverse hacia el noreste."),
    CmdMove(names=["noroeste", "no"], description="Moverse hacia el noroeste."),
    CmdMove(names=["sureste", "se"], description="Moverse hacia el sureste."),
    CmdMove(names=["suroeste", "so"], description="Moverse hacia el suroeste."),
]
# === FIN: commands/player/movement.py ===


# === INICIO: game_data/__init__.py ===
# === FIN: game_data/__init__.py ===


# === INICIO: game_data/channel_prototypes.py ===
# game_data/channel_prototypes.py
"""
Definici√≥n de Prototipos de Canales de Chat.

Este archivo act√∫a como la "Fuente de la Verdad" para todos los canales de
comunicaci√≥n globales disponibles en el juego. El `channel_service` utiliza
esta informaci√≥n para gestionar las suscripciones y formatear los mensajes.

A√±adir un nuevo canal al juego es tan simple como a√±adir una nueva entrada
a este diccionario.

Estructura de un Prototipo de Canal:
- <clave_unica>: (ej: "novato")
    - "name": (str) El nombre del canal que ven los jugadores.
    - "icon": (str) Un icono emoji que precede a los mensajes del canal.
    - "description": (str) Una breve explicaci√≥n que se muestra en el comando /canales.
    - "type": (str) Define el comportamiento del canal:
        - "CHAT": Los jugadores pueden enviar mensajes a trav√©s de un comando (ej: /novato).
        - "BROADCAST": Solo el sistema puede enviar mensajes (ej: anuncios).
    - "default_on": (bool) Si es `True`, los nuevos personajes se suscriben
                    autom√°ticamente a este canal al ser creados.
"""

CHANNEL_PROTOTYPES = {
    # Canal para que los nuevos jugadores puedan hacer preguntas.
    "novato": {
        "name": "Novato",
        "icon": "üì¢",
        "description": "Un canal para que los nuevos aventureros pidan ayuda.",
        "type": "CHAT",
        "default_on": True,
    },

    # Canal para notificaciones autom√°ticas del juego.
    "sistema": {
        "name": "Sistema",
        "icon": "‚öôÔ∏è",
        "description": "Anuncios autom√°ticos del juego, como estados de actividad.",
        "type": "BROADCAST",
        "default_on": True,
    },

    # --- Futuros canales podr√≠an ir aqu√≠ ---
    # "comercio": {
    #     "name": "Comercio",
    #     "icon": "üí∞",
    #     "description": "Para comprar y vender objetos con otros jugadores.",
    #     "type": "CHAT",
    #     "default_on": True,
    # },
    # "anuncios": {
    #     "name": "Anuncios",
    #     "icon": "üìú",
    #     "description": "Noticias y eventos importantes del mundo.",
    #     "type": "BROADCAST",
    #     "default_on": True,
    # }
}
# === FIN: game_data/channel_prototypes.py ===


# === INICIO: game_data/item_prototypes.py ===
# game_data/item_prototypes.py
"""
Definici√≥n de Prototipos de Objetos (Items).

Este archivo es el cat√°logo central de todos los objetos que pueden existir
en el mundo de Runegram. Sigue un sistema de prototipos, lo que significa que
este archivo define las "plantillas" o "planos" de los objetos, mientras que
la base de datos solo almacena las "instancias" individuales de esos objetos
(su ubicaci√≥n, si tienen un nombre personalizado, etc.).

Esta separaci√≥n es clave para la filosof√≠a de dise√±o del motor, permitiendo
a√±adir cientos de objetos nuevos sin modificar el c√≥digo fuente ni la
estructura de la base de datos.

Estructura de un Prototipo de Objeto:
- <clave_unica>: (ej: "espada_viviente")
    - "name": (str) El nombre que ven los jugadores (ej: "una espada viviente").
    - "keywords": (list[str]) Palabras clave para que los jugadores puedan interactuar
                    con el objeto (ej: /mirar espada).
    - "description": (str) El texto que se muestra al mirar el objeto.
    - "scripts": (dict, opcional) Define scripts reactivos a eventos.
        - "on_look": (str) El script a ejecutar cuando un jugador mira el objeto.
    - "tickers": (list[dict], opcional) Define scripts proactivos que se ejecutan
                 peri√≥dicamente.
        - "schedule": (str) El horario (cron o intervalo).
        - "script": (str) El script a ejecutar.
        - "category": (str) La categor√≠a del ticker (ej: "ambient").
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que este
                             objeto otorga al personaje que lo posea.
"""

ITEM_PROTOTYPES = {
    # Un objeto m√°gico que susurra secretos peri√≥dicamente.
    "espada_viviente": {
        "name": "una espada viviente",
        "description": "La hoja de acero parece retorcerse y susurrarte secretos.",
        "keywords": ["espada", "viviente"],
        "scripts": {
            # Cuando se mira, emite un brillo rojo.
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        },
        "tickers": [
            {
                # Cada 2 minutos, ejecuta el script de susurrar.
                "schedule": "*/2 * * * *",
                "script": "script_espada_susurra_secreto",
                # Se categoriza como "ambient" para no molestar a jugadores inactivos.
                "category": "ambient"
            }
        ]
    },

    # Un objeto decorativo con un ticker de intervalo.
    "corazon_sangrante": {
        "name": "un coraz√≥n sangrante",
        "description": "Late d√©bilmente y gotea un icor oscuro.",
        "keywords": ["corazon", "sangrante"],
        "tickers": [
            {
                # Cada 30 segundos, ejecuta un script (a√∫n por definir).
                "schedule": "interval:30",
                "script": "script_objeto_sangra_en_el_suelo",
                "category": "ambient"
            }
        ]
    },

    # --- Futuros objetos podr√≠an ir aqu√≠ ---
    # "ganzuas_maestras": {
    #     "name": "unas ganz√∫as maestras",
    #     "keywords": ["ganzuas", "herramientas"],
    #     "description": "Unas herramientas de precisi√≥n para el ladr√≥n experto.",
    #     # Este objeto otorga acceso al CommandSet "thievery" mientras se posea.
    #     "grants_command_sets": ["thievery"]
    # },
}
# === FIN: game_data/item_prototypes.py ===


# === INICIO: game_data/room_prototypes.py ===
# game_data/room_prototypes.py
"""
Definici√≥n de Prototipos de Salas (Rooms).

Este archivo es el "mapa maestro" del mundo de Runegram. Define todas las
salas est√°ticas, sus descripciones y, lo m√°s importante, c√≥mo se conectan
entre s√≠.

El `world_loader_service` lee este archivo al arrancar el bot para construir
o sincronizar el mundo en la base de datos.

Estructura de un Prototipo de Sala:
- <clave_unica>: (ej: "plaza_central") Un identificador √∫nico para la sala que
                 nunca debe cambiar. Se usa para las conexiones.
    - "name": (str) El nombre de la sala que ven los jugadores.
    - "description": (str) El texto principal que se muestra al entrar o mirar la sala.
    - "exits": (dict, opcional) Define las salidas desde esta sala.
        - "<direccion>": (str) La clave √∫nica de la sala de destino.
          (ej: "norte": "camino_del_bosque"). El `world_loader_service` se
          encarga de crear autom√°ticamente la salida de vuelta (sur).
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que esta
                             sala otorga a cualquier personaje que se encuentre en ella.
"""

ROOM_PROTOTYPES = {
    # La sala de inicio, donde aparecen todos los nuevos personajes.
    "limbo": {
        "name": "El Limbo",
        "description": "Te encuentras en una habitaci√≥n vac√≠a, suspendida en la nada. Es el comienzo de tu aventura y un refugio seguro.",
        "exits": {
            # "direcci√≥n": "clave_de_la_sala_destino"
            "norte": "plaza_central"
        }
    },

    # Un nexo central desde el que parten varios caminos.
    "plaza_central": {
        "name": "Plaza Central de Runegard",
        "description": "Est√°s en el coraz√≥n de la ciudad. El bullicio de mercaderes y aventureros llena el aire. Varios caminos parten desde aqu√≠.",
        "exits": {
            # El cargador crear√° autom√°ticamente la salida 'sur' de vuelta al 'limbo'.
            "este": "calle_mercaderes"
        }
    },

    # Una sala tem√°tica.
    "calle_mercaderes": {
        "name": "Calle de los Mercaderes",
        "description": "Decenas de puestos se alinean en esta calle, ofreciendo todo tipo de mercanc√≠as ex√≥ticas.",
        "exits": {
            # El cargador crear√° autom√°ticamente la salida 'oeste' de vuelta a 'plaza_central'.
        }
    },

    # --- Futuras salas podr√≠an ir aqu√≠ ---
    # "forja_del_enano": {
    #     "name": "La Forja del Enano Errante",
    #     "description": "El calor del fuego y el r√≠tmico martilleo sobre el yunque llenan esta sala.",
    #     "exits": {
    #         "sur": "plaza_central"
    #     },
    #     # Cualquier jugador en esta sala obtiene acceso a los comandos de herrer√≠a.
    #     "grants_command_sets": ["smithing"]
    # }
}
# === FIN: game_data/room_prototypes.py ===


# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
REM ##################################################################
REM #                                                                #
REM #           SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM              #
REM #                                                                #
REM #  Este script automatiza el proceso de limpiar por completo el  #
REM #  entorno de desarrollo de Docker y reconstruirlo desde cero.   #
REM #                                                                #
REM #  Es la herramienta principal para asegurar un estado limpio    #
REM #  despu√©s de cambios en dependencias, migraciones o si algo     #
REM #  se ha corrompido.                                             #
REM #                                                                #
REM ##################################################################

TITLE Reinicio Completo de Runegram

CLS
ECHO.
ECHO  ##################################################################
ECHO  #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO  ##################################################################
ECHO.
ECHO  ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES DE FORMA DESTRUCTIVA:
ECHO.
ECHO    1. Detendra todos los contenedores de la aplicacion.
ECHO    2. Eliminara los contenedores detenidos.
ECHO    3. [!] Eliminara el VOLUMEN de la base de datos, borrando TODOS los datos.
ECHO    4. Reconstruira la imagen Docker de la aplicacion desde cero.
ECHO    5. Levantara todos los servicios en segundo plano.
ECHO.
ECHO  Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.
ECHO  Presiona cualquier tecla para continuar o cierra esta ventana para cancelar.
PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen de datos... ---
ECHO.
REM `docker-compose down` detiene y elimina los contenedores.
REM La bandera `-v` (o `--volumes`) es crucial, ya que elimina los vol√∫menes
REM nombrados asociados, como `postgres_data`, asegurando un borrado total.
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo la imagen y levantando servicios... ---
ECHO.
REM `docker-compose up` levanta los servicios.
REM La bandera `--build` fuerza la reconstrucci√≥n de la imagen 'bot' desde el Dockerfile.
REM La bandera `-d` (o `--detach`) ejecuta los contenedores en segundo plano.
docker-compose up --build -d

ECHO.
ECHO  ##################################################################
ECHO  #                ¬°PROCESO COMPLETADO CON EXITO!                  #
ECHO  #----------------------------------------------------------------#
ECHO  #  Los contenedores estan corriendo en segundo plano.            #
ECHO  #  Puedes ver los logs con: docker-compose logs -f bot            #
ECHO  ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/generate_snapshot.py ===
# scripts/generate_snapshot.py

import os
from pathlib import Path

# --- CONFIGURACI√ìN ---

# Directorio ra√≠z del proyecto (sube dos niveles desde este script)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# Nombre del archivo de salida
OUTPUT_FILENAME = "project_snapshot.txt"

# --- LISTA NEGRA: Directorios y archivos a IGNORAR SIEMPRE ---
# Usamos sets para una b√∫squeda m√°s eficiente.
EXCLUDED_DIRS = {
    ".git",
    ".idea",
    ".vscode",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    "postgres_data",
    "node_modules",
}

EXCLUDED_FILES = {
    ".env",
    OUTPUT_FILENAME,
    "poetry.lock",
    "Pipfile.lock",
}

# Extensiones de archivo a ignorar (ej: binarios, compilados)
EXCLUDED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".egg-info",
    ".swp",
    ".db",
    ".sqlite3",
}

# --- FIN DE LA CONFIGURACI√ìN ---


def write_file_content(output_file, file_path):
    """Escribe el contenido de un archivo en el archivo de salida, con un encabezado."""
    # Obtenemos la ruta relativa usando el est√°ndar POSIX (barras /)
    relative_path = file_path.relative_to(PROJECT_ROOT).as_posix()
    print(f"  -> A√±adiendo: {relative_path}")

    header = f"# === INICIO: {relative_path} ===\n"
    footer = f"# === FIN: {relative_path} ===\n\n\n"

    output_file.write(header)
    try:
        # Leemos el contenido del archivo
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            # A√±adimos un salto de l√≠nea al final si no lo tiene, para un formato limpio
            if content and not content.endswith('\n'):
                content += '\n'
            output_file.write(content)
    except Exception as e:
        output_file.write(f"*** No se pudo leer el archivo: {e} ***\n")
    output_file.write(footer)


def main():
    """Funci√≥n principal para generar el snapshot del proyecto."""
    output_path = PROJECT_ROOT / OUTPUT_FILENAME
    print(f"Generando snapshot del proyecto en: {output_path}\n")

    # Usaremos una lista para almacenar las rutas de los archivos a incluir
    files_to_process = []

    # os.walk recorre todos los directorios y archivos desde la ra√≠z del proyecto
    for root, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        # Modificamos la lista de directorios 'in-place' para evitar que os.walk entre en ellos
        dirs[:] = [d for d in sorted(dirs) if d not in EXCLUDED_DIRS]

        # Procesamos los archivos del directorio actual
        for filename in sorted(files):
            # Comprobamos si el archivo o su extensi√≥n est√°n en la lista negra
            if filename in EXCLUDED_FILES:
                continue

            file_path = Path(root) / filename
            if file_path.suffix in EXCLUDED_EXTENSIONS:
                continue

            # Si el archivo pasa todos los filtros, lo a√±adimos a la lista
            files_to_process.append(file_path)

    # Escribimos todos los archivos encontrados en el archivo de salida
    with open(output_path, 'w', encoding='utf-8') as output_file:
        for file_path in files_to_process:
            write_file_content(output_file, file_path)

    print(f"\n¬°Snapshot generado con √©xito! {len(files_to_process)} archivos procesados.")


if __name__ == "__main__":
    main()
# === FIN: scripts/generate_snapshot.py ===


# === INICIO: scripts/run_migrations.sh ===
# === FIN: scripts/run_migrations.sh ===


# === INICIO: src/__init__.py ===
# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===
# src/config.py
"""
M√≥dulo de Configuraci√≥n Centralizado.

Este archivo define la clase `Settings` que utiliza Pydantic para cargar, validar
y gestionar todas las variables de entorno necesarias para la aplicaci√≥n.

Pydantic se encarga de:
1. Leer las variables desde un archivo `.env`.
2. Validar que las variables existan y tengan el tipo de dato correcto (ej: int, str).
3. Proveer un objeto `settings` √∫nico y fuertemente tipado que puede ser importado
   y utilizado en cualquier parte del proyecto.

Esto evita la dispersi√≥n de `os.getenv()` por el c√≥digo y asegura que la aplicaci√≥n
no arranque si falta una configuraci√≥n cr√≠tica.
"""

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    """
    Define y carga todas las variables de entorno de la aplicaci√≥n.
    """
    # Telegram
    bot_token: SecretStr

    # Database (PostgreSQL)
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Cache y Estados (Redis)
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        """
        Genera la URL de conexi√≥n a la base de datos para el motor AS√çNCRONO.
        Utiliza el driver 'asyncpg', que es el principal para la aplicaci√≥n.
        """
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @property
    def sync_database_url(self) -> str:
        """
        Genera la URL de conexi√≥n a la base de datos para operaciones S√çNCRONAS.
        Utiliza el driver 'psycopg2'. Su uso principal es para componentes que no
        son compatibles con asyncio, como el `SQLAlchemyJobStore` de APScheduler.
        """
        return (
            f"postgresql+psycopg2://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        """
        Configuraci√≥n interna de Pydantic para indicarle c√≥mo cargar las variables.
        """
        # Nombre del archivo del que se leer√°n las variables de entorno.
        env_file = '.env'
        # Codificaci√≥n del archivo .env.
        env_file_encoding = 'utf-8'

# Creamos una instancia √∫nica de la configuraci√≥n que ser√° importada
# por el resto de la aplicaci√≥n.
settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
"""
M√≥dulo de Configuraci√≥n de la Base de Datos.

Este archivo es el responsable de crear y configurar la conexi√≥n a la base de
datos para toda la aplicaci√≥n utilizando SQLAlchemy en modo as√≠ncrono.

Componentes Clave:
1. `async_engine`: Una instancia √∫nica del motor de base de datos que gestiona
   las conexiones a bajo nivel. Se crea una sola vez cuando se inicia la app.
2. `async_session_factory`: Una "f√°brica" que produce objetos de sesi√≥n de
   SQLAlchemy (`AsyncSession`). Cada vez que se necesita interactuar con la
   base de datos (ej: dentro de un manejador de comandos), se solicita una nueva
   sesi√≥n a esta f√°brica.
"""

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Se crea una √∫nica instancia del motor as√≠ncrono para toda la aplicaci√≥n.
# Este objeto gestiona un pool de conexiones a la base de datos.
async_engine = create_async_engine(
    settings.database_url,

    # `echo=True` mostrar√≠a todas las sentencias SQL que se ejecutan en la consola.
    # Es muy √∫til para depurar, pero debe estar en `False` en producci√≥n.
    echo=False,
)

# Se crea una f√°brica de sesiones. Esta f√°brica se usar√° en toda la aplicaci√≥n
# para obtener una nueva sesi√≥n de corta duraci√≥n cada vez que se necesite
# realizar una operaci√≥n en la base de datos.
async_session_factory = async_sessionmaker(
    bind=async_engine,

    # `expire_on_commit=False` es crucial en aplicaciones as√≠ncronas.
    # Evita que SQLAlchemy invalide los objetos (ej: un 'Character') despu√©s de un
    # `session.commit()`. Sin esto, acceder a un atributo de un objeto despu√©s
    # de un commit podr√≠a lanzar un error al intentar recargarlo desde una
    # sesi√≥n ya cerrada.
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===
# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
# src/bot/bot.py
"""
M√≥dulo para la Instanciaci√≥n del Objeto Bot de Aiogram.

Este archivo tiene una √∫nica y simple responsabilidad: crear una instancia
global del objeto `Bot` de Aiogram.

Centralizar la creaci√≥n de esta instancia aqu√≠ permite que cualquier otro
m√≥dulo en la aplicaci√≥n (como los servicios) pueda importarla para interactuar
directamente con la API de Telegram (por ejemplo, para enviar mensajes
proactivos fuera del flujo normal de un comando).
"""

from aiogram import Bot

from src.config import settings

# Se crea una instancia √∫nica del Bot para toda la aplicaci√≥n.
# El token se lee de forma segura desde el objeto de configuraci√≥n `settings`,
# que a su vez lo carga desde las variables de entorno.
# `settings.bot_token.get_secret_value()` es la forma correcta de acceder
# al valor de un `SecretStr` de Pydantic.
bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py
"""
M√≥dulo para la Instanciaci√≥n del Dispatcher de Aiogram.

Este archivo crea y configura la instancia global del `Dispatcher`, que es el
componente central de Aiogram para el procesamiento de actualizaciones (mensajes,
callbacks, etc.).

Responsabilidades:
1.  **Enrutamiento:** El `Dispatcher` (`dp`) es el objeto al que se registran
    todos los manejadores de mensajes (handlers). Se encarga de decidir qu√©
    funci√≥n debe procesar cada mensaje entrante.
2.  **Gesti√≥n de Estados (FSM):** Configura el almacenamiento de estados finitos
    (Finite State Machine), que permite crear conversaciones de varios pasos
    (ej: creaci√≥n de personaje, men√∫s interactivos).
"""

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# 1. Configuraci√≥n del Almacenamiento de Estados (FSM - Finite State Machine)
# Se utiliza Redis (`RedisStorage2`) como backend para almacenar el estado de
# la conversaci√≥n de cada usuario. Esto es esencial para funcionalidades
# de varios pasos, como la creaci√≥n de personajes.
#
# `pool_size` se establece expl√≠citamente para evitar el error 'Too many connections'
# que puede ocurrir si muchos usuarios interact√∫an con el bot simult√°neamente.
storage = RedisStorage2(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    pool_size=20,
)

# 2. Creaci√≥n de la Instancia del Dispatcher
# Se crea una instancia √∫nica del `Dispatcher` para toda la aplicaci√≥n,
# vincul√°ndola con la instancia del `bot` y el `storage` configurado.
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
"""
M√≥dulo del Dispatcher Principal de Comandos.

Este archivo contiene el manejador (`handler`) m√°s importante de la aplicaci√≥n.
La funci√≥n `main_command_dispatcher` est√° registrada para interceptar **todos**
los mensajes de texto enviados por los jugadores.

Act√∫a como el "cerebro" del juego, orquestando el siguiente flujo para cada mensaje:
1. Obtiene el contexto del jugador (Cuenta, Personaje) desde la base de datos.
2. Actualiza el estado de actividad del jugador (online/AFK).
3. Maneja casos especiales como el comando `/start`.
4. Utiliza el `command_service` para determinar din√°micamente qu√© `CommandSets`
   est√°n activos para el jugador en ese preciso momento.
5. Busca el comando invocado dentro de los sets activos.
6. Verifica los permisos (`permission_service`).
7. Ejecuta el m√©todo `.execute()` del comando encontrado.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service, online_service, command_service
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.player.movement import MOVEMENT_COMMANDS
from commands.player.channels import CHANNEL_COMMANDS
from commands.admin.building import SPAWN_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from commands.admin.info import INFO_COMMANDS
from src.utils.presenters import show_current_room

# El diccionario `COMMAND_SETS` es el cat√°logo maestro que contiene una instancia
# de cada comando disponible en el juego, agrupados por funcionalidad.
COMMAND_SETS = {
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "movement": MOVEMENT_COMMANDS,
    "channels": CHANNEL_COMMANDS,
    "spawning": SPAWN_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
    "admin_info": INFO_COMMANDS,
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Manejador principal que intercepta todos los mensajes de texto y los
    enruta al comando correspondiente.
    """
    async with async_session_factory() as session:
        try:
            # 1. Obtener el contexto del jugador.
            account = await player_service.get_or_create_account(session, message.from_user.id)
            if not account:
                # Si no se puede obtener la cuenta, es un error grave.
                await message.answer("Error cr√≠tico al acceder a tu cuenta.")
                return
            character = account.character
            input_text = message.text.strip()

            # 2. Actualizar estado de actividad (online/AFK).
            if character:
                await online_service.update_last_seen(session, character)

            # 3. Manejo especial para el comando /start.
            if input_text.lower().startswith('/start'):
                if character is None:
                    await message.answer(
                        "¬°Bienvenido a Runegram! Veo que eres nuevo por aqu√≠.\n"
                        "Para empezar, necesitas crear tu personaje. Usa el comando:\n"
                        "/crearpersonaje [nombre]"
                    )
                else:
                    await command_service.update_telegram_commands(character)
                    await show_current_room(message)
                return

            # 4. Validar que el jugador tenga un personaje para comandos que no sean de creaci√≥n.
            if not character:
                if not input_text.lower().startswith('/crearpersonaje'):
                    await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                # Permitimos que solo /crearpersonaje contin√∫e si no hay personaje.

            # 5. Parsear el comando y sus argumentos.
            if not input_text.startswith('/'):
                await message.answer("Comando desconocido. Los comandos deben empezar con / (ej: /mirar, /norte).")
                return

            cmd_name = message.get_command(pure=True).lower()
            args = message.get_args().split() if message.get_args() else []

            # 6. Obtener la lista din√°mica de CommandSets activos.
            active_sets_names = await command_service.get_active_command_sets_for_character(character)

            # 7. Buscar y ejecutar el comando.
            found_cmd = None
            for set_name in active_sets_names:
                for cmd_instance in COMMAND_SETS.get(set_name, []):
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
                if found_cmd:
                    break

            if not found_cmd:
                await message.answer("No conozco ese comando.")
                return

            # Si el jugador no tiene personaje, solo puede ejecutar comandos sin lock.
            if not character and found_cmd.lock:
                await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                return

            can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
            if not can_run:
                await message.answer(error_message or "No puedes hacer eso.")
                return

            await found_cmd.execute(character, session, message, args)

        except Exception:
            # Captura final para cualquier error no manejado en las capas inferiores.
            # Esto evita que el bot se caiga y registra el problema para depuraci√≥n.
            await message.answer("Ocurri√≥ un error inesperado al procesar tu comando.")
            logging.exception(f"Error cr√≠tico no manejado en el dispatcher principal para el usuario {message.from_user.id}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
from .character_setting import CharacterSetting
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
"""
M√≥dulo que define el Modelo de Datos para una Cuenta de Usuario.

Este archivo contiene la clase `Account`, que se mapea a la tabla `accounts`
en la base de datos. Una cuenta representa a un usuario real a nivel de aplicaci√≥n,
identificado de forma √∫nica por su `telegram_id`.

La cuenta es la entidad "propietaria" de un personaje (`Character`) y almacena
metadatos sobre el usuario, como su rol (JUGADOR, ADMINISTRADOR) y su estado
(ACTIVO, BLOQUEADO).
"""

from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    """

    Representa una cuenta de usuario en la base de datos.
    """
    __tablename__ = 'accounts'

    # Identificador √∫nico de la cuenta en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El ID de usuario √∫nico proporcionado por Telegram.
    # Es crucial para vincular nuestra cuenta interna con el usuario de Telegram.
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)

    # El rol del usuario en el juego (ej: 'JUGADOR', 'ADMINISTRADOR').
    # Determina el acceso a comandos y funcionalidades especiales.
    role = Column(String, default='JUGADOR', nullable=False)

    # El estado de la cuenta (ej: 'ACTIVE', 'BLOCKED').
    # Permite gestionar el acceso de los usuarios a nivel de cuenta.
    status = Column(String(20), default='ACTIVE', nullable=False, server_default='ACTIVE')

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-uno con el personaje del juego.
    # `uselist=False` indica que una cuenta solo puede tener un personaje.
    # `back_populates` asegura que la relaci√≥n sea bidireccional, permitiendo
    # acceder a `character.account`.
    # SQLAlchemy es lo suficientemente inteligente como para encontrar la clase "Character"
    # entre los modelos que heredan de la misma Base.
    character = relationship("Character", back_populates="account", uselist=False)

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Account(id={self.id}, telegram_id={self.telegram_id}, role='{self.role}')>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
"""
M√≥dulo que define la Base Declarativa para todos los Modelos de SQLAlchemy.

Este archivo contiene un √∫nico pero crucial objeto: `Base`.

SQLAlchemy utiliza un sistema "declarativo" donde las clases de Python se mapean
directamente a tablas de la base de datos. Para que esto funcione, todas las
clases de modelo (como `Account`, `Character`, `Room`, etc.) deben heredar de
una clase base com√∫n.

Esta clase `Base` act√∫a como un registro central que recopila metadatos sobre
todas las clases de modelo que heredan de ella. Herramientas como Alembic
utilizan estos metadatos para comparar los modelos con el estado de la base
de datos y generar as√≠ las migraciones autom√°ticamente.
"""

from sqlalchemy.orm import declarative_base

# `declarative_base()` es una funci√≥n de f√°brica que construye la clase base.
# Todos nuestros modelos de datos en el proyecto heredar√°n de este objeto `Base`.
Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
"""
M√≥dulo que define el Modelo de Datos para un Personaje del Juego.

Este archivo contiene la clase `Character`, que se mapea a la tabla `characters`
en la base de datos. Un personaje es el "avatar" o la entidad con la que un
jugador interact√∫a dentro del mundo de Runegram.

El personaje est√° vinculado a una `Account` (el usuario real) y act√∫a como el
punto central para las relaciones de juego, como su ubicaci√≥n (`Room`), su
inventario (`Item`), y sus configuraciones (`CharacterSetting`).
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class Character(Base):
    """
    Representa un personaje jugable en la base de datos.
    """
    __tablename__ = 'characters'

    # --- Atributos Principales ---

    # Identificador √∫nico del personaje en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El nombre del personaje, que debe ser √∫nico en todo el juego.
    name = Column(String(50), unique=True, nullable=False)

    # --- Claves For√°neas ---

    # V√≠nculo a la cuenta propietaria de este personaje.
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)

    # V√≠nculo a la sala donde se encuentra actualmente el personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Atributos de Juego (Datos Estructurados) ---

    # Almacena la lista de CommandSets base que el personaje conoce.
    # Por ejemplo: ["general", "interaction", "movement", "channels"].
    # Este campo es la base para el sistema de comandos din√°micos.
    command_sets = Column(
        JSONB,
        nullable=False,
        server_default='["general", "interaction", "movement", "channels"]',
        default=["general", "interaction", "movement", "channels"]
    )

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-uno con la cuenta.
    # Permite acceder al objeto `Account` desde el personaje v√≠a `character.account`.
    account = relationship("Account", back_populates="character")

    # Relaci√≥n muchos-a-uno con la sala.
    # Permite acceder al objeto `Room` desde el personaje v√≠a `character.room`.
    room = relationship("Room")

    # Relaci√≥n uno-a-muchos con los objetos del inventario.
    # Permite acceder a una lista de objetos `Item` v√≠a `character.items`.
    items = relationship("Item", back_populates="character")

    # Relaci√≥n uno-a-uno con las configuraciones del personaje.
    # Permite acceder al objeto `CharacterSetting` v√≠a `character.settings`.
    # `cascade="all, delete-orphan"` asegura que si se borra un personaje,
    # su fila de configuraciones asociada tambi√©n se borre autom√°ticamente.
    settings = relationship(
        "CharacterSetting",
        back_populates="character",
        uselist=False,
        cascade="all, delete-orphan"
    )

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Character(id={self.id}, name='{self.name}')>"
# === FIN: src/models/character.py ===


# === INICIO: src/models/character_setting.py ===
# src/models/character_setting.py
"""
M√≥dulo que define el Modelo de Datos para las Configuraciones de un Personaje.

Este archivo contiene la clase `CharacterSetting`, que se mapea a la tabla
`character_settings`. Esta tabla almacena configuraciones personalizables
para cada personaje, manteniendo el modelo `Character` principal m√°s limpio.

El uso de una columna `JSONB` (`active_channels`) permite a√±adir futuras
configuraciones (ej: colores, flags de tutorial) sin necesidad de modificar
el esquema de la base de datos, lo que hace que el sistema sea muy flexible
y extensible.
"""

from sqlalchemy import BigInteger, Column, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class CharacterSetting(Base):
    """
    Representa una fila de configuraciones para un personaje espec√≠fico.
    """
    __tablename__ = 'character_settings'

    # --- Clave Primaria y For√°nea ---

    # Usamos el ID del personaje como clave primaria (`primary_key=True`).
    # Esto impone una relaci√≥n estricta de uno-a-uno a nivel de base de datos:
    # no puede haber m√°s de una fila de configuraciones por personaje.
    character_id = Column(BigInteger, ForeignKey('characters.id'), primary_key=True)

    # --- Atributos de Configuraci√≥n ---

    # Columna JSONB para guardar una lista de los canales a los que el personaje
    # est√° suscrito. Usar JSONB es muy flexible.
    # Ejemplo de contenido: `{"active_channels": ["novato", "comercio"]}`
    active_channels = Column(JSONB, nullable=False, server_default='{}')

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n inversa uno-a-uno con el personaje.
    # Permite acceder al objeto `Character` desde la configuraci√≥n v√≠a `settings.character`.
    character = relationship("Character", back_populates="settings")

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<CharacterSetting(character_id={self.character_id})>"
# === FIN: src/models/character_setting.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py
"""
M√≥dulo que define el Modelo de Datos para una Salida entre Salas.

Este archivo contiene la clase `Exit`, que se mapea a la tabla `exits`.
Cada fila en esta tabla representa una conexi√≥n UNIDIRECCIONAL desde una sala
de origen (`from_room_id`) hacia una sala de destino (`to_room_id`).

Una conexi√≥n bidireccional (ej: una puerta entre la sala A y la sala B) se
representa como dos filas separadas en esta tabla:
1. Una salida desde A hacia B (ej: "norte").
2. Una salida desde B hacia A (ej: "sur").
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    # --- Atributos Principales ---

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta").
    name = Column(String(50), nullable=False, index=True)

    # El string de permisos para esta salida espec√≠fica.
    locks = Column(String, nullable=False, default="")

    # --- Claves For√°neas ---

    # El ID de la sala desde la que parte esta salida.
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El ID de la sala a la que lleva esta salida.
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n para poder acceder al objeto `Room` de origen.
    # `foreign_keys=[from_room_id]` es necesario para que SQLAlchemy sepa cu√°l de
    # las dos claves for√°neas a 'rooms.id' debe usar para esta relaci√≥n.
    # `back_populates="exits_from"` la conecta con la lista de salidas en el modelo Room.
    from_room = relationship("Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relaci√≥n para poder acceder al objeto `Room` de destino.
    # `back_populates="exits_to"` la conecta con la lista de "llegadas" en el modelo Room.
    to_room = relationship("Room", foreign_keys=[to_room_id], back_populates="exits_to")

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Exit(id={self.id}, name='{self.name}', from={self.from_room_id}, to={self.to_room_id})>"
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py
"""
M√≥dulo que define el Modelo de Datos para una Instancia de Objeto (Item).

Este archivo contiene la clase `Item`, que se mapea a la tabla `items`.
Es fundamental entender que este modelo NO representa un tipo de objeto, sino
una INSTANCIA √∫nica de un objeto en el mundo.

Este modelo es deliberadamente "ligero". La mayor√≠a de sus propiedades (nombre,
descripci√≥n, scripts, etc.) no se almacenan en la base de datos, sino que se
obtienen en tiempo de ejecuci√≥n a trav√©s de la columna `key`, que lo vincula
a su prototipo correspondiente en `game_data/item_prototypes.py`.
"""

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship

from game_data.item_prototypes import ITEM_PROTOTYPES
from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo del juego.
    """
    __tablename__ = 'items'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ITEM_PROTOTYPES.
    # Por ejemplo: "espada_viviente".
    key = Column(String(50), nullable=False, index=True)

    # Atributos `_override`: Permiten que una instancia espec√≠fica tenga
    # un nombre o descripci√≥n diferente a la de su prototipo, creando objetos √∫nicos.
    # Si son `NULL`, se usar√°n los valores del prototipo.
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)

    # --- Ubicaci√≥n del Objeto ---

    # El ID de la sala donde se encuentra el objeto.
    # Es `NULL` si el objeto est√° en el inventario de un personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)

    # El ID del personaje que lleva el objeto.
    # Es `NULL` si el objeto est√° en el suelo de una sala.
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n muchos-a-uno con la sala. Permite acceder a `item.room`.
    room = relationship("Room", back_populates="items")

    # Relaci√≥n muchos-a-uno con el personaje. Permite acceder a `item.character`.
    character = relationship("Character", back_populates="items")

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para este objeto desde `game_data`. Es el puente entre la instancia
        de la base de datos y su definici√≥n de contenido.
        """
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """
        Obtiene el nombre del item.
        Prioriza el `name_override` si existe; de lo contrario,
        recurre al nombre definido en el prototipo.
        """
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """
        Obtiene la descripci√≥n del item.
        Prioriza el `description_override` si existe; de lo contrario,
        recurre a la descripci√≥n definida en el prototipo.
        """
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """
        Obtiene las palabras clave del item, que siempre provienen del prototipo.
        """
        return self.prototype.get("keywords", [])

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Item(id={self.id}, key='{self.key}')>"
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py
"""
M√≥dulo que define el Modelo de Datos para una Sala del Mundo.

Este archivo contiene la clase `Room`, que se mapea a la tabla `rooms`.
Cada fila en esta tabla representa una ubicaci√≥n √∫nica en el juego.

Siguiendo la filosof√≠a de dise√±o del motor, una `Room` en la base de datos
es principalmente una instancia que se corresponde con un prototipo definido en
`game_data/room_prototypes.py`, vinculado a trav√©s de la columna `key`.
"""

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base
from game_data.room_prototypes import ROOM_PROTOTYPES

class Room(Base):
    """
    Representa una sala o ubicaci√≥n en el mundo del juego.
    """
    __tablename__ = 'rooms'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ROOM_PROTOTYPES.
    # Por ejemplo: "plaza_central". Es √∫nico y no deber√≠a cambiar.
    key = Column(String(50), unique=True, nullable=True, index=True)

    # El nombre y la descripci√≥n pueden ser actualizados desde los prototipos
    # por el `world_loader_service`.
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")

    # String de permisos para la sala en s√≠ (ej: para impedir la entrada).
    locks = Column(String, nullable=False, default="")

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-muchos con los objetos que se encuentran en esta sala.
    # Permite acceder a una lista de `Item` v√≠a `room.items`.
    items = relationship("Item", back_populates="room")

    # Relaci√≥n uno-a-muchos con las salidas QUE PARTEN DESDE ESTA SALA.
    # Permite acceder a una lista de `Exit` v√≠a `room.exits_from`.
    # `cascade="all, delete-orphan"` asegura que si se borra una sala,
    # todas sus salidas asociadas tambi√©n se eliminen.
    exits_from = relationship(
        "Exit",
        foreign_keys="[Exit.from_room_id]",
        back_populates="from_room",
        cascade="all, delete-orphan"
    )

    # Relaci√≥n uno-a-muchos con las salidas QUE LLEGAN A ESTA SALA.
    # Es √∫til para comprobaciones inversas (ej: "¬øqu√© salas conectan aqu√≠?").
    exits_to = relationship(
        "Exit",
        foreign_keys="[Exit.to_room_id]",
        back_populates="to_room",
        cascade="all, delete-orphan"
    )

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para esta sala desde `game_data`.
        """
        if not self.key:
            return {}
        return ROOM_PROTOTYPES.get(self.key, {})

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Room(id={self.id}, key='{self.key}', name='{self.name}')>"
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===
# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster_service.py ===
# src/services/broadcaster_service.py
"""
M√≥dulo de Servicio de Transmisi√≥n (Broadcasting).

Este archivo centraliza toda la l√≥gica para enviar mensajes a los jugadores
a trav√©s del bot de Telegram. Act√∫a como una capa de abstracci√≥n sobre la API
directa del bot.

Centralizar la comunicaci√≥n aqu√≠ ofrece varias ventajas:
1.  **Consistencia:** Todos los mensajes enviados por el juego pueden tener un
    formato y comportamiento consistentes.
2.  **Manejo de Errores Unificado:** La l√≥gica para manejar errores de la API de
    Telegram (ej: un usuario bloquea el bot) se encuentra en un solo lugar.
3.  **Desacoplamiento:** El resto de los servicios (scripts, canales, etc.) no
    necesitan saber los detalles de c√≥mo se env√≠a un mensaje; simplemente
    llaman a una funci√≥n en este servicio.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.bot.bot import bot
from src.models import Character


async def send_message_to_character(
    character: Character,
    message_text: str,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje formateado a un personaje espec√≠fico.

    Args:
        character (Character): La instancia del modelo Character a la que se enviar√° el mensaje.
                               Es crucial que este objeto tenga su relaci√≥n `.account` precargada.
        message_text (str): El contenido del mensaje a enviar.
        parse_mode (str): El modo de parseo de Telegram (por defecto 'HTML').
    """
    if not character:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un personaje nulo.")
        return

    # Salvaguarda para asegurar que la relaci√≥n con la cuenta est√° cargada.
    if not character.account:
        logging.error(f"BROADCASTER: El personaje {character.name} (ID: {character.id}) no tiene su cuenta cargada. No se puede enviar mensaje.")
        return

    try:
        logging.info(f"[BROADCASTER DEBUG] Intentando enviar mensaje a {character.name} (Chat ID: {character.account.telegram_id})")
        await bot.send_message(
            chat_id=character.account.telegram_id,
            text=message_text,
            parse_mode=parse_mode
        )
        logging.info(f"[BROADCASTER DEBUG] Mensaje enviado con √©xito a {character.name}")
    except Exception:
        # Usamos logging.exception para obtener un traceback completo si el env√≠o falla.
        # Esto es com√∫n si un usuario ha bloqueado el bot. No debe detener el juego.
        logging.exception(f"BROADCASTER: No se pudo enviar mensaje a {character.name} (ID: {character.id})")


async def send_message_to_room(
    session: AsyncSession,
    room_id: int,
    message_text: str,
    exclude_character_id: int | None = None,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje a todos los personajes presentes en una sala espec√≠fica.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala a la que se enviar√° el mensaje.
        message_text (str): El contenido del mensaje a enviar.
        exclude_character_id (int, optional): El ID de un personaje a excluir de la transmisi√≥n.
        parse_mode (str): El modo de parseo de Telegram.
    """
    if not room_id:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un room_id nulo.")
        return

    # 1. Obtenemos todos los personajes en la sala.
    #    Usamos `selectinload(Character.account)` para cargar eficientemente la
    #    informaci√≥n de la cuenta de todos los personajes en una sola consulta.
    query = (
        select(Character)
        .where(Character.room_id == room_id)
        .options(selectinload(Character.account))
    )
    result = await session.execute(query)
    characters_in_room = result.scalars().all()

    # 2. Iteramos y enviamos el mensaje a cada personaje.
    for char in characters_in_room:
        if char.id == exclude_character_id:
            continue

        # Reutilizamos nuestra propia funci√≥n para mantener la l√≥gica de env√≠o en un solo lugar.
        await send_message_to_character(
            character=char,
            message_text=message_text,
            parse_mode=parse_mode
        )
# === FIN: src/services/broadcaster_service.py ===


# === INICIO: src/services/channel_service.py ===
# src/services/channel_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Canales de Chat.

Este servicio encapsula toda la l√≥gica de negocio relacionada con los canales
de comunicaci√≥n globales. Sus responsabilidades incluyen:
- Gestionar la configuraci√≥n de canales por personaje (suscripciones).
- Formatear y transmitir mensajes a todos los jugadores suscritos a un canal.
- Proveer funciones de ayuda para comprobar el estado de los canales.

Depende de `broadcaster_service` para el env√≠o final de mensajes y de
`game_data/channel_prototypes.py` como fuente de la verdad sobre los
canales disponibles.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Character, CharacterSetting
from src.services import broadcaster_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

async def get_or_create_settings(session: AsyncSession, character: Character) -> CharacterSetting:
    """
    Obtiene las configuraciones para un personaje. Si no existen, las crea con
    los valores por defecto definidos en los prototipos de canal.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        character (Character): El personaje para el que se obtienen las configuraciones.

    Returns:
        CharacterSetting: El objeto de configuraci√≥n del personaje.
    """
    # Si las settings ya est√°n cargadas en el objeto character, las devolvemos directamente.
    if character.settings:
        return character.settings

    # Si no, las creamos.
    logging.info(f"Creando configuraciones por defecto para el personaje {character.name}")

    # Leemos los prototipos para ver qu√© canales deben estar activados por defecto.
    default_channels = [
        key for key, data in CHANNEL_PROTOTYPES.items() if data.get("default_on", False)
    ]

    new_settings = CharacterSetting(
        character_id=character.id,
        active_channels={"active_channels": default_channels}
    )
    session.add(new_settings)
    await session.commit()

    # Refrescamos el objeto 'character' para que la relaci√≥n 'settings' se cargue.
    await session.refresh(character, attribute_names=["settings"])

    return character.settings

async def is_channel_active(settings: CharacterSetting, channel_key: str) -> bool:
    """Comprueba si un canal est√° en la lista de canales activos de un jugador."""
    if not settings:
        return False
    return channel_key in settings.active_channels.get("active_channels", [])

async def broadcast_to_channel(session: AsyncSession, channel_key: str, message: str, exclude_character_id: int | None = None):
    """
    Env√≠a un mensaje a todos los jugadores que est√©n suscritos a un canal.
    """
    try:
        if channel_key not in CHANNEL_PROTOTYPES:
            logging.warning(f"Intento de transmitir a un canal desconocido: {channel_key}")
            return

        # 1. Formatear el mensaje con el √≠cono y nombre del canal.
        proto = CHANNEL_PROTOTYPES[channel_key]
        formatted_message = f"{proto['icon']} <b>{proto['name']}:</b> {message}"

        # 2. Obtener todos los personajes del juego.
        #    Precargamos sus settings y cuentas para evitar consultas adicionales en el bucle.
        query = select(Character).options(selectinload(Character.settings), selectinload(Character.account))
        result = await session.execute(query)
        all_characters = result.scalars().all()

        # 3. Iterar y enviar el mensaje a los que est√©n suscritos.
        for char in all_characters:
            if char.id == exclude_character_id:
                continue

            settings = await get_or_create_settings(session, char)
            if await is_channel_active(settings, channel_key):
                await broadcaster_service.send_message_to_character(char, formatted_message)
    except Exception:
        logging.exception(f"Error al transmitir al canal '{channel_key}'")

async def set_channel_status(session: AsyncSession, character: Character, channel_key: str, activate: bool):
    """Activa o desactiva un canal para un personaje."""
    if channel_key not in CHANNEL_PROTOTYPES:
        raise ValueError("El canal especificado no existe.")

    settings = await get_or_create_settings(session, character)

    # SQLAlchemy es capaz de detectar cambios en listas dentro de un JSONB "mutable".
    # Obtenemos la lista actual de canales activos.
    active_channels_list = settings.active_channels.get("active_channels", [])

    if activate:
        # A√±adir el canal si no est√° ya en la lista.
        if channel_key not in active_channels_list:
            active_channels_list.append(channel_key)
    else: # Desactivar
        # Quitar el canal si est√° en la lista.
        if channel_key in active_channels_list:
            active_channels_list.remove(channel_key)

    # Reasignamos la lista modificada al campo JSONB.
    settings.active_channels["active_channels"] = active_channels_list

    # Marcamos el objeto como "modificado" para que SQLAlchemy sepa que debe guardarlo.
    from sqlalchemy.orm.attributes import flag_modified
    flag_modified(settings, "active_channels")

    await session.commit()
# === FIN: src/services/channel_service.py ===


# === INICIO: src/services/command_service.py ===
# src/services/command_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Comandos.

Este servicio es el cerebro detr√°s del sistema de comandos din√°micos.
No define los comandos en s√≠, sino que orquesta cu√°les est√°n disponibles
para un jugador en un momento dado y c√≥mo se presentan en la interfaz.

Responsabilidades Clave:
1. Calcular la lista de `CommandSets` activos para un personaje bas√°ndose
   en su estado, equipo y ubicaci√≥n (contexto).
2. Sincronizar la lista de comandos disponibles con la interfaz del cliente
   de Telegram, proporcionando una experiencia de usuario (UX) reactiva.
"""

import logging
from aiogram.types import BotCommand, BotCommandScopeChat
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.bot import bot
from src.models import Character

def get_command_sets() -> dict:
    """
    Obtiene el diccionario `COMMAND_SETS` del dispatcher de forma segura.

    Este es un patr√≥n para evitar una "importaci√≥n circular", ya que el dispatcher
    importa este servicio, y este servicio necesita acceso al diccionario que
    el dispatcher define. La importaci√≥n se realiza dentro de la funci√≥n para
    retrasar su ejecuci√≥n hasta que todos los m√≥dulos est√©n cargados.
    """
    from src.handlers.player.dispatcher import COMMAND_SETS
    return COMMAND_SETS

async def get_active_command_sets_for_character(character: Character) -> list[str]:
    """
    Construye la lista de nombres de CommandSets activos para un personaje
    bas√°ndose en su contexto actual (base, equipo, sala, rol).
    """
    # Si no hay personaje (durante la creaci√≥n), solo est√°n disponibles los
    # comandos de creaci√≥n de personaje.
    if not character:
        return ["character_creation"]

    # 1. Empezamos con los sets base del personaje desde la BD (ej: "general", "movement").
    active_sets = set(character.command_sets)

    # 2. A√±adimos sets otorgados por los objetos en el inventario.
    for item in character.items:
        granted_sets = item.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 3. A√±adimos sets otorgados por la sala actual.
    if character.room and character.room.prototype:
        granted_sets = character.room.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 4. A√±adimos sets de administrador si el rol de la cuenta es el adecuado.
    if character.account and character.account.role == "ADMINISTRADOR":
        active_sets.update(["spawning", "admin_movement", "admin_info"])

    return sorted(list(active_sets))


async def update_telegram_commands(character: Character):
    """
    Actualiza la lista de comandos visibles en el men√∫ '/' del cliente de Telegram
    para un personaje espec√≠fico.
    """
    if not character or not character.account:
        return

    try:
        COMMAND_SETS = get_command_sets()
        active_set_names = await get_active_command_sets_for_character(character)

        telegram_commands = []
        seen_commands = set() # Para evitar duplicados si un comando est√° en varios sets.

        # Construimos la lista de objetos BotCommand que la API de Telegram espera.
        for set_name in active_set_names:
            for command_instance in COMMAND_SETS.get(set_name, []):
                # Usamos el primer alias como el comando principal (ej: "norte" de ["norte", "n"]).
                main_name = command_instance.names[0]
                if main_name not in seen_commands:
                    telegram_commands.append(
                        BotCommand(command=main_name, description=command_instance.description)
                    )
                    seen_commands.add(main_name)

        # Usamos un `BotCommandScopeChat` para aplicar estos comandos √∫nicamente
        # al chat con este jugador espec√≠fico, y no globalmente.
        scope = BotCommandScopeChat(chat_id=character.account.telegram_id)
        await bot.set_my_commands(commands=telegram_commands, scope=scope)

        logging.info(f"Actualizados {len(telegram_commands)} comandos de Telegram para {character.name}.")

    except Exception as e:
        # Los errores al actualizar comandos no son cr√≠ticos y no deben detener el juego.
        # Por ejemplo, si el usuario ha bloqueado al bot.
        logging.warning(f"No se pudieron actualizar los comandos de Telegram para {character.name}: {e}")
# === FIN: src/services/command_service.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Objetos (Items).

Este servicio encapsula la l√≥gica de negocio para crear y manipular instancias
de objetos en el mundo del juego. Se encarga de la interacci√≥n directa con el
modelo `Item`.

Responsabilidades:
- Crear nuevas instancias de objetos a partir de prototipos (`spawn`).
- Mover objetos entre salas y los inventarios de los personajes.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
from game_data.item_prototypes import ITEM_PROTOTYPES
from src.services import ticker_service


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto, la coloca en una sala
    y registra sus tickers.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala donde se crear√° el objeto.
        item_key (str): La clave del prototipo del objeto a crear.

    Returns:
        Item: La nueva instancia del objeto `Item` creada.

    Raises:
        ValueError: Si la `item_key` no corresponde a ning√∫n prototipo definido.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    try:
        # 1. Crear la instancia del modelo Item, vincul√°ndola a la sala.
        new_item = Item(room_id=room_id, key=item_key)
        session.add(new_item)
        await session.commit()
        await session.refresh(new_item)

        # 2. Notificar al ticker_service para que programe los tickers de este nuevo objeto.
        await ticker_service.schedule_tickers_for_entity(new_item)

        return new_item
    except Exception:
        logging.exception(f"Error inesperado al intentar generar el objeto con clave '{item_key}' en la sala {room_id}")
        # Relanzamos la excepci√≥n para que la capa superior (el comando) la maneje.
        raise


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """
    Mueve un objeto desde una sala (o de ning√∫n sitio) al inventario de un personaje.
    Actualiza el `room_id` a NULL y establece el `character_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=None, character_id=character_id)
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """
    Mueve un objeto desde el inventario de un personaje al suelo de una sala.
    Actualiza el `character_id` a NULL y establece el `room_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=room_id, character_id=None)
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/online_service.py ===
# src/services/online_service.py
"""
M√≥dulo de Servicio para el Seguimiento de Actividad (Presencia).

Este servicio gestiona el estado de "online" o "AFK" (Away From Keyboard) de los
personajes. Utiliza Redis para un almacenamiento y recuperaci√≥n de datos de alta
velocidad, lo cual es ideal para datos vol√°tiles como el timestamp de la √∫ltima
actividad.

Responsabilidades:
- Registrar la √∫ltima vez que un jugador env√≠a un comando.
- Determinar si un jugador est√° "online" bas√°ndose en un umbral de inactividad.
- Gestionar las notificaciones cuando un jugador pasa a estado AFK o vuelve.
- Proveer una tarea global (`check_for_newly_afk_players`) para ser ejecutada
  peri√≥dicamente por el `ticker_service`.
"""

import time
import logging
import redis.asyncio as redis
from datetime import timedelta

from src.config import settings
from src.models import Character
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from src.db import async_session_factory


# --- Configuraci√≥n del Servicio ---
ONLINE_THRESHOLD = timedelta(minutes=5)

redis_client = redis.Redis(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    decode_responses=True
)

# Variable global en memoria para rastrear qui√©n estaba online en el √∫ltimo chequeo.
PREVIOUSLY_ONLINE_IDS = set()


# --- Funciones de Ayuda (Internas) ---

def _get_last_seen_key(character_id: int) -> str:
    """Genera la clave de Redis estandarizada para el timestamp de un personaje."""
    return f"last_seen:{character_id}"

def _get_afk_notified_key(character_id: int) -> str:
    """Genera la clave de Redis para el flag que indica si ya se notific√≥ el estado AFK."""
    return f"afk_notified:{character_id}"


# --- Funciones Principales del Servicio ---

async def update_last_seen(session: AsyncSession, character: Character):
    """
    Actualiza la √∫ltima actividad de un personaje y notifica si vuelve de estar AFK.
    Esta funci√≥n es llamada por el dispatcher en cada mensaje.
    """
    from src.services import channel_service

    char_id = character.id

    # 1. Actualizar el timestamp de "√∫ltima vez visto" en Redis.
    key = _get_last_seen_key(char_id)
    await redis_client.set(key, time.time())
    await redis_client.expire(key, timedelta(days=7))

    # 2. Comprobar si el personaje estaba marcado como AFK.
    afk_notified_key = _get_afk_notified_key(char_id)
    # Usamos `getdel` para obtener y borrar la clave at√≥micamente si existe.
    was_afk = await redis_client.getdel(afk_notified_key)

    if was_afk:
        # El personaje estaba AFK y acaba de volver. Notificamos.
        logging.info(f"Personaje {character.name} ha vuelto de su inactividad (AFK).")
        await channel_service.broadcast_to_channel(
            session,
            "sistema",
            f"<i>{character.name} ha vuelto de su inactividad.</i>"
        )


async def is_character_online(character_id: int) -> bool:
    """
    Verifica si un personaje se considera "online" (activo recientemente).
    """
    key = _get_last_seen_key(character_id)
    last_seen_timestamp_str = await redis_client.get(key)
    if not last_seen_timestamp_str:
        return False

    try:
        elapsed_time = time.time() - float(last_seen_timestamp_str)
        return elapsed_time < ONLINE_THRESHOLD.total_seconds()
    except (ValueError, TypeError):
        return False

async def get_online_characters(session: AsyncSession) -> list[Character]:
    """
    Devuelve una lista de todos los objetos Character que se consideran "online".
    """
    result = await session.execute(select(Character))
    all_characters = result.scalars().all()

    online_characters = []
    for char in all_characters:
        if await is_character_online(char.id):
            online_characters.append(char)

    return online_characters

async def check_for_newly_afk_players():
    """
    Tarea global peri√≥dica para detectar y notificar sobre personajes que se
    han vuelto inactivos (AFK).
    """
    from src.services import channel_service, player_service
    global PREVIOUSLY_ONLINE_IDS
    logging.info("[AFK CHECK] Ejecutando chequeo de jugadores inactivos...")

    async with async_session_factory() as session:
        try:
            result = await session.execute(select(Character.id))
            all_char_ids = set(result.scalars().all())

            currently_online_ids = set()
            for char_id in all_char_ids:
                if await is_character_online(char_id):
                    currently_online_ids.add(char_id)

            newly_afk_ids = PREVIOUSLY_ONLINE_IDS - currently_online_ids

            for char_id in newly_afk_ids:
                afk_notified_key = _get_afk_notified_key(char_id)
                # Solo notificamos si no lo hemos hecho ya.
                if not await redis_client.exists(afk_notified_key):
                    character = await player_service.get_character_with_relations_by_id(session, char_id)
                    if character:
                        logging.info(f"Personaje {character.name} ha entrado en inactividad (AFK).")
                        await channel_service.broadcast_to_channel(
                            session,
                            "sistema",
                            f"<i>{character.name} ha entrado en inactividad.</i>"
                        )
                        # Marcamos que ya fue notificado para no spamear.
                        await redis_client.set(afk_notified_key, "1", ex=timedelta(days=1))
        except Exception:
            logging.exception("[AFK CHECK] Ocurri√≥ un error durante el chequeo de AFK.")

    PREVIOUSLY_ONLINE_IDS = currently_online_ids
    logging.info(f"[AFK CHECK] Chequeo finalizado. {len(PREVIOUSLY_ONLINE_IDS)} jugadores online.")
# === FIN: src/services/online_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Permisos y Locks.

Este servicio es el responsable de interpretar los "lock strings" (cadenas de
permisos) que se encuentran en varias entidades del juego (comandos, salidas,
objetos) y determinar si un personaje tiene permiso para realizar una acci√≥n.

Actualmente, solo implementa la funci√≥n de lock `rol()`, pero est√° dise√±ado
para ser f√°cilmente expandible con funciones m√°s complejas como `habilidad()`,
`tiene_objeto()`, etc.
"""

import logging
from src.models.character import Character


def _check_role(character: Character, required_role: str) -> bool:
    """
    Funci√≥n de lock interna: Verifica si el personaje tiene el rol requerido.
    Compara de forma insensible a may√∫sculas.
    """
    if not character or not character.account:
        return False
    return character.account.role.upper() == required_role.upper()


async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Eval√∫a un `lock_string` contra un personaje para ver si puede pasar el lock.

    Args:
        character (Character): El personaje que intenta la acci√≥n.
        lock_string (str): La cadena de permisos a evaluar (ej: "rol(ADMINISTRADOR)").

    Returns:
        tuple[bool, str]: Una tupla conteniendo:
                          - `True` si puede pasar, `False` si no.
                          - Una cadena con el mensaje de error si falla, o vac√≠a si tiene √©xito.
    """
    try:
        # Un lock vac√≠o siempre se puede pasar. Es la forma de definir una acci√≥n "p√∫blica".
        if not lock_string:
            return True, ""

        # Por ahora, el parser es simple y solo soporta la l√≥gica 'Y' (AND).
        # "rol(A) y tiene_objeto(B)" se divide en una lista de dos funciones.
        lock_functions = lock_string.lower().split(' y ')

        for func_str in lock_functions:
            # Futuro: Aqu√≠ ir√≠a un parser m√°s avanzado para manejar funciones
            # con argumentos y operadores l√≥gicos complejos.

            # Implementaci√≥n actual: `rol(argumento)`
            if func_str.startswith('rol(') and func_str.endswith(')'):
                required_role = func_str[4:-1]
                if not _check_role(character, required_role):
                    return False, "No tienes el rango necesario para hacer eso."

            # Si encontramos una funci√≥n de lock que no entendemos, por seguridad, denegamos el acceso.
            else:
                logging.warning(f"Funci√≥n de lock desconocida encontrada: {func_str} en lock string: '{lock_string}'")
                return False, "Esa acci√≥n est√° bloqueada por una fuerza desconocida."

        # Si el personaje pas√≥ todos los chequeos de la cadena, tiene permiso.
        return True, ""

    except Exception:
        logging.exception(f"Error al parsear el lock_string: '{lock_string}'")
        # En caso de cualquier error de parseo, siempre fallamos de forma segura.
        return False, "Error interno al comprobar los permisos."
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Jugadores y Personajes.

Este es uno de los servicios centrales de la aplicaci√≥n. Encapsula toda la
l√≥gica de negocio para crear, recuperar y modificar las entidades `Account` y
`Character`.

Act√∫a como la √∫nica capa que interact√∫a directamente con los modelos de jugador,
asegurando que toda la l√≥gica de negocio est√© centralizada y sea consistente.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.services import channel_service, command_service


async def get_character_with_relations_by_id(session: AsyncSession, character_id: int) -> Character | None:
    """
    Busca un personaje por su ID y carga expl√≠citamente todas sus relaciones
    cr√≠ticas (sala, inventario, cuenta, configuraciones) en una sola consulta.

    Esta es una funci√≥n de ayuda crucial para evitar errores de "carga perezosa"
    (lazy loading) en un entorno as√≠ncrono.
    """
    try:
        query = (
            select(Character)
            .where(Character.id == character_id)
            .options(
                selectinload(Character.room).selectinload(Room.items),
                selectinload(Character.room).selectinload(Room.exits_from),
                selectinload(Character.items),
                selectinload(Character.account),
                selectinload(Character.settings)
            )
        )
        result = await session.execute(query)
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al obtener el personaje completo con ID {character_id}")
        return None

async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Garantiza que el objeto `Account` devuelto contenga un `Character` completamente
    cargado si este existe.
    """
    try:
        # 1. Buscar la cuenta y su personaje asociado.
        account_query = select(Account).where(Account.telegram_id == telegram_id).options(selectinload(Account.character))
        result = await session.execute(account_query)
        account = result.scalar_one_or_none()

        # 2. Si la cuenta no existe, crearla y devolverla.
        if not account:
            logging.info(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
            new_account = Account(telegram_id=telegram_id)
            session.add(new_account)
            await session.commit()
            await session.refresh(new_account)
            return new_account

        # 3. Si la cuenta existe pero no tiene personaje, devolverla tal cual.
        if not account.character:
            return account

        # 4. Si la cuenta y el personaje existen, usar nuestra funci√≥n de ayuda para
        #    asegurarnos de que el personaje est√° completamente cargado con todas sus relaciones.
        full_character = await get_character_with_relations_by_id(session, account.character.id)
        account.character = full_character
        return account
    except Exception:
        logging.exception(f"Error al obtener o crear la cuenta para telegram_id {telegram_id}")
        # En caso de un fallo cr√≠tico, es m√°s seguro devolver None.
        return None

async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje, lo asocia a una cuenta, y dispara los hooks de bienvenida.
    """
    account = await get_or_create_account(session, telegram_id)
    if not account:
        raise RuntimeError("No se pudo obtener o crear una cuenta de usuario.")

    # Validaciones de negocio
    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya est√° en uso. Por favor, elige otro.")

    # Creaci√≥n y persistencia
    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1 # Asigna a la sala de inicio "limbo"
    )
    session.add(new_character)
    await session.commit()

    # Recargamos el personaje por completo para tener todas las relaciones disponibles.
    full_character = await get_character_with_relations_by_id(session, new_character.id)
    if not full_character:
        raise RuntimeError("No se pudo recargar el personaje reci√©n creado.")

    # Hooks de post-creaci√≥n
    await channel_service.get_or_create_settings(session, full_character)
    welcome_message = (
        f"¬°Bienvenido al mundo, {full_character.name}! "
        "Usa los comandos de movimiento como <b>/norte</b> o <b>/sur</b> para explorar. "
        "Si necesitas ayuda, puedes preguntar en este canal usando <b>/novato [tu pregunta]</b>. "
        "Para una lista de comandos m√°s detallada, escribe <b>/ayuda</b>."
    )
    await channel_service.broadcast_to_channel(session, "novato", welcome_message)

    await command_service.update_telegram_commands(full_character)

    return full_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala actualizando su `room_id`."""
    # Validaci√≥n: asegurar que la sala de destino existe.
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    # Actualizaci√≥n at√≥mica
    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py
"""
M√≥dulo de Servicio para la Ejecuci√≥n de Scripts.

Este servicio act√∫a como el "traductor" entre el contenido del juego (definido
como strings en los archivos de prototipos) y la l√≥gica del motor (c√≥digo Python).
Permite que los dise√±adores de contenido invoquen funcionalidades del motor
sin necesidad de escribir c√≥digo.

Funciona con un sistema de registro:
1.  Las funciones de script se definen en este archivo.
2.  Se registran en el diccionario `SCRIPT_REGISTRY` con un nombre √∫nico.
3.  Los archivos de prototipos en `game_data` usan ese nombre para referirse a ellas.
4.  El m√©todo `execute_script` se encarga de parsear el string, buscar la
    funci√≥n en el registro y ejecutarla con el contexto adecuado.
"""

import re
import random
import logging
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.character import Character
from src.models.item import Item
from src.models.room import Room
from src.services import broadcaster_service


# ==============================================================================
# SECCI√ìN 1: DEFINICIONES DE LAS FUNCIONES DE SCRIPT
#
# Cada funci√≥n aqu√≠ es una "habilidad" que el motor ofrece a los dise√±adores
# de contenido. Deben ser gen√©ricas y reutilizables.
# ==============================================================================

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Notifica al jugador que un objeto brilla al ser mirado.

    - Disparador T√≠pico: `on_look` en un prototipo de objeto.
    - Contexto Esperado: `character` (quien mira), `target` (el objeto mirado).
    - Argumentos: `color` (str, opcional) - el color del brillo.
    """
    color = kwargs.get("color", "una luz misteriosa")
    message = f"üåü Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."
    await broadcaster_service.send_message_to_character(character, message)


async def script_espada_susurra_secreto(session: AsyncSession, target: Item, character: Character, **kwargs):
    """
    Script de ticker: Hace que un objeto emita un susurro a un personaje activo
    que se encuentre en la misma sala.

    - Disparador T√≠pico: `tickers` en un prototipo de objeto.
    - Contexto Esperado: `target` (el objeto que susurra), `character` (el jugador que escucha).
    - Argumentos: Ninguno.
    """
    secretos = [
        "El tesoro se encuentra bajo la sombra del roble marchito...",
        "La llave oxidada no abre una puerta, sino un coraz√≥n...",
        "Cuidado con el que no proyecta sombra...",
    ]
    secreto_elegido = random.choice(secretos)
    mensaje = f"<i>Un susurro escalofriante parece emanar de {target.get_name()}: \"{secreto_elegido}\"</i>"
    await broadcaster_service.send_message_to_character(character, mensaje)


# ==============================================================================
# SECCI√ìN 2: REGISTRO DE SCRIPTS
#
# Este diccionario es el puente entre los nombres de los scripts (strings)
# y las funciones de Python reales. Para que un script pueda ser llamado
# desde `game_data`, DEBE estar registrado aqu√≠.
# ==============================================================================

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,
    # Futuros scripts se a√±adir√≠an aqu√≠.
}


# ==============================================================================
# SECCI√ìN 3: EL MOTOR DE EJECUCI√ìN
#
# L√≥gica interna del servicio para interpretar y ejecutar los scripts.
# ==============================================================================

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre(clave=valor, ...)' y devuelve
    el nombre de la funci√≥n y un diccionario de argumentos.

    Limitaci√≥n actual: solo soporta argumentos simples de tipo `clave=valor`.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        # Si el script no tiene par√©ntesis, se asume que no tiene argumentos.
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            logging.warning(f"Argumentos de script mal formados en '{script_string}'. Ignorando argumentos.")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El coraz√≥n del motor de scripts. Parsea el string, busca la funci√≥n en
    el registro y la ejecuta con el contexto proporcionado.

    Args:
        script_string (str): El string del script a ejecutar (ej: "mi_script(arg=val)").
        session (AsyncSession): La sesi√≥n de base de datos activa.
        **context: Un diccionario con las entidades relevantes al evento
                   (ej: `character`, `target`, `room`).
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        try:
            # Ejecutamos la funci√≥n encontrada, pasando el contexto y los argumentos parseados.
            await script_function(session=session, **context, **kwargs)
        except Exception:
            # Si un script falla, registramos el error con un traceback completo
            # pero no detenemos la ejecuci√≥n del resto del juego.
            logging.exception(f"Ocurri√≥ un error al ejecutar el script '{script_name}'")
    else:
        logging.warning(f"ADVERTENCIA: Se intent√≥ ejecutar un script desconocido: '{script_name}'")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/ticker_service.py ===
# src/services/ticker_service.py
"""
M√≥dulo de Servicio para Tareas Programadas (Tickers).

Este servicio es el "coraz√≥n" que hace que el mundo de Runegram se sienta vivo.
Utiliza la librer√≠a APScheduler para ejecutar scripts de forma peri√≥dica,
independientemente de las acciones de los jugadores.

Responsabilidades:
- Inicializar y configurar el scheduler global (APScheduler).
- Cargar las definiciones de tickers desde los prototipos de `game_data`.
- Programar, ejecutar y gestionar el ciclo de vida de estas tareas.
- Determinar el contexto correcto para un ticker (ej: la sala de un objeto)
  y filtrar su ejecuci√≥n (ej: solo para jugadores activos).
"""

import logging
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.db import async_session_factory
from src.services import script_service, online_service, player_service
from src.models import Item, Room, Character

# Instancia √∫nica del scheduler para toda la aplicaci√≥n.
scheduler = AsyncIOScheduler()


# ==============================================================================
# SECCI√ìN DE FUNCIONES AUXILIARES
# ==============================================================================

def parse_schedule(schedule_str: str) -> tuple[str, dict]:
    """
    Parsea el string de schedule del prototipo y lo convierte en argumentos para APScheduler.
    """
    if schedule_str.startswith("interval:"):
        seconds = int(schedule_str.split(':')[1])
        return 'interval', {'seconds': seconds}
    if schedule_str.startswith("date:"):
        date_val = schedule_str.split(':', 1)[1]
        return 'date', {'run_date': date_val}
    cron_expr = schedule_str
    if schedule_str.startswith("cron:"):
        cron_expr = schedule_str.split(':', 1)[1]
    parts = cron_expr.strip().split()
    if len(parts) != 5:
        logging.warning(f"ADVERTENCIA: Expresi√≥n cron mal formada en '{schedule_str}'. Se ignora.")
        return 'cron', {}
    cron_args = { 'minute': parts[0], 'hour': parts[1], 'day': parts[2], 'month': parts[3], 'day_of_week': parts[4] }
    return 'cron', cron_args


async def get_entity_by_id(session: AsyncSession, entity_id: int, entity_type: str):
    """
    Busca una entidad por su ID y tipo, cargando expl√≠citamente las relaciones
    necesarias para evitar errores de carga perezosa.
    """
    MODEL_MAP = {"Item": Item, "Room": Room, "Character": Character}
    model_class = MODEL_MAP.get(entity_type)
    if not model_class:
        logging.warning(f"ADVERTENCIA: Tipo de entidad desconocido '{entity_type}' para ticker.")
        return None

    query = select(model_class)
    if model_class is Item:
        query = query.options(
            selectinload(Item.room),
            selectinload(Item.character).selectinload(Character.room)
        )
    elif model_class is Character:
        query = query.options(selectinload(Character.room), selectinload(Character.account))

    query = query.where(model_class.id == entity_id)
    result = await session.execute(query)
    return result.scalar_one_or_none()


# ==============================================================================
# SECCI√ìN DE INICIALIZACI√ìN Y CARGA
# ==============================================================================

def initialize_scheduler():
    """Configura y arranca el scheduler global. Debe llamarse al iniciar el bot."""
    jobstores = {'default': SQLAlchemyJobStore(url=settings.sync_database_url)}
    scheduler.configure(jobstores=jobstores)
    scheduler.start()
    logging.info("‚è∞ Ticker Service iniciado y listo para programar tareas.")

async def load_and_schedule_all_tickers(session: AsyncSession):
    """
    Busca todas las entidades con tickers en la base de datos (actualmente solo Items)
    y las programa. Debe llamarse una vez al iniciar el bot para asegurar la persistencia.
    """
    logging.info("Cargando y programando tickers para todas las entidades existentes...")
    try:
        result = await session.execute(select(Item))
        all_items = result.scalars().all()
        for item in all_items:
            if item.prototype.get("tickers"):
                logging.info(f"  -> Programando tickers para el item '{item.key}' (ID: {item.id})")
                await schedule_tickers_for_entity(item)
        logging.info("Carga de tickers existentes finalizada.")
    except Exception:
        logging.exception("Error al cargar los tickers de entidades existentes.")


# ==============================================================================
# SECCI√ìN DE EJECUCI√ìN DE TAREAS
# ==============================================================================

async def schedule_tickers_for_entity(entity):
    """
    Lee los tickers del prototipo de una entidad y los a√±ade al scheduler.
    """
    prototype_tickers = entity.prototype.get("tickers", [])
    for ticker_data in prototype_tickers:
        schedule_str = ticker_data.get("schedule")
        script_str = ticker_data.get("script")
        category = ticker_data.get("category", "ambient")

        if not schedule_str or not script_str:
            continue
        trigger_type, trigger_args = parse_schedule(schedule_str)
        if not trigger_args:
            continue

        job_id = f"ticker_{type(entity).__name__}_{entity.id}_{schedule_str}_{script_str}"
        scheduler.add_job(
            execute_ticker_script, trigger=trigger_type,
            args=[entity.id, type(entity).__name__, script_str, category],
            id=job_id, replace_existing=True, **trigger_args
        )

async def execute_ticker_script(entity_id: int, entity_type: str, script_string: str, category: str):
    """
    Funci√≥n que APScheduler llama. Prepara el contexto, comprueba la actividad
    del jugador y delega la ejecuci√≥n al script_service.
    """
    async with async_session_factory() as session:
        try:
            entity = await get_entity_by_id(session, entity_id, entity_type)
            if not entity: return

            # 1. Determinar la sala de contexto del ticker.
            room = None
            if hasattr(entity, 'room') and entity.room:
                room = entity.room
            elif hasattr(entity, 'character') and entity.character and entity.character.room:
                room = entity.character.room

            if not room: return

            # 2. Encontrar los IDs de los personajes en esa sala.
            char_ids_query = select(Character.id).where(Character.room_id == room.id)
            result = await session.execute(char_ids_query)
            char_ids_in_room = result.scalars().all()

            # 3. Iterar sobre cada personaje, aplicar filtros y ejecutar el script.
            for char_id in char_ids_in_room:
                is_online = await online_service.is_character_online(char_id)
                if category == "ambient" and not is_online:
                    continue

                full_character = await player_service.get_character_with_relations_by_id(session, char_id)
                if not full_character:
                    continue

                context = {
                    "target": entity,
                    "room": full_character.room,
                    "character": full_character
                }

                await script_service.execute_script(
                    script_string=script_string,
                    session=session,
                    **context
                )
        except Exception:
            logging.exception(f"Error cr√≠tico en la ejecuci√≥n del ticker para {entity_type} {entity_id}")
# === FIN: src/services/ticker_service.py ===


# === INICIO: src/services/world_loader_service.py ===
# src/services/world_loader_service.py
"""
M√≥dulo de Servicio para la Carga del Mundo.

Este servicio es el responsable de construir y sincronizar el mundo est√°tico del
juego (salas y salidas) con la base de datos. Se ejecuta una sola vez durante
el arranque de la aplicaci√≥n.

Lee las definiciones de contenido desde `game_data/room_prototypes.py` y se
asegura de que el estado de la base de datos refleje fielmente esa "fuente de
la verdad".
"""

import logging
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Room, Exit
from game_data.room_prototypes import ROOM_PROTOTYPES

# Mapa de direcciones opuestas para crear autom√°ticamente las salidas bidireccionales.
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def sync_world_from_prototypes(session: AsyncSession):
    """
    Sincroniza la base de datos con los prototipos de salas. Esta funci√≥n es
    idempotente: se puede ejecutar de forma segura en cada arranque.

    Su l√≥gica es:
    1. Crea las salas que no existen y actualiza los datos de las que s√≠ existen.
    2. Borra por completo todas las salidas existentes.
    3. Recrea todas las salidas bas√°ndose en las definiciones actuales.
    """
    logging.info("Sincronizando el mundo est√°tico desde los prototipos...")
    try:
        # --- PASO 1: Sincronizar Salas ---
        # Se asegura de que todas las salas definidas en los prototipos existan en la BD
        # y actualiza su nombre/descripci√≥n. Guarda un mapa de `key` a `id` para el siguiente paso.
        room_key_to_id_map = {}

        # Obtenemos todas las salas existentes de la BD para compararlas.
        existing_rooms_query = await session.execute(select(Room))
        existing_rooms = {room.key: room for room in existing_rooms_query.scalars().all()}

        for key, data in ROOM_PROTOTYPES.items():
            room = existing_rooms.get(key)
            if not room:
                # La sala no existe en la BD, la creamos.
                logging.info(f"  -> Creando sala '{key}'...")
                room = Room(key=key, name=data['name'], description=data['description'])
                session.add(room)
            else:
                # La sala ya existe, actualizamos sus datos por si cambiaron.
                room.name = data['name']
                room.description = data['description']

            # `flush` env√≠a los cambios a la BD sin cerrar la transacci√≥n, lo que
            # nos permite obtener el ID de las nuevas salas antes del commit final.
            await session.flush()
            room_key_to_id_map[key] = room.id

        # --- PASO 2: Limpiar Salidas Viejas ---
        # Es m√°s simple y seguro borrar todas las salidas y recrearlas que intentar
        # parchear las existentes. Esto asegura que las salidas eliminadas de los
        # prototipos tambi√©n se eliminen de la BD.
        logging.info("  -> Limpiando todas las salidas existentes para reconstruir...")
        await session.execute(delete(Exit))

        # --- PASO 3: Crear Salidas Nuevas ---
        # Itera de nuevo sobre los prototipos y crea las filas en la tabla `exits`.
        for key, data in ROOM_PROTOTYPES.items():
            from_room_id = room_key_to_id_map[key]
            for direction, to_room_key in data.get("exits", {}).items():
                if to_room_key in room_key_to_id_map:
                    to_room_id = room_key_to_id_map[to_room_key]

                    # Crear la salida principal (ej: A -> B, "norte")
                    exit_forward = Exit(name=direction.lower(), from_room_id=from_room_id, to_room_id=to_room_id)
                    session.add(exit_forward)

                    # Crear la salida de vuelta autom√°ticamente (ej: B -> A, "sur")
                    opposite = OPPOSITE_DIRECTIONS.get(direction.lower())
                    if opposite:
                        exit_backward = Exit(name=opposite, from_room_id=to_room_id, to_room_id=from_room_id)
                        session.add(exit_backward)
                else:
                    logging.warning(f"  -> La sala de destino '{to_room_key}' definida en la sala '{key}' no existe. Se ignora la salida.")

        await session.commit()
        logging.info("¬°Sincronizaci√≥n del mundo completada!")
    except Exception:
        # Un fallo aqu√≠ es cr√≠tico para el arranque del bot.
        logging.exception("Error fatal durante la sincronizaci√≥n del mundo.")
        # Relanzamos la excepci√≥n para que la funci√≥n on_startup la capture y detenga el bot.
        raise
# === FIN: src/services/world_loader_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py
"""
M√≥dulo de Servicio con Utilidades para el Mundo.

Este servicio contiene funciones de ayuda de bajo nivel para interactuar
con las entidades del mundo, principalmente el modelo `Room`.

A diferencia del `world_loader_service` que construye el mundo al arrancar,
las funciones aqu√≠ presentes son utilidades gen√©ricas que pueden ser llamadas
desde otras partes del c√≥digo, como los comandos.

NOTA: Varias funciones en este archivo (`create_room`, `link_rooms`) han quedado
obsoletas por el sistema de carga de mundo basado en prototipos, pero se
mantienen por si son de utilidad para futuras herramientas de administraci√≥n
o para depuraci√≥n.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit


async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """
    Busca y devuelve una sala por su ID num√©rico.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala a buscar.

    Returns:
        Room | None: El objeto de la sala si se encuentra, de lo contrario None.
    """
    try:
        result = await session.execute(select(Room).where(Room.id == room_id))
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al buscar la sala con ID {room_id}")
        return None

# ==============================================================================
# Las siguientes funciones han sido mayormente reemplazadas por el sistema de
# carga de mundo (`world_loader_service`) y ya no se usan en el flujo principal.
# Se conservan para posible uso futuro en herramientas de administraci√≥n.
# ==============================================================================

async def create_room(session: AsyncSession, name: str) -> Room:
    """
    (Obsoleto) Crea una nueva sala en la base de datos.
    """
    if not name:
        raise ValueError("El nombre de la sala no puede estar vac√≠o.")
    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """
    (Obsoleto) Actualiza la descripci√≥n de una sala existente.
    """
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """
    (Obsoleto) Crea una salida (y opcionalmente su opuesta) entre dos salas.
    """
    # Mapa de direcciones opuestas, duplicado aqu√≠ para que la funci√≥n sea aut√≥noma.
    OPPOSITE_DIRECTIONS = {
        "norte": "sur", "sur": "norte", "este": "oeste", "oeste": "este",
        "arriba": "abajo", "abajo": "arriba", "dentro": "fuera", "fuera": "dentro",
        "noreste": "suroeste", "suroeste": "noreste", "noroeste": "sureste", "sureste": "noroeste",
    }

    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===
# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py
"""
M√≥dulo de Utilidades de Presentaci√≥n (Presenters).

Este archivo contiene funciones cuya √∫nica responsabilidad es tomar los objetos
de datos del juego (como `Room`, `Item`, `Character`) y convertirlos en texto
formateado listo para ser mostrado al jugador en Telegram.

Esta capa de "presentaci√≥n" separa la l√≥gica de c√≥mo se ven las cosas (formato
HTML, colores, etc.) de la l√≥gica de negocio del juego (que reside en los
servicios).
"""

import logging
from aiogram import types
from collections import Counter

from src.models.room import Room
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripci√≥n completa de una sala para ser
    mostrada al jugador.

    Args:
        room (Room): El objeto de la sala a formatear, con sus relaciones
                     (`items`, `exits_from`) ya cargadas.

    Returns:
        str: Un string formateado con HTML (`<pre>`, `<b>`) listo para ser enviado.
    """
    try:
        parts = []

        # 1. T√≠tulo de la Sala
        parts.append(f"<b>{room.name}</b>")

        # 2. Descripci√≥n principal
        parts.append(room.description.strip())

        # 3. Objetos en la sala
        if room.items:
            # Usamos `collections.Counter` para agrupar objetos id√©nticos.
            # Por ejemplo, tres objetos con `get_name()`="una moneda de oro"
            # se mostrar√°n como "una moneda de oro (3)".
            item_names = [item.get_name() for item in room.items]
            item_counts = Counter(item_names)
            formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
            items_str = ", ".join(formatted_items)
            parts.append(f"\n<b>Ves aqu√≠:</b> {items_str}.")

        # 4. Salidas
        if room.exits_from:
            # Ordenamos las salidas alfab√©ticamente para una visualizaci√≥n consistente.
            exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
            exits_str = ", ".join(exits_list)
            parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
        else:
            parts.append("\n<b>Salidas:</b> [ Ninguna ]")

        # Unimos todas las partes y las envolvemos en una etiqueta <pre>
        # para mantener el formato de monoespaciado y los saltos de l√≠nea.
        description_body = "\n".join(parts)
        return f"<pre>{description_body}</pre>"

    except Exception:
        logging.exception(f"Error al formatear la descripci√≥n de la sala ID {room.id}")
        return "<pre><b>Error:</b> No se pudo mostrar la descripci√≥n de la sala.</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripci√≥n formateada.
    Esta funci√≥n centraliza la l√≥gica com√∫n de "mirar" el entorno.
    """
    try:
        async with async_session_factory() as session:
            # Usamos el servicio para obtener la cuenta y sus relaciones precargadas.
            account = await player_service.get_or_create_account(session, message.from_user.id)

            if not account or not account.character or not account.character.room:
                # Esta es una salvaguarda. No deber√≠a ocurrir en un flujo normal.
                await message.answer("Parece que est√°s perdido en el vac√≠o. Te hemos llevado a un lugar seguro.")
                # Futuro: Aqu√≠ podr√≠amos teletransportar al jugador a la sala de inicio.
                return

            room = account.character.room
            # Usamos nuestro formateador para construir el texto de la sala.
            formatted_room = await format_room(room)

            await message.answer(formatted_room, parse_mode="HTML")

    except Exception:
        await message.answer("‚ùå Ocurri√≥ un error al mostrar tu ubicaci√≥n actual.")
        logging.exception(f"Fallo en show_current_room para el usuario {message.from_user.id}")
# === FIN: src/utils/presenters.py ===


