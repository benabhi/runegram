# === INICIO: .gitignore ===
project_snapshot.txt
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¡Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Caché de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Caché de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querrás subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de código
# Configuraciones específicas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena práctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: Dockerfile ===
# Dockerfile para la Aplicación Runegram MUD
#
# Este archivo define los pasos para construir la imagen Docker que contendrá
# y ejecutará la aplicación del bot. Docker utiliza esta "receta" para crear un
# entorno autocontenido y reproducible.
#
# El proceso de construcción sigue estos pasos:
# 1. FROM: Se parte de una imagen base oficial de Python sobre Alpine Linux.
# 2. RUN (apk): Se instalan las dependencias a nivel de sistema operativo que
#    necesita nuestra aplicación (ej: librerías de PostgreSQL, herramientas de red).
# 3. WORKDIR: Se establece el directorio de trabajo dentro del contenedor.
# 4. COPY / RUN (pip): Se copia primero el archivo de dependencias de Python y se
#    instalan. Este paso se hace por separado para aprovechar la caché de Docker.
#    Si el `requirements.txt` no cambia, Docker no volverá a ejecutar este paso,
#    acelerando construcciones futuras.
# 5. COPY (código fuente): Se copia el resto del código de la aplicación.
# 6. CMD: Se define el comando por defecto que se ejecutará al iniciar el contenedor,
#    el cual es interceptado y gestionado por nuestro `entrypoint.sh`.

# 1. Imagen Base
# Usamos la imagen oficial de Python 3.11 basada en Alpine Linux.
# Alpine es una distribución muy ligera, lo que resulta en una imagen final más pequeña.
FROM python:3.11-alpine

# 2. Dependencias del Sistema
# Usamos el gestor de paquetes de Alpine (`apk`) para instalar software necesario.
# --no-cache: No guarda el índice de paquetes, manteniendo la imagen ligera.
# - postgresql-libs: Librerías C requeridas por el driver `psycopg2-binary`.
# - netcat-openbsd: Herramienta de red utilizada en `entrypoint.sh` para esperar a PostgreSQL.
# - git: Puede ser útil para instalar dependencias de Python directamente desde repositorios.
RUN apk add --no-cache postgresql-libs netcat-openbsd git

# 3. Directorio de Trabajo
# Establece el directorio de trabajo por defecto dentro del contenedor.
# Todos los comandos `RUN`, `CMD`, `ENTRYPOINT`, `COPY` y `ADD` posteriores
# se ejecutarán en este directorio.
WORKDIR /app

# 4. Dependencias de Python
# Copiamos solo el archivo de requerimientos primero. Esto es una optimización
# de la caché de Docker. Si nuestro código cambia pero `requirements.txt` no,
# Docker reutilizará la capa de imagen ya existente donde se instalaron las
# dependencias, haciendo que la reconstrucción sea mucho más rápida.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. Código Fuente de la Aplicación
# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable.
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

# Copiamos el resto del código fuente del proyecto al directorio de trabajo (`/app`).
COPY . .

# 6. Comando de Ejecución
# Define el comando por defecto que se ejecutará al iniciar un contenedor
# a partir de esta imagen.
# IMPORTANTE: Este comando se pasa como argumento a nuestro `entrypoint.sh`
# (definido en `docker-compose.yml`), que lo ejecuta al final con `exec "$@"`.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: NOTAS.md ===
## Telegram

### Mi ID de usuario (benabbhi)

1648877346

## Postgres

### Conectarse

```shell
docker-compose exec postgres psql -U runegram -d runegram_db
```
### Ver tablas

```
\dt
```

## Docker

### Prune

```shell
docker system prune -a --volumes
```

## TODO

* Las salas no muestran los objetos caidos
* Como se determina que comando le corresponde a quie?
* No se actualizan ambos extremos de las salidas
# === FIN: NOTAS.md ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

**Runegram** es un motor de juego de rol textual multijugador (MUD - Multi-User Dungeon) diseñado para ser jugado a través de la interacción con un bot de Telegram. Este repositorio contiene el código fuente de un motor de juego funcional, construido con una arquitectura moderna, escalable y centrada en la separación entre la lógica del motor y el contenido del juego.

Este documento es una guía de inicio rápido. Para una documentación exhaustiva sobre la arquitectura, los sistemas del motor y las guías de creación de contenido, por favor, consulta la **[Documentación Completa](./docs/)**.

---

## Filosofía de Diseño

### Motor vs. Contenido
La arquitectura del proyecto se divide en dos conceptos clave para máxima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **código fuente** en **inglés**. Es la maquinaria genérica que hace que el juego funcione. No sabe qué es una "espada", solo sabe cómo manejar un `Item`.
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** en **español** (o el idioma del juego). Aquí se define qué es una "espada", qué hace el comando `/atacar`, etc.

### Filosofía de Comandos
Los comandos en Runegram buscan ser simples, descriptivos e intuitivos. Se prefiere la claridad de tener más comandos dedicados (ej: `/activarcanal`, `/desactivarcanal`) a la complejidad de un único comando con múltiples subcomandos. El formato preferido es `/<acción> [argumentos]`.

Además, el motor del juego genera dinámicamente comandos de comunicación a partir del contenido definido en `game_data`. Si un diseñador crea un nuevo canal de chat llamado "Comercio" (`comercio`), el comando `/comercio [mensaje]` estará disponible automáticamente para los jugadores.

---

## Puesta en Marcha Rápida

**Requisitos:**
*   [Docker](https://www.docker.com/products/docker-desktop/) y Docker Compose.

**Pasos:**

1.  **Clona el Repositorio** y entra en el directorio.
2.  **Configura el Entorno:** Crea un archivo `.env` en la raíz del proyecto y rellena las variables, especialmente `BOT_TOKEN` y `SUPERADMIN_TELEGRAM_ID`.
3.  **Ejecuta el Script de Reinicio:**
    ```bash
    # En Windows (CMD o PowerShell)
    scripts\full_reset.bat
    ```
4.  **¡A Jugar!** Abre Telegram y envía `/start` a tu bot.

---

## Documentación Detallada

Toda la documentación exhaustiva sobre la arquitectura, los sistemas del motor, las guías para crear contenido y la visión a futuro del proyecto se encuentra en la carpeta `docs/`.

**[➡️ Acceder a la Documentación Completa](./docs/01_GETTING_STARTED.md)**
# === FIN: README.md ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCIÓN PRINCIPAL DE ALEMBIC
# Aquí se definen las configuraciones más importantes.
# ==============================================================================
[alembic]

# --- Ubicación de los Scripts de Migración ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la raíz del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA LÍNEA MÁS IMPORTANTE.
# Le dice a Alembic cómo conectarse a tu base de datos PostgreSQL.
# La magia aquí es que no ponemos la contraseña directamente.
# El archivo `alembic/env.py` se encargará de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define cómo se nombran los nuevos archivos de migración.
# {rev} es el ID de la revisión, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos después de que se genera un nuevo archivo de migración.
# Es muy útil para formatear automáticamente el código con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACIÓN DE LOGGING
# Define cómo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aquí, la configuración por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml
#
# Este archivo es la pieza central para orquestar los diferentes servicios
# (contenedores) que componen la aplicación Runegram. Docker Compose lee
# este archivo para construir, iniciar, conectar y gestionar todos los
# contenedores de forma conjunta.
#
# Servicios definidos:
# 1. bot:       El contenedor principal de la aplicación Python que ejecuta el bot de Telegram.
# 2. postgres:  El servicio de base de datos PostgreSQL.
# 3. redis:     El servicio de caché en memoria, utilizado para la gestión de estados
#               de Aiogram y el seguimiento de actividad de los jugadores.

services:
  # --- Servicio de la Aplicación Principal del Bot ---
  bot:
    # `build: .` le dice a Docker Compose que construya una imagen para este servicio
    # utilizando el Dockerfile que se encuentra en el directorio actual ('.').
    build: .

    # `entrypoint`: Sobrescribe el ENTRYPOINT por defecto de la imagen. Aquí especificamos
    # nuestro script `entrypoint.sh`, que se encargará de las tareas de preparación
    # (esperar a la BD, ejecutar migraciones) antes de lanzar la aplicación principal.
    entrypoint: /app/entrypoint.sh

    # `command`: Especifica el comando que se pasa como argumento al `entrypoint`.
    # Nuestro `entrypoint.sh` ejecuta este comando al final con `exec "$@"`.
    command: python run.py

    # `environment`: Define variables de entorno dentro del contenedor.
    # `PYTHONPATH=/app` asegura que Python pueda encontrar nuestros módulos en `src/`.
    environment:
      - PYTHONPATH=/app

    # `env_file`: Carga las variables de entorno desde el archivo `.env` en la raíz
    # del proyecto. Esto mantiene las credenciales y configuraciones fuera del código.
    env_file:
      - .env

    # `depends_on`: Asegura que los servicios `postgres` y `redis` se inicien
    # *antes* de que se inicie el servicio `bot`. No garantiza que estén "listos",
    # por eso nuestro `entrypoint.sh` se encarga de esperar activamente.
    depends_on:
      - postgres
      - redis

    # `volumes`: Mapea directorios de nuestra máquina local al interior del contenedor.
    # Esto es crucial para el desarrollo, ya que cualquier cambio en nuestro código
    # se refleja instantáneamente dentro del contenedor sin necesidad de reconstruir la imagen.
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      - ./entrypoint.sh:/app/entrypoint.sh

  # --- Servicio de la Base de Datos ---
  postgres:
    # `image`: Utiliza una imagen preconstruida oficial de PostgreSQL desde Docker Hub.
    # La etiqueta `:15-alpine` especifica la versión 15 sobre Alpine Linux, que es ligera.
    image: postgres:15-alpine

    # `environment`: Configura las credenciales y el nombre de la base de datos
    # inicial. Los valores `${...}` se leen del archivo `.env` en nuestra máquina.
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}

    # `volumes`: Mapea un "volumen nombrado" de Docker (`postgres_data`) al directorio
    # donde PostgreSQL guarda sus datos. Esto hace que los datos de la base de datos
    # sean persistentes, sobreviviendo a reinicios o eliminaciones del contenedor.
    volumes:
      - postgres_data:/var/lib/postgresql/data/

    # `ports`: Mapea el puerto 5432 del contenedor al puerto 5432 de nuestra máquina local.
    # Esto nos permite conectarnos a la base de datos desde herramientas locales si es necesario.
    ports:
      - "5432:5432"

  # --- Servicio de Caché en Memoria ---
  redis:
    # Utiliza la imagen oficial de Redis, versión 7 sobre Alpine.
    image: redis:7-alpine

    # Mapea el puerto por defecto de Redis para permitir conexiones locales.
    ports:
      - "6379:6379"

# Define los volúmenes nombrados que hemos utilizado. Docker se encarga de gestionarlos.
volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: entrypoint.sh ===
#!/bin/sh
#
# Entrypoint para el Contenedor de la Aplicación Runegram
#
# Este script se ejecuta cada vez que el contenedor de la aplicación ('bot') se inicia.
# Su principal responsabilidad es preparar el entorno antes de lanzar la aplicación
# de Python principal.
#
# Tareas:
# 1. Esperar a que el servicio de PostgreSQL esté completamente disponible y acepte conexiones.
#    Esto evita que la aplicación falle al arrancar si el contenedor de la base de datos
#    tarda más en iniciarse.
# 2. Ejecutar las migraciones de la base de datos con Alembic para asegurar que el
#    esquema de la base de datos esté actualizado con la última versión del código.
# 3. Ejecutar el comando principal del contenedor (CMD), que en nuestro caso es
#    `python run.py`, para iniciar el bot.
#
# `set -e`: Este comando es crucial. Asegura que el script se detenga inmediatamente
# si cualquier comando falla (devuelve un código de salida distinto de cero).
#
set -e

# --- PASO 1: Esperar a PostgreSQL ---
echo "--- [Entrypoint] Esperando a que PostgreSQL esté disponible... ---"
# El host 'postgres' es el nombre del servicio definido en docker-compose.yml.
# El comando `nc -z` (netcat) intenta establecer una conexión sin enviar datos.
# El bucle `while` se repetirá hasta que el puerto 5432 de 'postgres' esté abierto.
while ! nc -z postgres 5432; do
  sleep 0.1
done
echo "--- [Entrypoint] ✅ PostgreSQL está listo. ---"


# --- PASO 2: Ejecutar Migraciones de la Base de Datos ---
echo "--- [Entrypoint] Ejecutando migraciones de la base de datos con Alembic... ---"
# `alembic upgrade head` aplica todas las migraciones pendientes desde la última
# versión registrada en la base de datos hasta la última versión en los archivos.
alembic upgrade head
echo "--- [Entrypoint] ✅ Migraciones completadas. ---"


# --- PASO 3: Ejecutar el Comando Principal ---
echo "--- [Entrypoint] Iniciando la aplicación principal del bot... ---"
# `exec "$@"` es una construcción de shell especial.
# 'exec' reemplaza el proceso actual del script con el nuevo comando, lo que es
# más eficiente y permite que las señales del sistema (como un 'docker stop')
# lleguen directamente a la aplicación de Python.
# `"$@"` expande todos los argumentos que se pasaron al script. En nuestro caso,
# `docker-compose.yml` pasa `python run.py`, por lo que este comando se convierte en
# `exec python run.py`.
exec "$@"
# === FIN: entrypoint.sh ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
APScheduler==3.10.1
python-dateutil
psycopg2-binary==2.9.9
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
"""
Punto de Entrada Principal de la Aplicación Runegram MUD.

Este script es el responsable de orquestar el arranque del bot. Sus tareas principales son:
1. Configurar el sistema de logging global para toda la aplicación.
2. Definir y registrar las funciones `on_startup` y `on_shutdown` que se ejecutarán
   al iniciar y detener el bot, respectivamente.
3. Iniciar el "polling" de Aiogram, que es el bucle principal que escucha los
   mensajes de Telegram.

Para ejecutar la aplicación, se llama a este script desde el `entrypoint.sh`
dentro del contenedor Docker.
"""

import logging
import asyncio
import sys
from aiogram import executor
from sqlalchemy import select

from src.bot.dispatcher import dp
from src.services import world_loader_service, ticker_service, online_service
from src.db import async_session_factory
from src.config import settings
from src.models import Account

# Esta importación es crucial para que los manejadores de mensajes se registren.
import src.handlers

async def _ensure_superadmin_exists(session):
    """
    Verifica que la cuenta del Superadmin (definida en .env) exista y tenga
    el rol correcto. La crea o actualiza si es necesario.

    Esta función de "autocorrección" se ejecuta en cada arranque para garantizar
    que el Superadmin siempre esté configurado correctamente, eliminando la
    necesidad de sembrar datos frágiles en las migraciones.
    """
    superadmin_id = settings.superadmin_telegram_id
    if not superadmin_id:
        logging.warning("No se ha definido un SUPERADMIN_TELEGRAM_ID en el archivo .env.")
        return

    result = await session.execute(select(Account).where(Account.telegram_id == superadmin_id))
    superadmin_account = result.scalar_one_or_none()

    if not superadmin_account:
        logging.info(f"Creando cuenta de Superadmin para el telegram_id: {superadmin_id}")
        superadmin_account = Account(telegram_id=superadmin_id, role="SUPERADMIN")
        session.add(superadmin_account)
        await session.commit()
    elif superadmin_account.role != "SUPERADMIN":
        logging.info(f"Actualizando cuenta {superadmin_id} al rol de Superadmin.")
        superadmin_account.role = "SUPERADMIN"
        await session.commit()
    else:
        logging.info("Cuenta de Superadmin verificada.")


async def on_startup(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se inicia con éxito.
    Inicializa todos los sistemas principales del juego.
    """
    logging.info("Iniciando secuencia de arranque del bot...")

    try:
        # 1. Inicia el scheduler. Es importante que se inicie antes de que cualquier
        #    otro servicio intente añadir tareas.
        ticker_service.initialize_scheduler()

        # 2. Crea una sesión de base de datos para las tareas de inicialización.
        async with async_session_factory() as session:
            # Asegura que la cuenta del Superadmin exista y tenga el rol correcto.
            await _ensure_superadmin_exists(session)

            # Sincroniza el mundo estático (salas, salidas) desde los archivos de prototipos.
            await world_loader_service.sync_world_from_prototypes(session)

            # Carga y programa los tickers de los objetos que ya existen en la base de datos.
            await ticker_service.load_and_schedule_all_tickers(session)

        # 3. Añade el ticker global para el chequeo de inactividad.
        ticker_service.scheduler.add_job(
            online_service.check_for_newly_afk_players,
            'interval',
            seconds=60,
            id="global_afk_check",
            replace_existing=True
        )
        logging.info("Ticker global para chequeo de AFK añadido.")

        logging.info("✅ Secuencia de arranque finalizada. El bot está en línea.")

    except Exception:
        # Si algo falla catastróficamente durante el arranque, lo registramos
        # y detenemos la aplicación para evitar un estado inconsistente.
        logging.exception("❌ Error fatal durante la secuencia de arranque. El bot se detendrá.")
        loop = asyncio.get_running_loop()
        loop.stop()


async def on_shutdown(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se detiene.
    Se asegura de que los servicios se apaguen de forma limpia.
    """
    logging.warning("Iniciando secuencia de apagado del bot...")
    if ticker_service.scheduler.running:
        ticker_service.scheduler.shutdown()
        logging.info("Scheduler detenido limpiamente.")
    logging.warning("Bot detenido.")


def main():
    """
    Configura el logging principal y arranca el bot.
    """
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s [%(levelname)s] - %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)


if __name__ == "__main__":
    main()
# === FIN: run.py ===


# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACIÓN DEL PATH ---
# Añade el directorio raíz del proyecto al sys.path para que Python
# pueda encontrar nuestros módulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACIÓN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneración
# y la configuración (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---
# Aquí sobrescribimos la URL de la base de datos que está en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuración de la aplicación.
# Esto centraliza la configuración y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Función auxiliar que Alembic ejecutará de forma síncrona
    una vez que la conexión asíncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor asíncrono
    # a partir de la URL de nuestra configuración.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma asíncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""Añadir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser más explícitos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # Nota: La columna 'exits' de tipo JSONB será eliminada por una migración posterior,
        # así que la dejamos aquí por ahora para mantener la consistencia histórica.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # Añadimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Rellenamos las filas existentes con un ID de sala por defecto (1).
    # Esto es necesario para que la siguiente línea (nullable=False) no falle en bases de datos existentes.
    # El `create_character` service y el `world_loader` aseguran que la sala con ID 1 (limbo) exista.
    op.execute('UPDATE characters SET room_id = 1 WHERE room_id IS NULL')

    # Ahora sí, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final.
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""Añadir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/5c4d38b0f409_añadir_capacidad_de_contenedor_a_los_.py ===
# alembic/script.py.mako

"""Añadir capacidad de contenedor a los items

Revision ID: 5c4d38b0f409
Revises: d1b407d64b9b
Create Date: 2025-10-01 14:00:11.616518+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '5c4d38b0f409'
down_revision = 'd1b407d64b9b'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.add_column('items', sa.Column('parent_item_id', sa.BigInteger(), nullable=True))
    op.create_foreign_key(None, 'items', 'items', ['parent_item_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'items', type_='foreignkey')
    op.drop_column('items', 'parent_item_id')
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###
# === FIN: alembic/versions/5c4d38b0f409_añadir_capacidad_de_contenedor_a_los_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""Añadir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/abe6da21ae81_añadir_columna_de_estado_a_las_cuentas.py ===
"""Añadir columna de estado a las cuentas

Revision ID: abe6da21ae81
Revises: f17a871c68a1
Create Date: <LA FECHA SE GENERA AUTOMÁTICamente>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'abe6da21ae81'
down_revision = 'f17a871c68a1'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('accounts', sa.Column('status', sa.String(length=20), server_default='ACTIVE', nullable=False))
    # NOTA: Se han eliminado las líneas autogeneradas que intentaban
    # borrar la tabla 'apscheduler_jobs', ya que esa tabla es gestionada
    # por otra migración y no por los modelos de la aplicación.
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('accounts', 'status')
    # NOTA: Se han eliminado las líneas autogeneradas que intentaban
    # recrear la tabla 'apscheduler_jobs' en el downgrade.
    # ### end Alembic commands ###
# === FIN: alembic/versions/abe6da21ae81_añadir_columna_de_estado_a_las_cuentas.py ===


# === INICIO: alembic/versions/cdb486941d55_añadir_key_a_las_salas_para_prototipos.py ===
# alembic/script.py.mako

"""Añadir key a las salas para prototipos

Revision ID: cdb486941d55
Revises: 57531370cbd7
Create Date: 2025-09-30 12:53:43.463923+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cdb486941d55'
down_revision = '57531370cbd7'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('key', sa.String(length=50), nullable=True))
    op.create_index(op.f('ix_rooms_key'), 'rooms', ['key'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_rooms_key'), table_name='rooms')
    op.drop_column('rooms', 'key')
    # ### end Alembic commands ###
# === FIN: alembic/versions/cdb486941d55_añadir_key_a_las_salas_para_prototipos.py ===


# === INICIO: alembic/versions/d1b407d64b9b_añadir_relacion_de_personajes_a_salas.py ===
# alembic/script.py.mako

"""Añadir relacion de personajes a salas

Revision ID: d1b407d64b9b
Revises: abe6da21ae81
Create Date: 2025-10-01 13:51:32.906868+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'd1b407d64b9b'
down_revision = 'abe6da21ae81'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###
# === FIN: alembic/versions/d1b407d64b9b_añadir_relacion_de_personajes_a_salas.py ===


# === INICIO: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===
"""Crear tabla para apscheduler jobs

Revision ID: db2dac1704aa
Revises: cdb486941d55
Create Date: <LA FECHA SE GENERA AUTOMÁTICAMENTE>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db2dac1704aa'
down_revision = 'cdb486941d55'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Crea la tabla 'apscheduler_jobs' con el esquema exacto que espera
    la librería APScheduler para su SQLAlchemyJobStore.
    """
    op.create_table(
        'apscheduler_jobs',
        sa.Column('id', sa.Unicode(191), primary_key=True),
        sa.Column('next_run_time', sa.Float(25), index=True),
        sa.Column('job_state', sa.LargeBinary, nullable=False)
    )


def downgrade() -> None:
    """
    Elimina la tabla 'apscheduler_jobs' si se revierte la migración.
    """
    op.drop_table('apscheduler_jobs')
# === FIN: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===


# === INICIO: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===
"""Crear tabla de configuraciones de personaje

Revision ID: f17a871c68a1
Revises: db2dac1704aa
Create Date: 2025-09-30 14:49:51.717892+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'f17a871c68a1'
down_revision = 'db2dac1704aa'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('character_settings',
    sa.Column('character_id', sa.BigInteger(), nullable=False),
    sa.Column('active_channels', postgresql.JSONB(astext_type=sa.Text()), server_default='{}', nullable=False),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.PrimaryKeyConstraint('character_id')
    )
    # --- Las líneas problemáticas han sido eliminadas de aquí ---
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('character_settings')
    # --- Las líneas problemáticas han sido eliminadas de aquí ---
    # ### end Alembic commands ###
# === FIN: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Define los cambios para aplicar esta migración.
    Crea las tablas iniciales `accounts` y `characters`.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

def downgrade() -> None:
    """
    Define los cambios para revertir esta migración.
    Elimina las tablas `characters` y `accounts`.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    # Ya no es necesario eliminar el usuario de seeding, ya que no se crea aquí.
    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###```
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===


# === INICIO: commands/__init__.py ===
# === FIN: commands/__init__.py ===


# === INICIO: commands/command.py ===
# commands/command.py
"""
Módulo que define la Clase Base para todos los Comandos.

Este archivo contiene la clase `Command`, que actúa como una plantilla o "contrato"
para todos los comandos del juego. Cada comando, ya sea de jugador o de administrador,
debe heredar de esta clase.

Esto asegura que todos los comandos tengan una estructura consistente y puedan ser
manejados de manera uniforme por el dispatcher principal.
"""

from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character

class Command:
    """
    Clase base abstracta para todos los comandos del juego.

    Atributos:
        names (list[str]): Una lista de alias que pueden invocar este comando.
                           El primer nombre de la lista se considera el principal.
        lock (str): Un string de permisos que el `permission_service` evaluará
                    para determinar si el personaje puede ejecutar el comando.
        description (str): Una breve descripción del propósito del comando, utilizada
                           para actualizar la lista de comandos en el cliente de Telegram.
    """
    lock: str = ""
    description: str = "Un comando sin descripción."

    def __init__(self, names: list[str] = None, description: str = None):
        """
        Inicializador que permite la creación de instancias de comandos
        con alias y descripciones dinámicas.

        Esto es especialmente útil para crear múltiples comandos a partir de una
        sola clase, como los comandos de movimiento (`/norte`, `/sur`, etc.).

        Args:
            names (list[str], optional): La lista de alias para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
            description (str, optional): La descripción para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
        """
        if names:
            self.names = names
        elif not hasattr(self, 'names'):
            self.names = []

        if description:
            self.description = description
        elif not hasattr(self, 'description'):
            # Asegura que siempre haya una descripción por defecto.
            self.description = "Un comando sin descripción."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """
        El método principal que se ejecuta cuando se llama al comando.

        Este método debe ser sobrescrito por cada clase de comando hija.

        Args:
            character (Character): El objeto del personaje que ejecuta el comando,
                                   precargado con todas sus relaciones.
            session (AsyncSession): La sesión de base de datos activa para esta
                                    interacción.
            message (types.Message): El objeto de mensaje de Aiogram que contiene
                                     el texto original, el ID del chat, etc.
            args (list[str]): Una lista de los argumentos proporcionados por el
                              usuario después del nombre del comando.
        """
        # Este método está pensado para ser sobrescrito. Si una subclase no lo
        # implementa, lanzar un NotImplementedError es una buena práctica para
        # detectar errores durante el desarrollo.
        raise NotImplementedError
# === FIN: commands/command.py ===


# === INICIO: commands/admin/__init__.py ===
from . import building
from . import movement
from . import info
from . import diagnostics
from . import management
# === FIN: commands/admin/__init__.py ===


# === INICIO: commands/admin/building.py ===
# commands/admin/building.py
"""
Módulo de Comandos Administrativos para la Generación de Entidades.

Este archivo contiene los comandos que permiten a los administradores "generar"
o "invocar" (`spawn`) entidades en el mundo a partir de sus prototipos
definidos en `game_data`.

Estos comandos no se usan para construir el mundo estático (eso lo hace el
`world_loader_service`), sino para añadir contenido dinámico durante el juego,
como objetos para un evento o PNJ para una misión.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service
from game_data.item_prototypes import ITEM_PROTOTYPES

class CmdGenerarObjeto(Command):
    """
    Comando para que un administrador cree una instancia de un objeto
    a partir de un prototipo y la coloque en la sala actual.
    """
    names = ["generarobjeto", "genobj"]
    lock = "rol(ADMIN)"  # Solo usuarios con rol ADMIN o superior pueden usarlo.
    description = "Genera un objeto en la sala a partir de su clave de prototipo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # Validación de entrada
        if not args:
            await message.answer("Uso: /generarobjeto [key_del_prototipo]")
            return

        item_key = args[0].lower()

        try:
            # Llama al servicio para crear la instancia del objeto en la base de datos.
            item = await item_service.spawn_item_in_room(session, character.room_id, item_key)

            # Obtenemos el nombre "bonito" del prototipo para el mensaje de confirmación.
            item_name = ITEM_PROTOTYPES.get(item.key, {}).get("name", "un objeto desconocido")

            await message.answer(f"✅ Objeto '{item_name}' generado en la sala actual.")

        except ValueError as e:
            # Este error se lanza desde `item_service` si la `item_key` no existe.
            await message.answer(f"❌ Error: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creación.
            await message.answer("❌ Ocurrió un error inesperado al generar el objeto.")
            logging.exception(f"Fallo al ejecutar /generarobjeto con la clave '{item_key}'")

# Exportamos la lista de comandos de este módulo.
SPAWN_COMMANDS = [
    CmdGenerarObjeto(),
]
# === FIN: commands/admin/building.py ===


# === INICIO: commands/admin/diagnostics.py ===
# commands/admin/diagnostics.py
"""
Módulo de Comandos Administrativos para Diagnóstico e Inspección.

Contiene herramientas para que los administradores puedan inspeccionar el estado
detallado de las entidades del juego, como personajes, objetos y salas.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from sqlalchemy import select

from commands.command import Command
from src.models import Character, Item, Room

class CmdExaminarPersonaje(Command):
    """
    Comando para obtener información detallada sobre un personaje.
    """
    names = ["examinarpersonaje", "exchar"]
    lock = "rol(ADMIN)"
    description = "Muestra información detallada de un personaje. Uso: /exchar [nombre o ID]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /examinarpersonaje [nombre o ID del personaje]")
            return

        target_string = " ".join(args)

        try:
            target_char = None
            try:
                # Buscar por ID
                char_id = int(target_string)
                target_char = await session.get(Character, char_id)
            except ValueError:
                # Buscar por nombre si no es un ID
                query = select(Character).where(Character.name.ilike(f"%{target_string}%"))
                result = await session.execute(query)
                target_char = result.scalar_one_or_none()

            if not target_char:
                await message.answer(f"No se encontró ningún personaje que coincida con '{target_string}'.")
                return

            # Cargar todas las relaciones para mostrar la información completa
            full_char = await session.get(Character, target_char.id, options=[selectinload("*")])

            lines = [
                f"<b>--- Personaje: {full_char.name} ---</b>",
                f"<b>ID:</b> {full_char.id}",
                f"<b>Cuenta ID:</b> {full_char.account_id} (Rol: {full_char.account.role})",
                f"<b>Sala Actual:</b> {full_char.room.name} (ID: {full_char.room_id})",
                f"<b>CommandSets Base:</b> {', '.join(full_char.command_sets)}",
            ]
            if full_char.items:
                lines.append("<b>Inventario:</b>")
                for item in full_char.items:
                    lines.append(f"  - {item.get_name()} (ID: {item.id}, Key: {item.key})")
            else:
                lines.append("<b>Inventario:</b> Vacío")

            body = '\n'.join(lines)
            await message.answer(f"<pre>{body}</pre>", parse_mode="HTML")

        except Exception:
            await message.answer("❌ Ocurrió un error al examinar el personaje.")
            logging.exception(f"Fallo al ejecutar /examinarpersonaje para '{target_string}'")


class CmdExaminarObjeto(Command):
    """
    Comando para obtener información detallada sobre una instancia de objeto.
    """
    names = ["examinarobjeto", "exobj"]
    lock = "rol(ADMIN)"
    description = "Muestra información detallada de un objeto. Uso: /exobj [ID]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /examinarobjeto [ID del objeto]")
            return

        try:
            item_id = int(args[0])
            target_item = await session.get(Item, item_id, options=[selectinload("*")])

            if not target_item:
                await message.answer(f"No se encontró ningún objeto con el ID '{item_id}'.")
                return

            lines = [
                f"<b>--- Objeto: {target_item.get_name()} ---</b>",
                f"<b>ID de Instancia:</b> {target_item.id}",
                f"<b>Clave de Prototipo:</b> {target_item.key}",
            ]
            if target_item.room:
                lines.append(f"<b>Ubicación:</b> Sala '{target_item.room.name}' (ID: {target_item.room_id})")
            elif target_item.character:
                lines.append(f"<b>Ubicación:</b> Inventario de '{target_item.character.name}' (ID: {target_item.character_id})")
            else:
                lines.append("<b>Ubicación:</b> En el limbo (ninguna sala/personaje)")

            lines.append(f"<b>Nombre Overr.:</b> {target_item.name_override or 'N/A'}")
            lines.append(f"<b>Desc. Overr.:</b> {target_item.description_override or 'N/A'}")

            body = '\n'.join(lines)
            await message.answer(f"<pre>{body}</pre>", parse_mode="HTML")

        except ValueError:
            await message.answer("El ID del objeto debe ser un número.")
        except Exception:
            await message.answer("❌ Ocurrió un error al examinar el objeto.")
            logging.exception(f"Fallo al ejecutar /examinarobjeto para '{args[0]}'")

# Exportamos la lista de comandos de este módulo.
DIAGNOSTICS_COMMANDS = [
    CmdExaminarPersonaje(),
    CmdExaminarObjeto(),
]
# === FIN: commands/admin/diagnostics.py ===


# === INICIO: commands/admin/info.py ===
# commands/admin/info.py
"""
Módulo de Comandos Administrativos de Información.

Este archivo contiene comandos diseñados para que los administradores puedan
consultar el estado interno del juego. Son herramientas de solo lectura
que ayudan a supervisar, depurar y obtener una visión general del mundo
sin modificarlo.

Ejemplos futuros podrían incluir: /donde [jugador], /infoobjeto [id], etc.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character, Room

class CmdListarSalas(Command):
    """
    Comando que muestra una lista de todas las salas existentes en el mundo,
    incluyendo su ID, su clave de prototipo y su nombre.
    """
    names = ["listarsalas", "lsalas"]
    lock = "rol(ADMIN)"
    description = "Muestra ID, Clave y Nombre de todas las salas del mundo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """Ejecuta la consulta y formatea la lista de salas."""
        try:
            # 1. Realizar la consulta a la base de datos para obtener todas las salas.
            # Se ordenan por ID para una visualización consistente.
            result = await session.execute(select(Room).order_by(Room.id))
            all_rooms = result.scalars().all()

            if not all_rooms:
                await message.answer("No se encontraron salas en la base de datos.")
                return

            # 2. Construir el mensaje de respuesta línea por línea.
            response_lines = ["<b>Lista de Salas del Mundo:</b>"]
            for room in all_rooms:
                # El formato con `<` alinea el texto a la izquierda, rellenando con espacios.
                response_lines.append(f"ID: {room.id:<4} | Key: {room.key:<20} | Nombre: {room.name}")

            body = "\n".join(response_lines)

            # 3. Envolver el cuerpo completo en una etiqueta <pre> para asegurar
            #    un formato de monoespaciado y una alineación perfecta de las columnas.
            response_text = f"<pre>{body}</pre>"

            await message.answer(response_text, parse_mode="HTML")

        except Exception:
            # Captura cualquier error inesperado durante la consulta a la base de datos.
            await message.answer("❌ Ocurrió un error al intentar listar las salas.")
            logging.exception("Fallo al ejecutar /listarsalas")

# Exportamos la lista de comandos de este módulo para que el dispatcher pueda importarla.
INFO_COMMANDS = [
    CmdListarSalas(),
]
# === FIN: commands/admin/info.py ===


# === INICIO: commands/admin/management.py ===
# commands/admin/management.py
"""
Módulo de Comandos Administrativos para la Gestión del Juego.

Este archivo contiene comandos de alto nivel que permiten a los administradores
modificar el estado persistente de las entidades del juego, como cambiar el
rol de un jugador.

Estos comandos son generalmente restrictivos y solo accesibles para los roles
más altos, como SUPERADMIN.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from commands.command import Command
from src.models import Character, Account
from src.services.permission_service import ROLE_HIERARCHY

class CmdAsignarRol(Command):
    """
    Comando de Superadmin para cambiar el rol de la cuenta de un personaje.
    """
    names = ["asignarrol"]
    lock = "rol(SUPERADMIN)"
    description = "Cambia el rol de un jugador. Uso: /asignarrol <nombre> <rol>"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if len(args) != 2:
            roles = ", ".join(ROLE_HIERARCHY.keys())
            await message.answer(f"Uso: /asignarrol <nombre_personaje> <rol>\nRoles disponibles: {roles}")
            return

        target_name, new_role = args
        new_role = new_role.upper()

        if new_role not in ROLE_HIERARCHY:
            roles = ", ".join(ROLE_HIERARCHY.keys())
            await message.answer(f"El rol '{new_role}' no es válido. Roles disponibles: {roles}")
            return

        try:
            # 1. Buscar al personaje por nombre.
            query = select(Character).where(Character.name.ilike(target_name))
            result = await session.execute(query)
            target_char = result.scalar_one_or_none()

            if not target_char:
                await message.answer(f"No se encontró un personaje con el nombre '{target_name}'.")
                return

            # 2. Obtener su cuenta.
            target_account = await session.get(Account, target_char.account_id)
            if not target_account:
                # Esto no debería ocurrir si la base de datos es consistente.
                await message.answer("Error: El personaje encontrado no tiene una cuenta asociada.")
                return

            # 3. Validar jerarquía: no se puede asignar un rol igual o superior al propio.
            user_level = ROLE_HIERARCHY.get(character.account.role.upper(), 0)
            new_role_level = ROLE_HIERARCHY.get(new_role, 0)

            if new_role_level >= user_level and character.id != target_char.id:
                 await message.answer("No puedes asignar un rol igual o superior a tu propio rango.")
                 return

            # 4. Actualizar el rol y guardar en la base de datos.
            old_role = target_account.role
            target_account.role = new_role
            await session.commit()

            await message.answer(f"✅ Se ha cambiado el rol de {target_char.name} de '{old_role}' a '{new_role}'.")

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar asignar el rol.")
            logging.exception(f"Fallo al ejecutar /asignarrol para '{target_name}'")

# Exportamos la lista de comandos de este módulo.
MANAGEMENT_COMMANDS = [
    CmdAsignarRol(),
]
# === FIN: commands/admin/management.py ===


# === INICIO: commands/admin/movement.py ===
# commands/admin/movement.py
"""
Módulo de Comandos Administrativos para el Movimiento.

Este archivo contiene comandos que otorgan a los administradores capacidades
de movimiento especiales, que no están sujetas a las reglas normales del juego
(como las salidas definidas en una sala).

Son herramientas esenciales para la construcción, supervisión y depuración del mundo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service # Importamos command_service para actualizar comandos
from src.utils.presenters import show_current_room

class CmdTeleport(Command):
    """
    Comando para teletransportar al administrador a cualquier sala del juego
    especificando su ID numérico.
    """
    names = ["teleport", "tp"]
    lock = "rol(ADMIN)"  # Solo usuarios con rol ADMIN o superior pueden usarlo.
    description = "Teletranspórtate a cualquier sala usando su ID."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario.
        if not args:
            await message.answer("Uso: /teleport [ID_sala]")
            return

        try:
            # Intentamos convertir el primer argumento a un número entero.
            to_room_id = int(args[0])
        except (ValueError, IndexError):
            # Falla si no hay argumentos o si el argumento no es un número.
            await message.answer("El ID de la sala debe ser un número válido.")
            return

        try:
            # 2. Llamar al servicio que contiene la lógica de negocio.
            await player_service.teleport_character(session, character.id, to_room_id)

            # 3. Notificar al administrador del éxito.
            await message.answer(f"🚀 Teletransportado a la sala {to_room_id}.")

            # 4. Actualizar los comandos de Telegram, ya que la nueva sala puede otorgar sets.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            if refreshed_character:
                 await command_service.update_telegram_commands(refreshed_character)

            # 5. Mostrar la nueva ubicación.
            await show_current_room(message)

        except Exception as e:
            # Capturamos cualquier error que pueda ocurrir durante el teletransporte,
            # como un ID de sala que no existe (manejado por `player_service`).
            await message.answer(f"❌ Error al teletransportar: {e}")
            logging.warning(f"Fallo al ejecutar /teleport a la sala {args[0]}: {e}")

# Exportamos la lista de comandos de este módulo.
ADMIN_MOVEMENT_COMMANDS = [
    CmdTeleport(),
]
# === FIN: commands/admin/movement.py ===


# === INICIO: commands/player/__init__.py ===
from . import general
from . import character
from . import interaction
from . import movement
from . import channels
from . import dynamic_channels
from . import settings
# === FIN: commands/player/__init__.py ===


# === INICIO: commands/player/channels.py ===
# commands/player/channels.py
"""
Módulo de Comandos para la Gestión de Canales de Chat.
... (resto de la cabecera sin cambios) ...
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdChannels(Command):
    """
    Comando para listar todos los canales disponibles y el estado de suscripción del jugador.
    """
    names = ["canales"]
    description = "Muestra los canales disponibles y tu estado de suscripción."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            settings = await channel_service.get_or_create_settings(session, character)
            user_channels = settings.active_channels.get("active_channels", [])

            response = ["<b>Estado de tus Canales:</b>"]
            for key, proto in CHANNEL_PROTOTYPES.items():
                status = "✅ Activado" if key in user_channels else "❌ Desactivado"
                response.append(f"- <b>{proto['name']}</b> ({key}): {status}\n  <i>{proto['description']}</i>")

            await message.answer("\n".join(response), parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al listar los canales.")
            logging.exception(f"Fallo al ejecutar /canales para {character.name}")

class CmdEnableChannel(Command):
    """
    Comando para que un jugador se suscriba (active) un canal.
    """
    names = ["activarcanal"]
    description = "Activa un canal para recibir sus mensajes. Uso: /activarcanal [nombre]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /activarcanal [nombre_del_canal]")
            return

        channel_key = args[0].lower()

        try:
            await channel_service.set_channel_status(session, character, channel_key, activate=True)
            await message.answer(f"✅ Has activado el canal '{channel_key}'.")
        except ValueError as e:
            await message.answer(f"❌ Error: {e}")
        except Exception:
            await message.answer("❌ Ocurrió un error al activar el canal.")
            logging.exception(f"Fallo al ejecutar /activarcanal para {character.name}")

class CmdDisableChannel(Command):
    """
    Comando para que un jugador cancele la suscripción (desactive) de un canal.
    """
    names = ["desactivarcanal"]
    description = "Desactiva un canal para no recibir sus mensajes. Uso: /desactivarcanal [nombre]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /desactivarcanal [nombre_del_canal]")
            return

        channel_key = args[0].lower()

        try:
            await channel_service.set_channel_status(session, character, channel_key, activate=False)
            await message.answer(f"✅ Has desactivado el canal '{channel_key}'.")
        except ValueError as e:
            await message.answer(f"❌ Error: {e}")
        except Exception:
            await message.answer("❌ Ocurrió un error al desactivar el canal.")
            logging.exception(f"Fallo al ejecutar /desactivarcanal para {character.name}")

# Exportamos la lista de comandos de gestión de canales.
CHANNEL_COMMANDS = [
    CmdChannels(),
    CmdEnableChannel(),
    CmdDisableChannel(),
]
# === FIN: commands/player/channels.py ===


# === INICIO: commands/player/character.py ===
# commands/player/character.py
"""
Módulo de Comandos para la Gestión del Personaje.

Este archivo contiene los comandos que permiten a los jugadores gestionar
el ciclo de vida de su personaje en el juego.

El comando principal aquí es `/crearpersonaje`, que es el primer comando que
un nuevo jugador debe usar para entrar al mundo de Runegram.

Futuros comandos como `/borrarpersonaje` o `/descripcion` también pertenecerían
a este módulo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service

class CmdCreateCharacter(Command):
    """
    Comando para que un nuevo usuario cree su personaje.
    """
    names = ["crearpersonaje"]
    description = "Crea tu personaje para empezar a jugar."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """
        Gestiona la lógica de creación de un nuevo personaje.
        """
        # 1. Comprobar si el jugador ya tiene un personaje.
        # El objeto 'character' solo es None si la cuenta no tiene un personaje asociado.
        if character:
            await message.answer("Ya tienes un personaje.")
            return

        # 2. Validar el nombre proporcionado por el usuario.
        character_name = " ".join(args)
        if not character_name or len(character_name) > 50:
            await message.answer("Por favor, proporciona un nombre válido (máx 50 caracteres). Uso: /crearpersonaje [nombre]")
            return

        try:
            # 3. Llamar al servicio que contiene la lógica de negocio para la creación.
            new_char = await player_service.create_character(session, message.from_user.id, character_name)

            # 4. Enviar un mensaje de éxito al jugador.
            await message.answer(
                f"¡Tu personaje, {new_char.name}, ha sido creado con éxito!\n"
                "Ahora estás listo para explorar el mundo de Runegram. ¡Envía /start para comenzar!"
            )
        except ValueError as e:
            # Captura errores de negocio específicos lanzados por `player_service`,
            # como "El nombre ya está en uso".
            await message.answer(f"No se pudo crear el personaje: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creación.
            # Gracias al `logging.exception`, veremos el traceback completo en los logs
            # del contenedor, lo que es vital para depurar errores sutiles de la base de datos.
            await message.answer("Ocurrió un error inesperado al crear tu personaje.")
            logging.exception(f"Error finalizando la creación del personaje para {message.from_user.id}")

# Exportamos la lista de comandos de este módulo.
CHARACTER_COMMANDS = [
    CmdCreateCharacter(),
]
# === FIN: commands/player/character.py ===


# === INICIO: commands/player/dynamic_channels.py ===
# commands/player/dynamic_channels.py
"""
Módulo para la Generación Dinámica de Comandos de Canal.

Este archivo contiene la lógica para crear automáticamente los comandos de chat
(ej: /novato, /sistema) a partir de las definiciones en
`game_data/channel_prototypes.py`.

Esto sigue la filosofía "Data-Driven" del motor: para añadir un nuevo canal
de chat al juego, un diseñador solo necesita añadir una entrada al archivo
de prototipos (con `type: "CHAT"`), y este módulo se encargará de crear el
comando correspondiente, aplicando los permisos definidos en el `lock`.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdDynamicChannel(Command):
    """
    Clase de comando genérica para enviar un mensaje a un canal de chat.
    La instancia de esta clase sabe a qué canal pertenece por su nombre.
    """
    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # El nombre principal del comando (ej: "novato") es la clave del canal.
            channel_key = self.names[0]

            if not args:
                await message.answer(f"Uso: /{channel_key} [mensaje]")
                return

            proto = CHANNEL_PROTOTYPES.get(channel_key)
            if not proto:
                # Salvaguarda en caso de inconsistencia entre el comando y los prototipos.
                await message.answer("Error: El canal para este comando ya no existe.")
                return

            # 1. Verificar si el jugador tiene el canal activado para recibir mensajes.
            settings = await channel_service.get_or_create_settings(session, character)
            if not await channel_service.is_channel_active(settings, channel_key):
                await message.answer(f"Tienes el canal '{channel_key}' desactivado. Actívalo con:\n/activarcanal {channel_key}")
                return

            # 2. Formatear y transmitir el mensaje a través del servicio.
            text = " ".join(args)
            channel_message = f"[{character.name}] {text}"
            await channel_service.broadcast_to_channel(session, channel_key, channel_message, exclude_character_id=character.id)

            # 3. Enviar una confirmación al propio jugador para que vea su mensaje.
            await message.answer(f"{proto['icon']} <b>{proto['name']}:</b> {channel_message}", parse_mode="HTML")

        except Exception:
            await message.answer("❌ Ocurrió un error al enviar tu mensaje al canal.")
            logging.exception(f"Fallo al ejecutar un comando de canal dinámico para {character.name}")

def generate_channel_commands() -> list[Command]:
    """
    Función "fábrica" que lee los prototipos de canal y genera una lista
    de instancias de `CmdDynamicChannel` para cada canal de tipo 'CHAT'.
    Asigna dinámicamente los permisos (locks) definidos en el prototipo.
    """
    commands = []
    for key, proto in CHANNEL_PROTOTYPES.items():
        # Solo se crean comandos para los canales que están explícitamente marcados como CHAT.
        if proto.get("type") == "CHAT":
            instance = CmdDynamicChannel(
                names=[key],
                description=f"Envía un mensaje por el canal {proto['name']}."
            )
            # Asignamos el lock del prototipo al atributo de la instancia del comando.
            # Si el prototipo no tiene un lock, se asigna una cadena vacía (sin restricciones).
            instance.lock = proto.get("lock", "")
            commands.append(instance)
    return commands

# Exportamos la lista de comandos generados dinámicamente.
# El dispatcher importará esta lista.
DYNAMIC_CHANNEL_COMMANDS = generate_channel_commands()
# === FIN: commands/player/dynamic_channels.py ===


# === INICIO: commands/player/general.py ===
# commands/player/general.py
"""
Módulo de Comandos Generales del Jugador.

Este archivo agrupa los comandos más básicos y fundamentales que un jugador
utiliza para interactuar con el mundo y obtener información esencial sobre su
entorno y su personaje.

Estos comandos están disponibles para todos los jugadores en todo momento.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from collections import Counter

from commands.command import Command
from src.models import Character
from src.utils.presenters import show_current_room
from src.services import script_service, online_service, permission_service

# Re-importamos `find_item_in_list` aquí ya que CmdInventory lo necesita.
from .interaction import find_item_in_list

class CmdLook(Command):
    """
    Comando para observar el entorno, objetos, personajes o detalles.
    """
    names = ["mirar", "m", "l"]
    lock = ""
    description = "Observa tu entorno o un objeto/personaje/detalle específico."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await show_current_room(message)
                return

            target_string = " ".join(args).lower()

            # 1. Buscar en los detalles de la sala.
            room_details = character.room.prototype.get("details", {})
            for detail_key, detail_data in room_details.items():
                if target_string in detail_data.get("keywords", []):
                    await message.answer(f"<pre>{detail_data['description']}</pre>", parse_mode="HTML")
                    return

            # 2. Buscar en los objetos de la sala.
            for item in character.room.items:
                if target_string in item.get_keywords() or target_string == item.get_name().lower():
                    await message.answer(f"<pre>{item.get_description()}</pre>", parse_mode="HTML")
                    if "on_look" in item.prototype.get("scripts", {}):
                        await script_service.execute_script(
                            script_string=item.prototype["scripts"]["on_look"],
                            session=session, character=character, target=item
                        )
                    return

            # 3. Buscar en el inventario del personaje.
            for item in character.items:
                if target_string in item.get_keywords() or target_string == item.get_name().lower():
                    await message.answer(f"<pre>{item.get_description()}</pre>", parse_mode="HTML")
                    if "on_look" in item.prototype.get("scripts", {}):
                        await script_service.execute_script(
                            script_string=item.prototype["scripts"]["on_look"],
                            session=session, character=character, target=item
                        )
                    return

            # 4. Buscar otros personajes en la sala.
            for other_char in character.room.characters:
                if other_char.id != character.id and target_string == other_char.name.lower():
                    await message.answer(f"<pre>{other_char.get_description()}</pre>", parse_mode="HTML")
                    return

            await message.answer("No ves eso por aquí.")

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar mirar.")
            logging.exception(f"Fallo al ejecutar /mirar para {character.name}")

class CmdSay(Command):
    """Comando para que el personaje hable a otros en la misma sala."""
    names = ["decir", "'"]
    lock = ""
    description = "Habla con las personas que están en tu misma sala."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("¿Qué quieres decir?")
            return

        say_text = " ".join(args)
        # Futuro: Usar broadcaster_service para notificar a la sala.
        await message.answer(f"Dices: {say_text}")

class CmdInventory(Command):
    """Comando para mostrar el inventario del jugador o el de un contenedor."""
    names = ["inventario", "inv", "i"]
    description = "Muestra tu inventario o el de un contenedor. Uso: /inv [contenedor]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # CASO 1: Mirar el inventario propio.
            if not args:
                inventory = character.items
                if not inventory:
                    response = "No llevas nada."
                else:
                    items_list = [f" - {item.get_name()}" for item in inventory]
                    items_str = "\n".join(items_list)
                    response = f"<b>Llevas lo siguiente:</b>\n{items_str}"
                await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")
                return

            # CASO 2: Mirar el inventario de un contenedor.
            container_name = " ".join(args).lower()
            container = find_item_in_list(container_name, character.items) or \
                        find_item_in_list(container_name, character.room.items)

            if not container:
                await message.answer(f"No ves ningún '{container_name}' por aquí.")
                return
            if not container.prototype.get("is_container"):
                await message.answer(f"{container.get_name().capitalize()} no es un contenedor.")
                return

            lock_string = container.prototype.get("locks", "")
            can_pass, _ = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                await message.answer(f"No puedes ver el contenido de {container.get_name()}.")
                return

            await session.refresh(container, attribute_names=['contained_items'])
            inventory = container.contained_items
            if not inventory:
                response = f"{container.get_name().capitalize()} está vacío."
            else:
                item_names = [item.get_name() for item in inventory]
                item_counts = Counter(item_names)
                formatted_items = [f" - {name}" + (f" ({count})" if count > 1 else "") for name, count in item_counts.items()]
                items_str = "\n".join(formatted_items)
                response = f"<b>En {container.get_name()} ves:</b>\n{items_str}"

            await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")

        except Exception:
            await message.answer("❌ Ocurrió un error al mostrar el inventario.")
            logging.exception(f"Fallo al ejecutar /inventario para {character.name}")


class CmdHelp(Command):
    """Comando para mostrar un mensaje de ayuda básico."""
    names = ["ayuda", "help"]
    lock = ""
    description = "Muestra una lista con los comandos básicos del juego."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        help_text = (
            "<b>Comandos Básicos de Runegram</b>\n"
            "---------------------------------\n"
            "/mirar - Muestra la descripción de tu entorno.\n"
            "/inventario - Muestra los objetos que llevas.\n"
            "/decir [mensaje] - Hablas a la gente en tu misma sala.\n"
            "/coger [objeto] - Recoges un objeto del suelo.\n"
            "/dejar [objeto] - Dejas un objeto en el suelo.\n"
            "/quien - Muestra quién está conectado.\n"
            "/canales - Gestiona tus suscripciones a canales.\n\n"
            "Para moverte, usa /norte, /sur, etc."
        )
        await message.answer(f"<pre>{help_text}</pre>", parse_mode="HTML")

class CmdWho(Command):
    """Comando social que muestra una lista de personajes conectados."""
    names = ["quien", "who"]
    lock = ""
    description = "Muestra una lista de los jugadores conectados."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            online_characters = await online_service.get_online_characters(session)

            if not online_characters or (len(online_characters) == 1 and online_characters[0].id == character.id):
                await message.answer("Eres la única alma aventurera en este mundo ahora mismo.")
                return

            response_lines = [f"<b>Hay {len(online_characters)} aventureros en Runegram:</b>"]
            for char in sorted(online_characters, key=lambda c: c.name):
                response_lines.append(f"- {char.name}")

            response_text = "\n".join(response_lines)
            await message.answer(f"<pre>{response_text}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al obtener la lista de jugadores.")
            logging.exception(f"Fallo al ejecutar /quien para {character.name}")

class CmdPray(Command):
    """Comando que permite al jugador rezar a los dioses."""
    names = ["orar", "rezar"]
    description = "Rezas a los dioses en busca de inspiración."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            response_text = "Bajas la cabeza y murmuras una plegaria. Sientes una cálida sensación de esperanza."
            await message.answer(response_text)
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar procesar tu plegaria.")
            logging.exception(f"Fallo al ejecutar /orar para {character.name}")


# Exportamos la lista de comandos de este módulo.
GENERAL_COMMANDS = [
    CmdLook(),
    CmdSay(),
    CmdInventory(),
    CmdHelp(),
    CmdWho(),
    CmdPray(),
]
# === FIN: commands/player/general.py ===


# === INICIO: commands/player/interaction.py ===
# commands/player/interaction.py
"""
Módulo de Comandos de Interacción con Objetos.

Este archivo contiene los comandos que permiten al jugador manipular directamente
los objetos (`Items`) en el mundo del juego, incluyendo la interacción con
objetos que funcionan como contenedores.
"""

import logging
import re
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from collections import Counter

from commands.command import Command
from src.models.character import Character
from src.services import item_service, command_service, player_service, permission_service

# --- Funciones de Ayuda para Búsqueda ---

def find_item_in_list(item_name: str, item_list: list):
    """Busca un objeto en una lista por su nombre o keywords."""
    for item in item_list:
        if item_name in item.get_keywords() or item_name == item.get_name().lower():
            return item
    return None

def parse_interaction_args(args: list[str]) -> tuple[str | None, str | None]:
    """
    Parsea argumentos complejos como "espada en mochila".
    Devuelve (nombre_objeto, nombre_contenedor).
    """
    arg_string = " ".join(args).lower()
    # Buscamos patrones como "en", "dentro de", "de", "desde"
    match = re.search(r'\s(en|dentro de|de|desde)\s', arg_string)
    if match:
        # Usamos `re.split` para manejar el separador de múltiples palabras
        parts = re.split(r'\s(?:en|dentro de|de|desde)\s', arg_string, 1)
        return parts[0].strip(), parts[1].strip()
    return arg_string, None

# --- Comandos ---

class CmdGet(Command):
    """Comando para coger un objeto del suelo."""
    names = ["coger", "g"]
    description = "Recoge un objeto del suelo. Uso: /coger <objeto>"
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¿Qué quieres coger?")
                return

            item_name_to_get, container_name = parse_interaction_args(args)

            # --- Lógica para Coger de un Contenedor ---
            if container_name:
                await CmdSacar().execute(character, session, message, args)
                return

            # --- Lógica para Coger del Suelo ---
            item_to_get = find_item_in_list(item_name_to_get, character.room.items)

            if not item_to_get:
                await message.answer("No ves eso por aquí.")
                return

            lock_string = item_to_get.prototype.get("locks", "")
            can_pass, error_message = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                await message.answer(error_message or "No puedes coger eso.")
                return

            await item_service.move_item_to_character(session, item_to_get.id, character.id)

            if item_to_get.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has cogido: {item_to_get.get_name()}")
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar coger el objeto.")
            logging.exception(f"Fallo al ejecutar /coger para {character.name}")

class CmdDrop(Command):
    """Comando para dejar un objeto del inventario en el suelo."""
    names = ["dejar", "d"]
    description = "Deja un objeto en el suelo. Uso: /dejar <objeto>"
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            if not args:
                await message.answer("¿Qué quieres dejar?")
                return

            item_to_drop_name = " ".join(args).lower()
            item_to_drop = find_item_in_list(item_to_drop_name, character.items)

            if not item_to_drop:
                await message.answer("No llevas eso.")
                return

            await item_service.move_item_to_room(session, item_to_drop.id, character.room_id)

            if item_to_drop.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has dejado: {item_to_drop.get_name()}")
        except Exception:
            await message.answer("❌ Ocurrió un error al intentar dejar el objeto.")
            logging.exception(f"Fallo al ejecutar /dejar para {character.name}")


class CmdMeter(Command):
    """Comando para meter un objeto en un contenedor."""
    names = ["meter", "guardar"]
    description = "Guarda un objeto en un contenedor. Uso: /meter <objeto> en <contenedor>"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            item_name, container_name = parse_interaction_args(args)
            if not item_name or not container_name:
                await message.answer("Uso: /meter <objeto> en <contenedor>")
                return

            container = find_item_in_list(container_name, character.items) or \
                        find_item_in_list(container_name, character.room.items)
            if not container:
                await message.answer(f"No ves ningún '{container_name}' por aquí.")
                return
            if not container.prototype.get("is_container"):
                await message.answer(f"{container.get_name().capitalize()} no es un contenedor.")
                return

            lock_string = container.prototype.get("locks", "")
            can_pass, _ = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                await message.answer(f"No puedes meter nada en {container.get_name()}.")
                return

            capacity = container.prototype.get("capacity", 0)
            # Aseguramos cargar la relación para contar los items.
            await session.refresh(container, attribute_names=['contained_items'])
            if len(container.contained_items) >= capacity:
                await message.answer(f"{container.get_name().capitalize()} está lleno.")
                return

            item_to_store = find_item_in_list(item_name, character.items) or \
                            find_item_in_list(item_name, character.room.items)
            if not item_to_store:
                await message.answer(f"No tienes ni ves ningún '{item_name}'.")
                return
            if item_to_store.id == container.id:
                await message.answer("No puedes meter un objeto dentro de sí mismo.")
                return

            await item_service.move_item_to_container(session, item_to_store.id, container.id)
            await message.answer(f"Guardas {item_to_store.get_name()} en {container.get_name()}.")

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar guardar el objeto.")
            logging.exception(f"Fallo al ejecutar /meter para {character.name}")

class CmdSacar(Command):
    """Comando para sacar un objeto de un contenedor."""
    names = ["sacar"]
    description = "Saca un objeto de un contenedor. Uso: /sacar <objeto> de <contenedor>"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            item_name, container_name = parse_interaction_args(args)
            if not item_name or not container_name:
                await message.answer("Uso: /sacar <objeto> de <contenedor>")
                return

            container = find_item_in_list(container_name, character.items) or \
                        find_item_in_list(container_name, character.room.items)
            if not container:
                await message.answer(f"No ves ningún '{container_name}' por aquí.")
                return

            lock_string = container.prototype.get("locks", "")
            can_pass, _ = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                await message.answer(f"No puedes sacar nada de {container.get_name()}.")
                return

            # Aseguramos cargar la relación para buscar items dentro.
            await session.refresh(container, attribute_names=['contained_items'])
            item_to_take = find_item_in_list(item_name, container.contained_items)
            if not item_to_take:
                await message.answer(f"No ves ningún '{item_name}' en {container.get_name()}.")
                return

            await item_service.move_item_to_character(session, item_to_take.id, character.id)
            await message.answer(f"Sacas {item_to_take.get_name()} de {container.get_name()}.")

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar sacar el objeto.")
            logging.exception(f"Fallo al ejecutar /sacar para {character.name}")

class CmdInventory(Command):
    """
    Comando para mostrar el inventario del jugador o el contenido de un contenedor.
    """
    names = ["inventario", "inv", "i"]
    description = "Muestra tu inventario o el de un contenedor. Uso: /inv [contenedor]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # CASO 1: Mirar el inventario propio.
            if not args:
                inventory = character.items
                if not inventory:
                    response = "No llevas nada."
                else:
                    items_list = [f" - {item.get_name()}" for item in inventory]
                    items_str = "\n".join(items_list)
                    response = f"<b>Llevas lo siguiente:</b>\n{items_str}"
                await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")
                return

            # CASO 2: Mirar el inventario de un contenedor.
            container_name = " ".join(args).lower()
            container = find_item_in_list(container_name, character.items) or \
                        find_item_in_list(container_name, character.room.items)

            if not container:
                await message.answer(f"No ves ningún '{container_name}' por aquí.")
                return
            if not container.prototype.get("is_container"):
                await message.answer(f"{container.get_name().capitalize()} no es un contenedor.")
                return

            lock_string = container.prototype.get("locks", "")
            can_pass, _ = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                await message.answer(f"No puedes ver el contenido de {container.get_name()}.")
                return

            # Aseguramos cargar la relación para ver los items.
            await session.refresh(container, attribute_names=['contained_items'])
            inventory = container.contained_items
            if not inventory:
                response = f"{container.get_name().capitalize()} está vacío."
            else:
                item_names = [item.get_name() for item in inventory]
                item_counts = Counter(item_names)
                formatted_items = [f" - {name}" + (f" ({count})" if count > 1 else "") for name, count in item_counts.items()]
                items_str = "\n".join(formatted_items)
                response = f"<b>En {container.get_name()} ves:</b>\n{items_str}"

            await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")

        except Exception:
            await message.answer("❌ Ocurrió un error al mostrar el inventario.")
            logging.exception(f"Fallo al ejecutar /inventario para {character.name}")

# Exportamos la lista de comandos de este módulo.
# CmdInventory se mueve a GENERAL_COMMANDS para unificarlo.
INTERACTION_COMMANDS = [
    CmdGet(),
    CmdDrop(),
    CmdMeter(),
    CmdSacar(),
]
# === FIN: commands/player/interaction.py ===


# === INICIO: commands/player/movement.py ===
# commands/player/movement.py
"""
Módulo de Comandos de Movimiento del Jugador.

Este archivo centraliza toda la lógica relacionada con el desplazamiento del
personaje por el mundo del juego.

Utiliza una única clase genérica, `CmdMove`, que se instancia para cada una de
las direcciones posibles (norte, sur, etc.), cada una con sus propios alias.
Esto evita la duplicación de código y mantiene la lógica de movimiento en un
solo lugar.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service, permission_service
from src.utils.presenters import show_current_room

class CmdMove(Command):
    """
    Comando genérico que gestiona el movimiento del jugador en una dirección.
    La dirección específica se determina por el nombre principal del comando
    (el primer elemento en la lista `names`).
    """
    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            # 1. Determinar la dirección basándose en el comando invocado.
            direction = self.names[0]

            # 2. Buscar si existe una salida válida en esa dirección.
            target_exit = next(
                (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == direction),
                None
            )

            if not target_exit:
                await message.answer("No puedes ir en esa dirección.")
                return

            # 3. Comprobar permisos (Locks).
            #    Llamamos al permission_service para evaluar el lock_string de la salida.
            can_pass, error_message = await permission_service.can_execute(character, target_exit.locks)
            if not can_pass:
                # Si `can_execute` devuelve un mensaje personalizado, lo usamos.
                # Si no, usamos un mensaje genérico.
                await message.answer(error_message or "Esa salida está bloqueada.")
                return

            # 4. Mover al personaje a la nueva sala.
            await player_service.teleport_character(session, character.id, target_exit.to_room_id)

            # 5. Actualizar la lista de comandos del jugador en Telegram.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            if refreshed_character:
                await command_service.update_telegram_commands(refreshed_character)

            # 6. Mostrar al jugador la descripción de su nueva ubicación.
            await show_current_room(message)

        except Exception:
            await message.answer("❌ Ocurrió un error al intentar moverte.")
            logging.exception(f"Fallo al ejecutar /mover ({self.names[0]}) para {character.name}")

# --- Creación del Command Set con descripciones ---
# Se crea una instancia de `CmdMove` para cada dirección, asignando sus alias
# y una descripción clara para la lista de comandos de Telegram.
MOVEMENT_COMMANDS = [
    CmdMove(names=["norte", "n"], description="Moverse hacia el norte."),
    CmdMove(names=["sur", "s"], description="Moverse hacia el sur."),
    CmdMove(names=["este", "e"], description="Moverse hacia el este."),
    CmdMove(names=["oeste", "o"], description="Moverse hacia el oeste."),
    CmdMove(names=["arriba", "ar"], description="Moverse hacia arriba."),
    CmdMove(names=["abajo", "ab"], description="Moverse hacia abajo."),
    CmdMove(names=["noreste", "ne"], description="Moverse hacia el noreste."),
    CmdMove(names=["noroeste", "no"], description="Moverse hacia el noroeste."),
    CmdMove(names=["sureste", "se"], description="Moverse hacia el sureste."),
    CmdMove(names=["suroeste", "so"], description="Moverse hacia el suroeste."),
]
# === FIN: commands/player/movement.py ===


# === INICIO: commands/player/settings.py ===
# commands/player/settings.py
"""
Módulo de Comandos para la Configuración del Personaje.

Este archivo contiene los comandos que permiten a los jugadores personalizar
su experiencia de juego, como ajustar las notificaciones, los colores (en el
futuro), u otras preferencias.

Actualmente, sirve como punto de entrada para la gestión de canales, pero
está diseñado para albergar más comandos de configuración a medida que el
juego crezca.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character

class CmdConfig(Command):
    """
    Comando principal para que un jugador acceda a las opciones de configuración.
    Actualmente, muestra una ayuda contextual sobre cómo gestionar los canales.
    """
    names = ["config", "opciones"]
    description = "Muestra las opciones de configuración disponibles."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            help_text = (
                "<b>Configuración de Runegram</b>\n"
                "---------------------------------\n"
                "Aquí podrás ajustar tus preferencias de juego.\n\n"
                "<b>Gestión de Canales:</b>\n"
                " - Usa <code>/canales</code> para ver una lista de todos los canales y su estado.\n"
                " - Usa <code>/activarcanal [nombre]</code> para suscribirte a un canal.\n"
                " - Usa <code>/desactivarcanal [nombre]</code> para cancelar tu suscripción."
            )
            await message.answer(help_text, parse_mode="HTML")
        except Exception:
            await message.answer("❌ Ocurrió un error al mostrar las opciones de configuración.")
            logging.exception(f"Fallo al ejecutar /config para {character.name}")

# Exportamos la lista de comandos de este módulo.
SETTINGS_COMMANDS = [
    CmdConfig(),
]
# === FIN: commands/player/settings.py ===


# === INICIO: docs/01_GETTING_STARTED.md ===
# Guía de Inicio para Desarrolladores

Este documento proporciona una guía detallada paso a paso para configurar el entorno de desarrollo de Runegram en una máquina local. El proyecto está completamente contenerizado con Docker, lo que simplifica enormemente el proceso de instalación.

## 1. Prerrequisitos

Antes de comenzar, asegúrate de tener instalado el siguiente software:

*   **[Git](https://git-scm.com/)**: Para clonar el repositorio.
*   **[Docker Desktop](https://www.docker.com/products/docker-desktop/)**: Gestiona los contenedores, imágenes y volúmenes. Incluye `docker` y `docker-compose`.

## 2. Proceso de Instalación

### Paso 1: Clonar el Repositorio

Abre tu terminal preferida, navega al directorio donde quieres guardar el proyecto y clona el repositorio desde GitHub.

```bash
git clone https://github.com/tu-usuario/runegram.git
cd runegram
```

### Paso 2: Configurar las Variables de Entorno

La aplicación utiliza un archivo `.env` en la raíz del proyecto para gestionar secretos y configuraciones específicas del entorno. Este archivo **no se debe subir a Git**.

1.  Crea un nuevo archivo llamado `.env` en la raíz del proyecto.
2.  Copia y pega el siguiente contenido en el archivo:

    ```env
    # ===============================================================
    #          Archivo de Configuración de Entorno para Runegram
    # ===============================================================

    # --- Configuración del Superadministrador ---
    # El ID numérico de Telegram del usuario que tendrá el rol más alto.
    # Puedes obtener tu ID hablando con bots como @userinfobot en Telegram.
    SUPERADMIN_TELEGRAM_ID=123456789

    # --- Telegram ---
    # El token de autenticación para tu bot de Telegram, proporcionado por @BotFather.
    BOT_TOKEN=7647451243:AAF7TOxVmEGjEtvMUQo69uM0yvLbpyS39Wc

    # --- Base de Datos (PostgreSQL) ---
    # Credenciales para el servicio de la base de datos.
    POSTGRES_USER=runegram
    POSTGRES_PASSWORD=runegram
    POSTGRES_DB=runegram_db
    POSTGRES_HOST=postgres
    POSTGRES_PORT=5432

    # --- Caché y Estados (Redis) ---
    # Configuración para la conexión al servicio de Redis.
    REDIS_HOST=redis
    REDIS_PORT=6379
    REDIS_DB=0
    ```

3.  **Modifica las variables `SUPERADMIN_TELEGRAM_ID` y `BOT_TOKEN` con tus propios valores.**

### Paso 3: Construir y Ejecutar los Contenedores

El proyecto incluye un script de conveniencia que automatiza todo el proceso de limpieza y arranque.

Desde la raíz del proyecto, ejecuta:
```bash
# En Windows (CMD o PowerShell)
scripts\full_reset.bat
```
Este script realizará las siguientes acciones:
1.  `docker-compose down -v`: Detiene y elimina los contenedores existentes y, crucialmente, **borra el volumen de la base de datos**, asegurando un estado completamente limpio.
2.  `docker-compose up --build -d`: Reconstruye la imagen de la aplicación (si hay cambios en el `Dockerfile` o `requirements.txt`) y levanta todos los servicios (`bot`, `postgres`, `redis`) en segundo plano.

### Paso 4: Verificar la Instalación

Tras ejecutar el script, puedes verificar que todo está funcionando correctamente:

1.  **Comprueba los contenedores en ejecución:**
    ```bash
    docker ps
    ```
    Deberías ver tres contenedores en estado `Up`: `runegram-bot-1`, `runegram-postgres-1` y `runegram-redis-1`.

2.  **Revisa los logs de la aplicación:**
    ```bash
    docker-compose logs -f bot
    ```
    Espera a que el proceso de arranque finalice. Verás los logs del `entrypoint.sh` esperando a PostgreSQL, ejecutando las migraciones y, finalmente, el bot de Python iniciándose. La última línea debería ser similar a:
    `[INFO] - aiogram.dispatcher.dispatcher: Start polling.`

### Paso 5: ¡A Jugar!
Abre tu cliente de Telegram, busca tu bot y envíale el comando `/start`. ¡Deberías recibir el mensaje de bienvenida!

## 3. Flujo de Trabajo de Desarrollo

### Realizar Cambios en el Código
Gracias a los volúmenes de Docker configurados en `docker-compose.yml`, cualquier cambio que hagas en los archivos de tu máquina local (en `src/`, `commands/`, `game_data/`, etc.) se refleja **instantáneamente** dentro del contenedor. El servidor de Aiogram se reiniciará automáticamente para aplicar la mayoría de los cambios en el código Python.

### Gestionar Migraciones de la Base de Datos
Cuando modificas la estructura de un modelo en `src/models/` (ej: añades una nueva columna), debes generar y aplicar una migración.

1.  **Generar una nueva migración:**
    ```bash
    docker-compose exec bot alembic revision --autogenerate -m "Un mensaje descriptivo del cambio"
    ```
2.  **Revisar el archivo generado:** Es una buena práctica abrir el nuevo archivo en `alembic/versions/` para asegurarte de que los cambios generados son los que esperabas.
3.  **Aplicar la migración:** La forma más segura de aplicar la nueva migración en un entorno de desarrollo es reiniciar todo el sistema.
    ```bash
    scripts\full_reset.bat
    ```

### Comandos Útiles de Docker
*   `docker-compose up -d`: Levanta los servicios en segundo plano.
*   `docker-compose down`: Detiene y elimina los contenedores.
*   `docker-compose logs -f bot`: Muestra los logs del contenedor del bot en tiempo real.
*   `docker-compose exec bot <comando>`: Ejecuta un comando dentro del contenedor del bot (ej: `docker-compose exec bot alembic current`).
# === FIN: docs/01_GETTING_STARTED.md ===


# === INICIO: docs/02_CORE_PHILOSOPHY.md ===
# Filosofía del Núcleo de Runegram

La arquitectura de Runegram no es accidental; se basa en un conjunto de principios de diseño bien definidos. Comprender esta filosofía es clave para desarrollar y expandir el juego de manera consistente, mantenible y escalable.

Estos principios se dividen en dos áreas principales: la separación estructural entre el **Motor y el Contenido**, y el diseño de la interfaz de usuario a través de la **Filosofía de Comandos**.

## 1. El Principio del Motor vs. el Contenido (Data-Driven Design)

Este es el principio más fundamental de Runegram. El proyecto entero está dividido en dos dominios lógicos estrictamente separados:

### El Motor del Juego (`src/`)

*   **¿Qué es?** El Motor es el **código fuente** de la aplicación. Es la maquinaria genérica, abstracta y reutilizable que hace que el juego funcione.
*   **Responsabilidades:** Conexión a la base de datos, comunicación con Telegram, ejecución de la lógica de los sistemas (comandos, permisos, tickers), gestión de modelos de datos, etc.
*   **Cómo piensa:** El Motor no sabe qué es una "espada mágica" o la "Ciudad de Runegard". Solo conoce conceptos genéricos como `Item` y `Room`. No contiene nombres, descripciones ni reglas de juego específicas. Su trabajo es proporcionar un conjunto de herramientas potentes para que el Contenido pueda existir.

### El Contenido del Juego (`game_data/`, `commands/`)

*   **¿Qué es?** El Contenido son los **datos y definiciones** que dan vida, forma y reglas al mundo del juego.
*   **Responsabilidades:** Definir qué objetos existen (`item_prototypes.py`), cómo se conectan las salas (`room_prototypes.py`), qué canales de chat hay (`channel_prototypes.py`), qué hacen los comandos (`commands/`) y cómo reacciona el mundo (`scripts`).
*   **Cómo piensa:** El Contenido define qué es una "Espada Viviente", qué descripción tiene, qué hace cuando la miras y que susurra secretos cada dos minutos. Utiliza las herramientas que el Motor le proporciona para implementar estas reglas.

### La Ventaja de la Separación

Esta estricta separación (conocida como **diseño dirigido por datos** o *Data-Driven Design*) es la clave de la escalabilidad de Runegram:

1.  **Aceleración del Desarrollo:** Un diseñador de contenido puede crear cientos de salas, objetos y PNJ sin escribir una sola línea de código Python del motor. El desarrollo del mundo se convierte en una tarea de edición de archivos de datos, no de programación.
2.  **Reducción de Bugs:** Al aislar la lógica compleja en el Motor, se reduce drásticamente la superficie de ataque para los errores. Un error de tipeo en la descripción de un objeto no puede romper el servidor.
3.  **Mantenibilidad:** El Motor se puede refactorizar y mejorar de forma independiente sin afectar al Contenido, y viceversa.
4.  **Control de Versiones Claro:** Los cambios en el mundo del juego son visibles directamente en el historial de `git` de la carpeta `game_data/`, lo que permite un seguimiento y una colaboración mucho más sencillos.

## 2. La Filosofía de Comandos

La interfaz a través de la cual los jugadores interactúan con el mundo sigue una filosofía centrada en la claridad y la facilidad de uso.

### Principio de Comando Descriptivo

Se prefiere la claridad de tener **más comandos dedicados y explícitos** a la complejidad de tener un único comando con múltiples subcomandos.

*   **Ejemplo Bueno:** `/activarcanal`, `/desactivarcanal`, `/listarsalas`. Cada comando hace una sola cosa y su nombre lo describe.
*   **Ejemplo a Evitar:** `/canal set novato on`, `/admin salas listar`. Este enfoque, aunque potente, es menos intuitivo y más difícil de descubrir para el jugador.

El formato estándar para todos los comandos es `/<acción> [argumentos]`.

### Principio de Descubrimiento Dinámico

El motor del juego está diseñado para que la interfaz se adapte al contexto del jugador, ayudándole a descubrir las acciones disponibles.

*   **Generación Dinámica:** Los comandos de chat (como `/novato` o `/sistema`) no están hardcodeados. Se generan automáticamente al leer los prototipos de canal. Si un diseñador añade un nuevo canal de chat `comercio`, el comando `/comercio` pasa a existir sin necesidad de programación adicional.
*   **Actualización en Vivo:** El motor actualiza la lista de comandos disponibles en el menú (`/`) del cliente de Telegram en tiempo real. Si un jugador coge un objeto que le otorga una nueva habilidad (y por tanto, un nuevo comando), ese comando aparecerá inmediatamente en su lista. Esto elimina la necesidad de que los jugadores memoricen comandos contextuales.

Estos principios combinados buscan crear una experiencia de juego fluida, donde la interfaz es una ayuda y no un obstáculo, y donde el mundo puede crecer y evolucionar de forma rápida y segura.
# === FIN: docs/02_CORE_PHILOSOPHY.md ===


# === INICIO: docs/05_ADMIN_GUIDE.md ===
# Guía de Comandos de Administración

Este documento es una referencia completa para todos los comandos especiales disponibles para los roles de `ADMIN` y `SUPERADMIN`. Estos comandos son herramientas para la creación, depuración y gestión del mundo de Runegram.

## Jerarquía de Roles

El sistema de permisos se basa en una jerarquía simple:
*   **SUPERADMIN:** Tiene acceso a todos los comandos. Es el rol más alto.
*   **ADMIN:** Tiene acceso a la mayoría de los comandos de construcción y moderación, pero no a los que son potencialmente destructivos o alteran la configuración fundamental del juego.
*   **JUGADOR:** El rol base sin acceso a comandos administrativos.

---

## Comandos de Generación (Spawning)

Estos comandos permiten crear nuevas instancias de entidades en el mundo.

### `/generarobjeto <clave_prototipo>`
*   **Alias:** `/genobj`
*   **Permiso:** `ADMIN`
*   **Descripción:** Crea una instancia del objeto especificado por su `clave_prototipo` y la coloca en el suelo de la sala actual del administrador. La clave debe corresponder a una entrada en `game_data/item_prototypes.py`.
*   **Uso:**
    ```
    /generarobjeto espada_viviente
    ```

---

## Comandos de Movimiento

Estos comandos permiten a los administradores moverse libremente por el mundo.

### `/teleport <id_sala>`
*   **Alias:** `/tp`
*   **Permiso:** `ADMIN`
*   **Descripción:** Te teletransporta instantáneamente a la sala especificada por su `ID` numérico. Para encontrar el ID de una sala, utiliza el comando `/listarsalas`.
*   **Uso:**
    ```
    /tp 3
    ```

---

## Comandos de Información y Diagnóstico

Estos comandos son herramientas de solo lectura para inspeccionar el estado del juego.

### `/listarsalas`
*   **Alias:** `/lsalas`
*   **Permiso:** `ADMIN`
*   **Descripción:** Muestra una lista de todas las salas que existen en el mundo, incluyendo su `ID`, su `key` de prototipo y su `nombre`. Esencial para usar `/teleport`.

### `/examinarpersonaje <nombre_o_id>`
*   **Alias:** `/exchar`
*   **Permiso:** `ADMIN`
*   **Descripción:** Muestra un informe detallado sobre un personaje. Incluye su ID, sala actual, rol de cuenta, CommandSets base y contenido del inventario.
*   **Uso:**
    ```
    /exchar Ben
    /exchar 1
    ```

### `/examinarobjeto <id>`
*   **Alias:** `/exobj`
*   **Permiso:** `ADMIN`
*   **Descripción:** Muestra un informe detallado sobre una **instancia** específica de un objeto, identificado por su ID único en la base de datos. Incluye su clave de prototipo, ubicación (sala o inventario de un jugador) y cualquier `override` de nombre o descripción.
*   **Uso:**
    ```
    /exobj 12
    ```

---

## Comandos de Gestión (Management)

Estos comandos modifican el estado fundamental de las entidades del juego y generalmente requieren el permiso más alto.

### `/asignarrol <nombre_personaje> <rol>`
*   **Permiso:** `SUPERADMIN`
*   **Descripción:** Cambia el rol de la cuenta asociada al personaje especificado. El Superadmin no puede asignar un rol igual o superior al suyo a otra persona.
*   **Roles Disponibles:** `JUGADOR`, `ADMIN`, `SUPERADMIN`.
*   **Uso:**
    ```
    /asignarrol Pippin ADMIN
    ```
# === FIN: docs/05_ADMIN_GUIDE.md ===


# === INICIO: docs/06_DATABASE_AND_MIGRATIONS.md ===
# Guía de Base de Datos y Migraciones

La base de datos es la columna vertebral de Runegram, almacenando todo el estado persistente del mundo. La gestión de los cambios en su estructura (el "esquema") se realiza a través de una herramienta llamada **Alembic**. Esta guía explica el concepto y el flujo de trabajo para manejar las migraciones de la base de datos.

## 1. ¿Qué es una Migración?

Cuando cambias el código de un modelo en `src/models/` (por ejemplo, añades una nueva columna `status` a la tabla `Account`), la base de datos no se actualiza mágicamente. Una **migración** es un script de Python que contiene las instrucciones (`ALTER TABLE`, `CREATE TABLE`, etc.) necesarias para llevar la base de datos desde su estado antiguo al nuevo estado que tus modelos definen.

Alembic se encarga de generar y ejecutar estos scripts de forma ordenada.

## 2. El Flujo de Trabajo para Cambios en los Modelos

Cada vez que realices un cambio en la estructura de un modelo, debes seguir este proceso para que el cambio se refleje correctamente en la base de datos.

### Paso 1: Modificar el Modelo de Python

Realiza los cambios necesarios en el archivo del modelo correspondiente en `src/models/`.

**Ejemplo:** Añadir una columna `nickname` a la tabla `characters`.

```python
# En src/models/character.py
class Character(Base):
    # ...
    name = Column(String(50), unique=True, nullable=False)
    nickname = Column(String(50), nullable=True) # <-- NUEVA COLUMNA
    # ...
```

### Paso 2: Generar el Script de Migración

Una vez guardados los cambios en el modelo, necesitas que Alembic compare tus modelos actualizados con el estado actual de la base de datos y genere el script de migración.

1.  **Asegúrate de que tus contenedores estén en ejecución:**
    ```bash
    docker-compose up -d
    ```

2.  **Ejecuta el comando `autogenerate`:**
    Usa `docker-compose exec` para ejecutar Alembic dentro del contenedor del bot. Proporciona siempre un mensaje descriptivo con `-m`.

    ```bash
    docker-compose exec bot alembic revision --autogenerate -m "Añadir columna nickname a characters"
    ```

Alembic generará un nuevo archivo en `alembic/versions/` con un nombre como `xxxxxxxxxxxx_añadir_columna_nickname_a_characters.py`.

### Paso 3: Revisar y Corregir el Script (¡Paso Crucial!)

El comando `autogenerate` es una herramienta potente, pero **no es perfecto**. A veces puede interpretar los cambios de forma incorrecta o añadir operaciones no deseadas.

**Siempre debes abrir el nuevo archivo de migración y revisarlo.**

**Caso Común de Error: Tablas Externas**
Alembic solo conoce los modelos definidos en `src/models/`. Si tienes una tabla creada "manualmente" por una migración (como `apscheduler_jobs`), `autogenerate` la verá en la base de datos pero no en los modelos y pensará que debe ser eliminada.

**Si ves líneas como `op.drop_table('apscheduler_jobs')` o `op.drop_index(...)` en una migración que no debería afectar a esa tabla, ¡bórralas del archivo!**

### Paso 4: Aplicar la Migración

Una vez que has revisado y estás conforme con el script de migración, puedes aplicarlo. En el entorno de desarrollo, la forma más simple y segura es reiniciar todo el sistema con el script de reseteo.

```bash
# En Windows
scripts\full_reset.bat```

Este script detendrá los contenedores, borrará la base de datos antigua y la reconstruirá desde cero, aplicando **todas** las migraciones en orden, incluida la nueva que acabas de crear. Al arrancar, el `entrypoint.sh` se encarga de ejecutar `alembic upgrade head`, que pone la base de datos al día.

## 3. Comandos Útiles de Alembic

Puedes ejecutar estos comandos usando `docker-compose exec bot alembic <comando>`.

*   `alembic current`: Muestra el ID de la última migración aplicada a la base de datos.
*   `alembic heads`: Muestra el ID de la migración más reciente en tus archivos (la "cabeza" o `head`).
*   `alembic history`: Muestra el historial de todas las migraciones, desde la base hasta la cabeza, indicando cuál es la actual.
*   `alembic upgrade head`: Aplica todas las migraciones pendientes.
*   `alembic downgrade -1`: Revierte la última migración aplicada. (Usar con cuidado).
# === FIN: docs/06_DATABASE_AND_MIGRATIONS.md ===


# === INICIO: docs/07_ROADMAP.md ===
# Visión a Futuro y Roadmap de Runegram

Este documento describe la visión a largo plazo para el desarrollo de Runegram y enumera las próximas grandes funcionalidades y mejoras planificadas. Actúa como una hoja de ruta para evolucionar desde el motor de juego actual hacia una experiencia MUD completa y rica.

## Visión General

El objetivo es transformar Runegram en un MUD social y dinámico con sistemas de juego profundos, incluyendo combate, progresión de habilidades, crafteo y quests. La arquitectura actual, basada en la separación de Motor y Contenido, está diseñada para facilitar la implementación de estas características de manera modular y escalable.

---

## 🚀 Próximas Grandes Funcionalidades

Estas son las características de alto impacto que definirán la siguiente etapa del juego.

### 1. Sistema de Combate y Habilidades
*   **Visión:** Crear un sistema de combate táctico por turnos y una progresión de habilidades basada en la mecánica de "aprender haciendo" (d100).
*   **Tareas:**
    1.  **Modelos de Datos:** Crear las tablas `skills` y `character_skills` en la base de datos. Añadir atributos de combate (ej: `current_hp`, `max_hp`, `current_mana`, `max_mana`) al modelo `Character`.
    2.  **Mecánica d100:** Implementar en un `skill_service` la lógica central de resolución de acciones: una acción tiene éxito si `d100 <= nivel_de_habilidad`. El éxito otorga experiencia en esa habilidad.
    3.  **PNJs (Personajes No Jugadores):**
        *   Crear un archivo `game_data/npc_prototypes.py` y un modelo `NPC` en la base de datos.
        *   Desarrollar un `npc_service` para gestionar el "spawn" (aparición), el "despawn" (desaparición) y la IA básica (ej: agresivo, pasivo, patrulla).
        *   Implementar un sistema de "respawn" para que los monstruos vuelvan a aparecer después de un tiempo.
    4.  **Comandos de Combate:** Crear el `CommandSet` de `combat` con comandos como `/atacar [objetivo]`, `/huir`, `/lanzar [hechizo] [objetivo]`, etc.

### 2. Sistema de Interacción Social
*   **Visión:** Hacer que el mundo se sienta verdaderamente multijugador, donde las acciones de un jugador son visibles y tienen un impacto en los demás.
*   **Tareas:**
    1.  **Refactorizar `/decir`:** Modificar el comando para que use `broadcaster_service.send_message_to_room`, de modo que todos los jugadores *online* en la misma sala vean el mensaje.
    2.  **Notificaciones de Movimiento:** Implementar mensajes de "entrada/salida" en el `CmdMove`. Cuando un jugador se mueve, los jugadores en la sala de origen y de destino deben ser notificados.
    3.  **Notificaciones de Acción:** Modificar comandos como `/coger` y `/dejar` para que notifiquen a la sala sobre la acción (ej: "Benabhi coge una espada viviente.").
    4.  **Expandir `/mirar`:** Mejorar el comando para que pueda `mirar` a otros jugadores y PNJ en la sala, mostrando sus descripciones.

### 3. Sistema de Clases y Razas
*   **Visión:** Permitir a los jugadores personalizar su personaje al inicio del juego, eligiendo una clase y/o raza que defina sus habilidades y `CommandSets` iniciales.
*   **Tareas:**
    1.  **Máquina de Estados Finitos (FSM):** Utilizar el sistema de `FSM` de Aiogram para guiar al jugador a través de un proceso de creación de personaje por pasos (nombre -> elegir raza -> elegir clase).
    2.  **Prototipos de Clases/Razas:** Crear archivos en `game_data` que definan las estadísticas, habilidades y `CommandSets` base para cada clase y raza.
    3.  **Integración:** Hacer que el `player_service.create_character` lea la elección del jugador y aplique las plantillas correspondientes al nuevo personaje.

---

## ✨ Mejoras del Motor y Calidad de Vida

Estas son mejoras a los sistemas existentes que pulirán la experiencia de juego y desarrollo.

*   **Expandir el Sistema de Locks:**
    *   Implementar y registrar nuevas funciones de `lock` en el `permission_service`, como `habilidad(nombre)>valor`, `clase(nombre)`, etc.
    *   Integrar los `locks` en los prototipos de `Exits` para que el `world_loader_service` los aplique, permitiendo la creación de puertas con llave.

*   **Sistema de Contenedores:**
    *   Modificar el modelo `Item` para que pueda actuar como un contenedor (con capacidad, inventario propio).
    *   Crear comandos como `/meter [objeto] en [contenedor]` y `/sacar [objeto] de [contenedor]`.

*   **Bandeja de Entrada para Notificaciones:**
    *   Para los tickers de categoría `important` o `quest`, implementar la lógica para guardar los mensajes para los jugadores inactivos y presentárselos cuando vuelvan a conectarse.

*   **Detalles de Sala Interactivos:**
    *   Expandir `room_prototypes.py` y `CmdLook` para permitir "keywords" en la descripción de una sala. Al `mirar` una `keyword` (ej: `/mirar cuadro`), se revelaría un texto adicional sin necesidad de que sea un objeto físico.
# === FIN: docs/07_ROADMAP.md ===


# === INICIO: docs/08_COMBAT_SYSTEM.md ===
# Sistema de Combate

*(Este documento es un borrador y se completará a medida que el Sistema de Combate sea diseñado e implementado).*

## Visión General

El Sistema de Combate de Runegram será un sistema táctico por turnos diseñado para la interfaz de un MUD de texto. Se centrará en la claridad de la información y en decisiones significativas por parte del jugador.

## Flujo de un Turno de Combate

1.  **Iniciación:** El combate comienza cuando un jugador ataca a un PNJ agresivo o viceversa. Todos los participantes en la sala entran en "modo de combate".
2.  **Cola de Acciones:** El sistema determinará el orden de acción (basado en atributos como Agilidad o Iniciativa).
3.  **Resolución de Acciones:** Las acciones (atacar, lanzar hechizo, usar objeto) se resuelven una por una.
4.  **Fin del Turno:** Se muestra un resumen del turno a todos los participantes.
5.  **Comprobación de Fin de Combate:** Si solo queda un bando en pie, el combate termina. De lo contrario, comienza un nuevo turno.

## Comandos de Combate

El `CommandSet` de `combat` incluirá, como mínimo:
*   `/atacar <objetivo>`
*   `/lanzar <hechizo> <objetivo>`
*   `/usar <objeto> <objetivo>`
*   `/huir`

## Atributos de Personaje y PNJ

Los personajes y PNJ tendrán atributos clave para el combate:
*   Salud (HP)
*   Maná/Energía (MP/EP)
*   Atributos primarios (Fuerza, Agilidad, Inteligencia)
*   Atributos secundarios (Ataque, Defensa, Probabilidad de Crítico)
# === FIN: docs/08_COMBAT_SYSTEM.md ===


# === INICIO: docs/09_SKILL_SYSTEM.md ===
# Sistema de Habilidades

*(Este documento es un borrador y se completará a medida que el Sistema de Habilidades sea diseñado e implementado).*

## Visión General

El Sistema de Habilidades de Runegram se basará en el principio de "aprender haciendo" (*learning by doing*). Los personajes mejorarán sus habilidades al usarlas exitosamente, en lugar de gastar puntos de experiencia de forma manual. La resolución de acciones se basará en una tirada de d100.

## Mecánica Central (d100)

1.  **Resolución de Acción:** Cuando un personaje intenta una acción basada en una habilidad (ej: forzar una cerradura), el sistema realiza una tirada de `d100` (un número aleatorio entre 1 y 100).
2.  **Comprobación:** La acción tiene éxito si `d100 <= Nivel de Habilidad del Personaje`.
3.  **Progresión:** Si la acción tiene éxito, el personaje tiene una probabilidad de ganar un punto (o una fracción de punto) en esa habilidad. La probabilidad de ganar un punto disminuirá a medida que el nivel de la habilidad aumente, haciendo que la progresión sea natural.

## Tipos de Habilidades

Las habilidades se dividirán en categorías, como:

*   **Habilidades de Combate:**
    *   `espadas`
    *   `hachas`
    *   `arcos`
    *   `parada`
    *   `esquiva`
*   **Habilidades Mágicas:**
    *   `evocacion`
    *   `alteracion`
    *   `necromancia`
*   **Habilidades de Artesanía y Generales:**
    *   `herreria`
    *   `alquimia`
    *   `forzar_cerraduras`
    *   `sigilo`

## Integración con el Sistema de Locks

Este sistema se integrará directamente con el `permission_service`. Se creará una nueva función de `lock`, `habilidad()`, que permitirá crear `lock strings` como:

*   `"habilidad(forzar_cerraduras)>50"`
*   `"habilidad(herreria)>75 and tiene_objeto(martillo_especial)"`
# === FIN: docs/09_SKILL_SYSTEM.md ===


# === INICIO: docs/03_ENGINE_SYSTEMS/01_COMMAND_SYSTEM.md ===
# Sistema de Comandos

El Sistema de Comandos es el corazón de la interacción del jugador con el mundo de Runegram. Está diseñado para ser robusto, extensible y, sobre todo, dinámico. Esta documentación desglosa su arquitectura, desde la estructura de un comando individual hasta cómo el sistema decide qué comandos están disponibles para un jugador en un momento dado.

## 1. Arquitectura General

El sistema se basa en tres componentes principales que trabajan en conjunto:

1.  **El Dispatcher Principal (`dispatcher.py`):** Un único manejador de Aiogram que actúa como el "cerebro" central. Intercepta todos los mensajes de texto y orquesta el proceso de identificación y ejecución del comando.
2.  **El Catálogo de Comandos (`COMMAND_SETS`):** Un diccionario global en el `dispatcher` que contiene una instancia de cada comando disponible en todo el juego, agrupados por funcionalidad en `CommandSets`.
3.  **El Servicio de Comandos (`command_service.py`):** La lógica de negocio que determina, en tiempo real, qué `CommandSets` están activos para un personaje según su contexto (rol, inventario, ubicación).

## 2. El Flujo de Ejecución de un Comando

Cuando un jugador envía un mensaje como `/mirar espada`, ocurre el siguiente flujo:

1.  **Intercepción:** El `main_command_dispatcher` recibe el objeto de mensaje de Aiogram.
2.  **Contextualización:** Se obtiene la `Account` y el `Character` del jugador desde la base de datos.
3.  **Determinación de Comandos Activos:** El `dispatcher` llama a `command_service.get_active_command_sets_for_character(character)`.
4.  **Construcción Dinámica (en `command_service`):**
    *   Se obtiene la lista de `CommandSets` base del personaje desde la base de datos.
    *   Se inspecciona el inventario del personaje para añadir `CommandSets` otorgados por objetos.
    *   Se inspecciona la sala actual para añadir `CommandSets` otorgados por la ubicación.
    *   Se comprueba el rol del jugador para añadir sets de administración.
    *   El servicio devuelve una lista unificada de todos los `CommandSets` activos.
5.  **Búsqueda y Ejecución:**
    *   El `dispatcher` itera sobre los nombres de los `CommandSets` activos.
    *   Para cada nombre, busca la lista de comandos correspondiente en el catálogo `COMMAND_SETS`.
    *   Compara los alias (`names`) de cada comando con el comando invocado (`mirar`).
    *   Cuando encuentra una coincidencia, ejecuta el método `.execute()` de esa instancia, pasándole el contexto.

## 3. La Clase `Command` (El Contrato)

Todo comando en el juego hereda de la clase base `Command` (`commands/command.py`). Esta clase define el "contrato" que todos los comandos deben cumplir:

*   `names` (list[str]): Una lista de alias.
*   `description` (str): El texto que se muestra en la lista de comandos de Telegram.
*   `lock` (str): El string de permisos evaluado por el `permission_service`.
*   `execute()` (async method): El método que contiene la lógica del comando.

## 4. Tipos de Comandos Implementados

### Comandos Generales y de Interacción
*   Comandos básicos como `/mirar`, `/decir`, `/ayuda` y `/quien`.
*   El comando `/inventario` (`/inv`) ha sido mejorado. Ahora puede usarse sin argumentos para ver el inventario del personaje, o con un argumento para ver el contenido de un contenedor (ej: `/inv mochila`).
*   Nuevos comandos para contenedores: `/meter <objeto> en <contenedor>` y `/sacar <objeto> de <contenedor>`.

### Generación Dinámica de Comandos
Para sistemas como los canales de chat, se utiliza un patrón de "fábrica":
*   Una clase genérica como `CmdDynamicChannel` define la lógica para "hablar por un canal".
*   Una función `generate_channel_commands()` lee los prototipos de `game_data` y crea una instancia de `CmdDynamicChannel` para cada canal de tipo `CHAT` (ej: `/novato`, `/sistema`).
*   Esta lista de comandos generados se registra como un `CommandSet` más en el `dispatcher`.

## 5. Sincronización con la Interfaz de Telegram

El motor actualiza la lista de comandos visibles en el menú `/` de Telegram en tiempo real.
*   **`command_service.update_telegram_commands(character)`:** Esta función es la responsable de esta tarea.
*   **Triggers:** Se llama en puntos clave donde el contexto del jugador puede cambiar: al entrar al juego, al moverse de sala, o al coger/dejar un objeto.
*   **Funcionamiento:** La función obtiene la lista completa de comandos activos, genera los objetos `BotCommand` y los envía a la API de Telegram usando un `BotCommandScopeChat` para que la actualización solo afecte al jugador específico.
# === FIN: docs/03_ENGINE_SYSTEMS/01_COMMAND_SYSTEM.md ===


# === INICIO: docs/03_ENGINE_SYSTEMS/02_PERMISSION_SYSTEM.md ===
# Sistema de Permisos (Locks)

El Sistema de Permisos, o sistema de `locks`, es el "guardián" de Runegram. Es un motor de reglas potente y extensible que determina si un personaje (`Character`) tiene permiso para realizar una acción determinada, como usar un comando, pasar por una salida o coger un objeto.

El diseño está inspirado en los sistemas de `locks` de frameworks de MUDs avanzados como Evennia y se basa en dos pilares: **`lock strings` expresivos** y un **motor de evaluación seguro**.

## 1. Arquitectura General

El sistema se compone de tres partes principales, todas encapsuladas en `src/services/permission_service.py`:

1.  **El Parser (basado en `ast`):** El corazón del sistema. En lugar de un parser manual, se utiliza el módulo `ast` (Abstract Syntax Tree) de Python para convertir de forma segura un `lock string` en un árbol de sintaxis que representa su estructura lógica.
2.  **El Evaluador (`LockEvaluator`):** Una clase que "camina" por el árbol de sintaxis generado por `ast` y evalúa el resultado booleano final. Es una caja de arena segura que solo permite ejecutar operadores lógicos (`and`, `or`, `not`) y llamadas a funciones de `lock` pre-aprobadas.
3.  **El Registro de Funciones de Lock (`LOCK_FUNCTIONS`):** Un diccionario que mapea los nombres de las funciones permitidas en un `lock string` (ej: `rol`) a las funciones de Python reales que implementan la lógica de comprobación (ej: `_lock_rol`).

## 2. El `Lock String`

Un `lock string` es una cadena de texto que define una o más condiciones que deben cumplirse. Gracias al uso de `ast`, la sintaxis es muy similar a una expresión booleana de Python.

### Operadores Soportados

*   **`and`**: Ambas condiciones deben ser verdaderas.
*   **`or`**: Al menos una de las condiciones debe ser verdadera.
*   **`not`**: Niega el resultado de una condición.
*   **`()`**: Permite agrupar condiciones para controlar el orden de evaluación.

### Funciones de Lock Disponibles

Actualmente, el sistema implementa las siguientes funciones de `lock`:

*   **`rol(ROL)`**: Comprueba si el rol del personaje es igual o superior al `ROL` especificado.
    *   **Jerarquía:** `SUPERADMIN > ADMIN > JUGADOR`.
    *   Un `SUPERADMIN` pasará las comprobaciones de `rol(ADMIN)` y `rol(JUGADOR)`.
    *   **Ejemplo:** `rol(ADMIN)`

*   **`tiene_objeto(clave_prototipo)`**: Comprueba si el personaje lleva un objeto con la `key` especificada en su inventario.
    *   **Ejemplo:** `tiene_objeto(llave_maestra)`

### Ejemplos de `Lock Strings` Complejos

```python
# Solo un ADMIN o superior puede pasar.
"rol(ADMIN)"

# El personaje debe llevar la llave de la torre en su inventario.
"tiene_objeto(llave_torre)"

# Debe ser un ADMIN Y llevar la llave.
"rol(ADMIN) and tiene_objeto(llave_torre)"

# Debe ser un SUPERADMIN O llevar la llave especial.
"rol(SUPERADMIN) or tiene_objeto(llave_especial)"

# Cualquiera puede pasar, EXCEPTO los JUGADORES (es decir, solo ADMINS y superiores).
"not rol(JUGADOR)"

# Un lock complejo: debe ser un ADMIN que lleve la llave, O ser un SUPERADMIN.
"(rol(ADMIN) and tiene_objeto(llave_gremio)) or rol(SUPERADMIN)"
```

## 3. Flujo de Evaluación de un Permiso

Cuando una parte del juego necesita comprobar un permiso (ej: el `dispatcher` para un comando, o `CmdMove` para una salida), se llama a `permission_service.can_execute(character, lock_string)`.

1.  **Parseo:** `ast.parse(lock_string, mode='eval')` convierte el string en un árbol de nodos. Si la sintaxis es inválida, se lanza un `SyntaxError`.
2.  **Creación del Evaluador:** Se crea una instancia de `LockEvaluator`, pasándole el objeto `character` que intenta la acción. Este `character` es el contexto contra el cual se evaluarán todas las condiciones.
3.  **Recorrido del Árbol:** El método `evaluator.visit(tree)` comienza a "caminar" por el árbol.
    *   Si encuentra un nodo `BoolOp` (`and`/`or`), evalúa recursivamente sus hijos y combina los resultados.
    *   Si encuentra un nodo `UnaryOp` (`not`), evalúa recursivamente su operando y niega el resultado.
    *   Si encuentra un nodo `Call` (una función como `rol(...)`), busca el nombre (`rol`) en el registro `LOCK_FUNCTIONS`. Si lo encuentra, ejecuta la función de Python correspondiente (`_lock_rol`), pasándole el `character` y los argumentos parseados. Si no lo encuentra, devuelve `False`.
    *   Cualquier otro tipo de nodo (asignaciones, bucles, etc.) no está permitido y lanzará un `TypeError`, lo que garantiza la seguridad del sistema.
4.  **Resultado:** La función `can_execute` devuelve una tupla `(True, "")` si el resultado final es verdadero, o `(False, "Mensaje de error")` si es falso.

## 4. Cómo Extender el Sistema

Añadir un nuevo tipo de `lock` (ej: `habilidad(magia)>10`) es un proceso de tres pasos:

1.  **Crear la Lógica:** Escribir una nueva función de chequeo en `permission_service.py`, similar a `_lock_rol`. Esta función recibiría `character` y una lista de argumentos (`["magia>10"]`).
2.  **Registrar la Función:** Añadir la nueva función al diccionario `LOCK_FUNCTIONS` con su nombre en minúsculas.
    ```python
    LOCK_FUNCTIONS = {
        # ...
        "habilidad": _lock_habilidad,
    }
    ```
3.  **Usar en Contenido:** ¡Listo! Ahora los diseñadores pueden empezar a escribir `lock strings` como `"habilidad(magia)>10"` en sus prototipos.

Este diseño hace que el Sistema de Permisos sea una de las herramientas más potentes y escalables del motor de Runegram.
# === FIN: docs/03_ENGINE_SYSTEMS/02_PERMISSION_SYSTEM.md ===


# === INICIO: docs/03_ENGINE_SYSTEMS/03_PROTOTYPE_SYSTEM.md ===
# Sistema de Prototipos

El Sistema de Prototipos es la implementación central de la filosofía "Motor vs. Contenido" en Runegram. Es un enfoque de diseño dirigido por datos (Data-Driven) que separa la **definición** de una entidad de su **instancia** en el mundo.

## 1. El Concepto: Prototipo vs. Instancia

Para entender el sistema, es crucial diferenciar estos dos conceptos:

*   **Prototipo (El "Plano"):**
    *   **¿Qué es?** Es la plantilla o el plano maestro que define un *tipo* de entidad. Contiene todos los datos base que son comunes a todas las entidades de ese tipo.
    *   **¿Dónde vive?** En los archivos de `game_data/` (ej: `item_prototypes.py`, `room_prototypes.py`).
    *   **Ejemplo:** El prototipo de la "espada viviente" define que su nombre es "una espada viviente", su descripción, que susurra cada 2 minutos, y que brilla al ser mirada.

*   **Instancia (La "Copia"):**
    *   **¿Qué es?** Es una copia única y específica de un prototipo que existe en el mundo del juego en un momento dado.
    *   **¿Dónde vive?** Como una fila en una tabla de la base de datos (ej: la tabla `items` o `rooms`).
    *   **Ejemplo:** Pueden existir tres "espadas vivientes" en el juego. Cada una es una `Instancia` diferente (con un `id` único en la tabla `items`), pero todas apuntan al mismo `Prototipo` "espada_viviente" a través de su columna `key`.

## 2. Ventajas del Sistema de Prototipos

Este enfoque ofrece enormes ventajas en escalabilidad y mantenimiento:

1.  **Eficiencia de Datos:** La base de datos no necesita almacenar el nombre, la descripción, los scripts y los tickers de cada una de las 100 espadas del juego. Solo almacena la `key` del prototipo y su ubicación. El resto de la información se lee desde el diccionario de prototipos en memoria.
2.  **Facilidad de Creación de Contenido:** Para crear un nuevo tipo de objeto, un diseñador solo necesita añadir una nueva entrada al diccionario `ITEM_PROTOTYPES`. No se requiere ninguna modificación en el código del motor ni en el esquema de la base de datos.
3.  **Actualizaciones Globales Sencillas:** Si necesitas corregir un error en la descripción de la "espada viviente", solo lo cambias en el prototipo. Automáticamente, todas las instancias de esa espada en el juego reflejarán el cambio.

## 3. Estructura de los Prototipos

### Prototipos de Objetos (`item_prototypes.py`)

La clave del diccionario es una `key` única para el tipo de objeto.

```python
"cofre_roble": {
    # --- Atributos Básicos ---
    "name": "un cofre de roble",
    "keywords": ["cofre", "roble"],
    "description": "Un pesado cofre de madera con refuerzos de hierro.",

    # --- Atributos de Comportamiento (Opcional) ---
    "scripts": { "on_look": "script_notificar_brillo_magico(color=tenue)" },
    "tickers": [{ "schedule": "...", "script": "...", "category": "..." }],

    # --- Atributos de Sistema (Opcional) ---
    "grants_command_sets": ["secretos_cofre"],
    "locks": "rol(SUPERADMIN) or tiene_objeto(llave_maestra)",

    # --- Atributos de Contenedor (Opcional) ---
    "is_container": True,
    "capacity": 20
}
```
*   **`locks`**: Para un objeto normal, restringe el comando `/coger`. Para un contenedor, restringe `/meter`, `/sacar` y `/inv`.
*   **`is_container`**: Si es `True`, el objeto puede contener otros ítems.
*   **`capacity`**: El número máximo de ítems que puede albergar el contenedor.

### Prototipos de Salas (`room_prototypes.py`)

La clave del diccionario es una `key` única para la sala, utilizada para las conexiones.

```python
"plaza_central": {
    # --- Atributos Básicos ---
    "name": "Plaza Central de Runegard",
    "description": "Estás en el corazón de la ciudad...",

    # --- Atributos de Conexión (Opcional) ---
    "exits": {
        "norte": {
            "to": "puerta_del_norte",
            "locks": "tiene_objeto(salvoconducto_real)"
        },
        "este": "calle_mercaderes" # Sintaxis simple
    },

    # --- Atributos de Sistema (Opcional) ---
    "grants_command_sets": ["comercio_ciudad"],

    # --- Atributos de Entorno (Opcional) ---
    "details": {
        "fuente": {
            "keywords": ["fuente", "marmol"],
            "description": "Una magnífica fuente esculpida en mármol blanco..."
        }
    }
}
```
*   **`exits`**: Puede usar una sintaxis simple (`"direccion": "destino"`) para una salida bidireccional sin `lock`, o una sintaxis avanzada (`"direccion": {"to": "destino", "locks": "..."}`) para añadir un `lock` a la salida de ida.
*   **`details`**: Permite definir elementos de la descripción que se pueden `mirar` con `/mirar [keyword]` sin ser objetos físicos.

## 4. Conexión en el Código (Modelos)

Los modelos de SQLAlchemy (`Item` y `Room`) actúan como el puente entre la **Instancia** (base de datos) y el **Prototipo** (código) a través de una propiedad `@property`.

```python
# En src/models/item.py

class Item(Base):
    # ... columnas de la instancia (id, key, room_id) ...

    @property
    def prototype(self) -> dict:
        """
        Esta propiedad busca en el diccionario ITEM_PROTOTYPES usando
        la `self.key` de la instancia y devuelve el diccionario del prototipo.
        """
        return ITEM_PROTOTYPES.get(self.key, {})
```

Todos los servicios y comandos del motor interactúan con las instancias de los modelos, pero utilizan la propiedad `.prototype` para acceder a la definición de contenido, manteniendo la separación limpia.
# === FIN: docs/03_ENGINE_SYSTEMS/03_PROTOTYPE_SYSTEM.md ===


# === INICIO: docs/03_ENGINE_SYSTEMS/04_SCRIPTING_ENGINE.md ===
# Motor de Scripts

El Motor de Scripts es el sistema que permite que el **Contenido** del juego (definido en `game_data`) pueda ejecutar **Lógica** del juego (definida en el `src/services`). Es el mecanismo que da comportamiento a los objetos y al mundo.

El motor tiene una arquitectura dual, separando las acciones que son una **reacción** a algo que hace el jugador (Eventos) de las acciones que ocurren de forma **proactiva** con el tiempo (Tickers). Toda la lógica está centralizada en `src/services/script_service.py`.

## 1. El `script_service`

Este servicio actúa como un "traductor" e "invocador" seguro. Su funcionamiento es análogo al del `permission_service`:

1.  **Registro de Funciones (`SCRIPT_REGISTRY`):** Es un diccionario que mapea nombres de script (en formato string, ej: `"script_espada_susurra_secreto"`) a las funciones de Python reales que contienen la lógica.
2.  **Parser de Scripts (`_parse_script_string`):** Una función simple que toma un string como `"nombre_script(arg1=valor1)"` y lo descompone en el nombre de la función y un diccionario de argumentos.
3.  **Ejecutor (`execute_script`):** Es el corazón del servicio. Recibe un `script_string` y un `contexto` (que contiene los objetos relevantes como `character`, `target`, `room`), busca la función en el registro y la ejecuta de forma segura, pasándole el contexto y los argumentos.

## 2. Scripts Reactivos (Eventos)

Estos scripts se ejecutan como respuesta directa a una acción del jugador.

*   **Definición:** Se definen en la clave `"scripts"` de un prototipo. La clave del diccionario es el nombre del evento (el "trigger") y el valor es el `script_string`.

    ```python
    # En game_data/item_prototypes.py
    "espada_viviente": {
        "scripts": {
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        }
    }
    ```

*   **Flujo de Ejecución (Ejemplo: `/mirar espada`):**
    1.  El jugador ejecuta el comando `/mirar`.
    2.  La lógica de `CmdLook.execute()` encuentra el objeto `Item` de la espada.
    3.  Después de mostrar la descripción, el comando comprueba si el prototipo del objeto tiene una clave `"on_look"` dentro de `"scripts"`.
    4.  Si la encuentra, llama a `script_service.execute_script()` pasándole el `script_string` `"script_notificar_brillo_magico(color=rojo)"` y el contexto (`character` y `target`).
    5.  El `script_service` parsea el string, encuentra `script_notificar_brillo_magico` en su registro y la ejecuta.

Actualmente, el único evento implementado es `on_look`, pero la arquitectura permite añadir fácilmente nuevos "triggers" en otros comandos (`on_get`, `on_drop`, `on_enter_room`, etc.).

## 3. Scripts Proactivos (Tickers)

Estos scripts se ejecutan de forma programada, haciendo que el mundo se sienta vivo incluso cuando los jugadores no hacen nada. Están gestionados por el `ticker_service`.

*   **Definición:** Se definen como una lista en la clave `"tickers"` de un prototipo. Cada elemento es un diccionario que define una tarea programada.

    ```python
    # En game_data/item_prototypes.py
    "espada_viviente": {
        "tickers": [{
            "schedule": "*/2 * * * *",  # Un cronjob: "cada 2 minutos"
            "script": "script_espada_susurra_secreto",
            "category": "ambient"
        }]
    }
    ```

*   **Flujo de Ejecución:**
    1.  **Arranque del Bot:** El `ticker_service` escanea la base de datos en busca de entidades existentes que tengan tickers y las programa en `APScheduler`.
    2.  **Creación de Entidad:** Cuando se crea un nuevo objeto (`/generarobjeto`), el `item_service` notifica al `ticker_service` para que programe sus tickers.
    3.  **Disparo:** Cuando el `schedule` se cumple, `APScheduler` ejecuta la función `execute_ticker_script` del `ticker_service`.
    4.  **Contextualización y Filtrado (en `ticker_service`):**
        *   Se recupera la entidad (la espada) y su ubicación (la sala, o la sala del personaje que la lleva).
        *   Se obtienen todos los personajes en esa sala.
        *   Se itera sobre cada personaje y se comprueba si está "online" (`online_service`). Si el ticker es de categoría `"ambient"` y el jugador está inactivo, se le ignora.
    5.  **Ejecución Final:** Por cada personaje que pasa el filtro, se llama a `script_service.execute_script()` con el `script_string` y el contexto (`target`, `room`, y el `character` específico que va a recibir el efecto).

## 4. Cómo Crear una Nueva "Habilidad" de Script

Para dar a los diseñadores de contenido una nueva herramienta (ej: un script que haga que un objeto se mueva a una sala aleatoria), un desarrollador del motor debe seguir estos pasos:

1.  **Escribir la Lógica:** Añadir una nueva función `async` en `src/services/script_service.py`. Debe aceptar `session` y `**context` como argumentos.
    ```python
    async def script_teleport_aleatorio(session: AsyncSession, target: Item, **kwargs):
        # Lógica para encontrar una sala aleatoria y mover el 'target' (el objeto).
        # ...
        await broadcaster_service.send_message_to_room(...)
    ```
2.  **Registrar la Función:** Añadir la nueva función y su nombre en string al diccionario `SCRIPT_REGISTRY`.
    ```python
    SCRIPT_REGISTRY = {
        # ...
        "script_teleport_aleatorio": script_teleport_aleatorio,
    }
    ```
3.  **Documentar para Diseñadores:** ¡Listo! Ahora un diseñador puede usar `"script": "script_teleport_aleatorio"` en un `ticker` o en un `evento` para hacer que los objetos se teletransporten.
# === FIN: docs/03_ENGINE_SYSTEMS/04_SCRIPTING_ENGINE.md ===


# === INICIO: docs/03_ENGINE_SYSTEMS/05_SOCIAL_SYSTEMS.md ===
# Sistemas Sociales: Presencia y Canales

Un MUD (Multi-User Dungeon) es, por definición, una experiencia social. Runegram implementa dos sistemas clave que trabajan juntos para crear la sensación de un mundo compartido y vivo: el **Sistema de Presencia** (que gestiona quién está "online") y el **Sistema de Canales** (que gestiona la comunicación global).

## 1. Sistema de Presencia (Online / AFK)

Debido a la naturaleza asíncrona de un bot de Telegram, no existe una "conexión" persistente con el jugador. Por lo tanto, el concepto de "online" se redefine como: **"¿Ha interactuado el jugador con el juego recientemente?"**

Toda esta lógica está encapsulada en `src/services/online_service.py`.

### Arquitectura

*   **Almacenamiento en Redis:** Para una velocidad máxima, el estado de actividad no se guarda en PostgreSQL. Se utiliza Redis para almacenar dos piezas de información por cada personaje:
    1.  `last_seen:<character_id>`: Un timestamp de Unix que registra la última vez que el personaje envió un comando.
    2.  `afk_notified:<character_id>`: Un "flag" o marcador que indica si ya se le ha notificado al jugador que ha entrado en estado AFK.

*   **Umbral de Actividad (`ONLINE_THRESHOLD`):** Una constante (actualmente 5 minutos) que define el tiempo máximo de inactividad antes de que un jugador se considere "offline" o AFK.

### Flujo de Funcionamiento

1.  **Actualización de Actividad (`update_last_seen`):**
    *   En cada mensaje recibido, el `dispatcher` principal llama a esta función.
    *   Actualiza el `timestamp` `last_seen` del personaje en Redis a la hora actual.
    *   Comprueba si existía un `flag` `afk_notified`. Si es así, significa que el jugador estaba AFK y acaba de volver. En este caso, le envía un mensaje privado ("Has vuelto de tu inactividad.") y borra el `flag`.

2.  **Chequeo Periódico de AFK (`check_for_newly_afk_players`):**
    *   El `ticker_service` ejecuta esta tarea global cada 60 segundos.
    *   La tarea mantiene una lista en memoria (`PREVIOUSLY_ONLINE_IDS`) de quién estaba online en el chequeo anterior.
    *   Compara esa lista con quién está online *ahora*.
    *   Cualquier jugador que estuviera en la lista anterior pero no en la actual acaba de pasar a estado AFK.
    *   A estos jugadores recién inactivos, les envía un mensaje privado ("Has entrado en modo de inactividad (AFK).") y establece su `flag` `afk_notified` en Redis para no volver a notificarles.
    *   Finalmente, actualiza `PREVIOUSLY_ONLINE_IDS` para el siguiente ciclo.

Este sistema dual asegura notificaciones de estado AFK precisas y sin spam.

## 2. Sistema de Canales

El Sistema de Canales proporciona un medio para la comunicación global entre jugadores, así como para anuncios del sistema. Está gestionado por `src/services/channel_service.py`.

### Arquitectura "Data-Driven"

*   **Prototipos de Canal (`game_data/channel_prototypes.py`):** Es la "fuente de la verdad". Define todos los canales, su nombre, icono, descripción y, lo más importante, su **tipo** y sus **permisos**.
    *   `"type": "CHAT"`: Indica al sistema que debe generar dinámicamente un comando (ej: `/novato`) para que los jugadores puedan hablar en este canal.
    *   `"lock": "rol(ADMIN)"`: Un `lock string` opcional que se asigna al comando generado, restringiendo quién puede hablar.

*   **Configuración de Usuario (`CharacterSetting`):** La suscripción de un jugador a un canal se almacena en la base de datos, en la columna `active_channels` de su tabla de `character_settings`. Esto hace que sus preferencias sean persistentes.

### Flujo de Funcionamiento

*   **Hablar en un Canal (ej: `/novato ¡hola!`):**
    1.  El `dispatcher` identifica el comando `/novato`, que fue generado dinámicamente por el módulo `dynamic_channels`.
    2.  Se comprueban los `locks` del comando (leídos desde el prototipo del canal).
    3.  `CmdDynamicChannel.execute()` se ejecuta. Llama a `channel_service` para comprobar si el jugador está suscrito al canal "novato".
    4.  Si está suscrito, se llama a `channel_service.broadcast_to_channel()`.
    5.  Esta función recupera de la base de datos a **todos los personajes del juego**.
    6.  Itera sobre ellos, y para cada uno, comprueba si tiene el canal "novato" activo en su configuración.
    7.  Si es así, utiliza el `broadcaster_service` para enviarle el mensaje formateado.

*   **Gestión de Canales:**
    *   `/canales`: Lista todos los prototipos de canal y muestra si el jugador está suscrito a cada uno.
    *   `/activarcanal <nombre>` y `/desactivarcanal <nombre>`: Modifican la lista de `active_channels` en la configuración del personaje en la base de datos.
# === FIN: docs/03_ENGINE_SYSTEMS/05_SOCIAL_SYSTEMS.md ===


# === INICIO: docs/04_CONTENT_CREATION/01_CREATING_COMMANDS.md ===
# Guía Práctica: Creando Comandos

Esta guía te mostrará el proceso paso a paso para añadir un nuevo comando a Runegram. Gracias a la arquitectura del sistema, este proceso es sencillo y está bien estructurado.

Como ejemplo, crearemos un comando `/orar`, que permitirá a los jugadores rezar y recibir una bendición simple.

## Paso 1: Elegir o Crear el `CommandSet`

Primero, decide a qué grupo funcional pertenece tu nuevo comando. ¿Es una interacción general? ¿Una acción de combate? ¿Una habilidad de una clase específica?

Para nuestro comando `/orar`, parece una acción general de "rol-playing". Lo añadiremos al `CommandSet` `GENERAL_COMMANDS` que ya existe.

Si estuvieras creando un sistema completamente nuevo (ej: combate), crearías un nuevo archivo como `commands/player/combat.py` y una nueva lista exportada como `COMBAT_COMMANDS`.

## Paso 2: Crear la Clase del Comando

Abre el archivo correspondiente. En nuestro caso, `commands/player/general.py`. Al final del archivo, antes de la línea `GENERAL_COMMANDS = [...]`, añade la nueva clase para tu comando.

Toda clase de comando debe heredar de `Command` y definir, como mínimo, los atributos `names` y `description`, y sobrescribir el método `execute`.

```python
# En commands/player/general.py

# ... (importaciones y otras clases de comando) ...

class CmdOrar(Command):
    """
    Comando que permite al jugador rezar a los dioses.
    """
    # Lista de alias. El primero es el nombre principal.
    names = ["orar", "rezar"]

    # Descripción que aparecerá en la lista de comandos de Telegram.
    description = "Rezas a los dioses en busca de inspiración."

    # String de permisos. Una cadena vacía significa que no hay restricciones.
    lock = ""

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """
        La lógica que se ejecuta cuando un jugador escribe /orar.
        """
        try:
            # Aquí va la lógica de tu comando.
            # Puedes interactuar con los servicios, la base de datos, etc.

            # Para este ejemplo, solo enviaremos un mensaje al jugador.
            response_text = "Bajas la cabeza y murmuras una plegaria. Sientes una cálida sensación de esperanza."

            # También podrías notificar a otros en la sala (futura mejora del broadcaster).
            # await broadcaster_service.send_to_room_from_character(
            #     character, f"{character.name} baja la cabeza y reza en silencio."
            # )

            await message.answer(response_text)

        except Exception:
            # Un bloque try/except es una buena práctica para capturar errores
            # inesperados y evitar que el bot se caiga.
            await message.answer("❌ Ocurrió un error al intentar procesar tu plegaria.")
            logging.exception(f"Fallo al ejecutar /orar para {character.name}")

```

## Paso 3: Añadir el Comando al `CommandSet`

Ahora que la clase está creada, simplemente añade una instancia de ella a la lista del `CommandSet` al final del archivo.

```python
# En commands/player/general.py

# ... (definición de la clase CmdOrar) ...

# Exportamos la lista de comandos de este módulo.
GENERAL_COMMANDS = [
    CmdLook(),
    CmdSay(),
    CmdInventory(),
    CmdHelp(),
    CmdWho(),
    CmdOrar(),  # <-- AÑADE LA NUEVA INSTANCIA AQUÍ
]
```

## Paso 4: ¡Reiniciar y Probar!

**¡Y eso es todo!** No necesitas modificar el `dispatcher` ni ningún otro servicio del motor.

1.  Reinicia tus contenedores para que los cambios en el código se apliquen.
    ```bash
    docker-compose up -d
    ```
2.  Entra al juego y envía `/start`. El `command_service` detectará el nuevo comando en el `CommandSet` `general` y lo añadirá automáticamente a tu lista de comandos en Telegram.
3.  Prueba a ejecutar `/orar`. Deberías recibir el mensaje de respuesta que definiste.

Este flujo de trabajo demuestra el poder del sistema: añadir nuevas funcionalidades se reduce a crear un archivo autocontenido y añadir una sola línea a una lista, manteniendo el resto del motor intacto y estable.
# === FIN: docs/04_CONTENT_CREATION/01_CREATING_COMMANDS.md ===


# === INICIO: docs/04_CONTENT_CREATION/02_BUILDING_THE_WORLD.md ===
# Guía Práctica: Construyendo el Mundo

Gracias a la arquitectura "Data-Driven" de Runegram, expandir el mundo del juego es una tarea de diseño de contenido, no de programación del motor. Esta guía te mostrará cómo añadir nuevas salas, objetos con `locks`, contenedores y canales, simplemente editando archivos de datos en la carpeta `game_data/`.

## 1. Construyendo Salas y Salidas con Locks

**Archivo a editar:** `game_data/room_prototypes.py`

### Sintaxis de Salidas (Exits)

Para conectar salas, se usa la clave `"exits"`. Tienes dos formas de definir una salida:

#### a) Sintaxis Simple (Bidireccional y sin Lock)

Si solo proporcionas un string con la `key` de la sala de destino, el motor creará una salida bidireccional y sin restricciones.

```python
"plaza_central": {
    "exits": { "oeste": "biblioteca_antigua" }
},
"biblioteca_antigua": {
    # No es necesario definir "este": "plaza_central" aquí.
    # El motor lo creará automáticamente.
}
```

#### b) Sintaxis Avanzada (con Locks)

Para añadir un `lock` a una salida, debes usar un diccionario. Esto te permite especificar la sala de destino y el `lock_string`.

**Importante:** Cuando usas la sintaxis avanzada, el `lock` se aplica **solo a la salida de ida**. La salida de vuelta se crea automáticamente sin `lock`.

**Ejemplo:** Vamos a crear una "Armería" a la que solo se puede entrar siendo `ADMIN` y teniendo una llave.

```python
"plaza_central": {
    "exits": {
        "norte": {
            "to": "armeria",
            "locks": "rol(ADMIN) and tiene_objeto(llave_armeria)"
        }
    }
},
"armeria": {
    "name": "La Armería de Runegard"
    # El motor creará la salida "sur" de vuelta a la "plaza_central" sin lock.
}
```
**Resultado:** Un jugador podrá salir libremente de la armería hacia el sur, pero para entrar desde la plaza hacia el norte, deberá cumplir las dos condiciones del `lock`.

### Añadiendo Detalles Interactivos
Puedes añadir elementos a una sala que se pueden `mirar` pero que no son objetos físicos usando la clave `"details"`.

```python
"plaza_central": {
    "description": "...Una imponente fuente de mármol domina el centro...",
    "details": {
        "fuente": {
            "keywords": ["fuente", "marmol"],
            "description": "Es una magnífica fuente esculpida en mármol blanco..."
        }
    }
},
```
**Resultado:** El comando `/mirar fuente` funcionará en esta sala.

## 2. Creando Objetos, Locks y Contenedores

**Archivo a editar:** `game_data/item_prototypes.py`

### Objetos con `lock` para Coger

Puedes restringir quién puede coger un objeto usando la clave `"locks"`.

```python
"espada_sagrada_antigua": {
    "name": "la Espada Sagrada Antigua",
    "keywords": ["espada", "sagrada", "antigua"],
    "description": "Una hoja legendaria que vibra con un poder inmenso.",
    "locks": "rol(SUPERADMIN)" # Solo un Superadmin puede coger este objeto.
}
```
**Resultado:** Cuando un jugador que no sea `SUPERADMIN` intente usar `/coger espada`, el comando `CmdGet` evaluará el `lock` y denegará la acción.

### Creando Contenedores

Para convertir un objeto en un contenedor, debes añadir dos claves: `"is_container": True` y `"capacity": <número>`.

#### a) Contenedor Portátil (Mochila)

```python
"mochila_cuero": {
    "name": "una mochila de cuero",
    "keywords": ["mochila", "cuero"],
    "description": "Una mochila simple pero resistente.",
    "is_container": True,
    "capacity": 10
}
```
Un jugador puede coger esta mochila y usar `/meter` y `/sacar` para gestionar su contenido.

#### b) Contenedor Fijo y Cerrado (Cofre)

Puedes combinar `locks` y propiedades de contenedor para crear objetos como cofres.

```python
"cofre_roble": {
    "name": "un cofre de roble",
    "keywords": ["cofre", "roble"],
    "description": "Un pesado cofre de madera con refuerzos de hierro.",
    "is_container": True,
    "capacity": 20,
    // El lock "rol(SUPERADMIN)" evita que nadie pueda coger el cofre del suelo.
    "locks": "tiene_objeto(llave_roble) or rol(ADMIN)"
}
```
**Resultado:**
*   Nadie podrá coger el cofre (`/coger cofre`) debido al `lock` `rol(SUPERADMIN)` (una forma de hacerlo inamovible).
*   Un jugador solo podrá interactuar con el cofre (`/meter`, `/sacar`, `/inv cofre`) si lleva la "llave_roble" o si es un `ADMIN`.

## 3. Añadiendo Canales de Chat

**Archivo a editar:** `game_data/channel_prototypes.py`

Para crear un nuevo canal donde los jugadores puedan hablar, como `/comercio`:

```python
"comercio": {
    "name": "Comercio",
    "icon": "💰",
    "description": "Para comprar, vender e intercambiar objetos.",
    "type": "CHAT",
    "default_on": True,
    "lock": "" // Sin lock, cualquiera puede hablar.
}
```
Al reiniciar el bot, el comando `/comercio` se creará automáticamente. Si quisieras que solo los administradores pudieran hablar, simplemente añadirías `"lock": "rol(ADMIN)"`.
# === FIN: docs/04_CONTENT_CREATION/02_BUILDING_THE_WORLD.md ===


# === INICIO: docs/04_CONTENT_CREATION/03_WRITING_SCRIPTS.md ===
# Guía Práctica: Escribiendo Scripts

El Motor de Scripts es lo que permite que el contenido del juego tenga comportamiento. Es el puente que conecta las definiciones de datos con la lógica del motor, dando vida a los objetos y al mundo.

Esta guía se divide en dos partes:
1.  **Para Diseñadores de Contenido:** Cómo *usar* los scripts existentes en los prototipos.
2.  **Para Desarrolladores del Motor:** Cómo *crear* nuevas funciones de script.

## 1. Para Diseñadores de Contenido: Usando Scripts

Como diseñador, no necesitas escribir código Python. Solo necesitas saber qué "habilidades" de script existen y cómo invocarlas desde los archivos de `game_data`.

Los scripts se invocan a través de `script strings`, que tienen un formato de llamada de función: `nombre_del_script(argumento=valor)`.

### Usando Scripts de Evento (`on_look`)

Los scripts de evento reaccionan a las acciones de los jugadores. Actualmente, el principal evento es `on_look`.

*   **Uso:** Se añade a la clave `"scripts"` en el prototipo de un objeto.
*   **Función Disponible:** `script_notificar_brillo_magico(color=...)`
    *   **Propósito:** Envía un mensaje privado al jugador que mira el objeto, indicando que este emite un brillo.
    *   **Argumento:** `color` (opcional, string). Define el color del brillo. Si no se especifica, usa un color por defecto.

**Ejemplo:**
```python
# En game_data/item_prototypes.py
"amuleto_antiguo": {
    "name": "un amuleto antiguo",
    "description": "Una joya opaca que parece absorber la luz.",
    "scripts": {
        "on_look": "script_notificar_brillo_magico(color=púrpura)"
    }
}
```
**Resultado:** Cuando un jugador escriba `/mirar amuleto`, primero verá la descripción y luego recibirá un mensaje privado que dice: "...notas que emite un suave brillo de color púrpura."

### Usando Scripts Proactivos (`tickers`)

Los tickers hacen que el mundo actúe por sí solo. Se definen en la clave `"tickers"` de un prototipo.

*   **Uso:** Es una lista de diccionarios, donde cada diccionario es una tarea programada.
*   **Claves:**
    *   `"schedule"`: Define cuándo se ejecuta. Puede ser un `cron` (ej: `"*/5 * * * *"`) o un intervalo en segundos (ej: `"interval:30"`).
    *   `"script"`: El `script_string` a ejecutar.
    *   `"category"`: La categoría. Si es `"ambient"`, solo se ejecutará para jugadores considerados "online", para no enviar spam.

*   **Función Disponible:** `script_espada_susurra_secreto()`
    *   **Propósito:** Envía un mensaje privado a cada jugador "online" en la misma sala que el objeto, con un "secreto" aleatorio.
    *   **Argumentos:** Ninguno.

**Ejemplo:**
```python
# En game_data/item_prototypes.py
"craneo_susurrante": {
    "name": "un cráneo susurrante",
    "description": "Un cráneo amarillento que parece murmurar cuando no lo miras directamente.",
    "tickers": [{
        "schedule": "*/5 * * * *", # Cada 5 minutos
        "script": "script_espada_susurra_secreto",
        "category": "ambient"
    }]
}
```
**Resultado:** Cada 5 minutos, todos los jugadores activos en la misma sala que el cráneo recibirán un mensaje privado con un susurro.

## 2. Para Desarrolladores del Motor: Creando Nuevas Funciones de Script

Para expandir las capacidades del juego, los desarrolladores del motor pueden crear nuevas funciones de script. El proceso es simple y seguro.

**Archivo a editar:** `src/services/script_service.py`

### Paso 1: Escribir la Función de Lógica

Crea una nueva función `async` en la "SECCIÓN 1" del archivo. La función debe aceptar `session` y `**context` como argumentos. El `context` es un diccionario que contiene los objetos relevantes al evento que disparó el script.

**Ejemplo:** Vamos a crear un script que cure ligeramente al personaje que mira un objeto.

```python
# En src/services/script_service.py

# ... (otras importaciones) ...

async def script_curacion_menor(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Cura una pequeña cantidad de vida al personaje.

    - Disparador Típico: on_look
    - Contexto Esperado: character (quien es curado), target (el objeto que cura).
    - Argumentos: cantidad (int, opcional)
    """
    # (Lógica futura: cuando el personaje tenga un atributo de vida)
    # curacion = int(kwargs.get("cantidad", 5))
    # character.vida_actual += curacion
    # await session.commit()

    # Por ahora, solo notificamos al jugador.
    mensaje = f"Sientes una oleada de energía restauradora emanando de {target.get_name()}."
    await broadcaster_service.send_message_to_character(character, mensaje)
```

### Paso 2: Registrar la Nueva Función

Añade la función y su nombre en string al diccionario `SCRIPT_REGISTRY` en la "SECCIÓN 2".

```python
# En src/services/script_service.py

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,

    # --- NUEVO SCRIPT REGISTRADO ---
    "script_curacion_menor": script_curacion_menor,
}
```

### Paso 3: Documentar para Diseñadores

¡Listo! La nueva "habilidad" del motor está disponible. Ahora un diseñador de contenido puede crear un objeto como este:

```python
# En game_data/item_prototypes.py
"piedra_vital": {
    "name": "una piedra de vitalidad",
    "description": "Una piedra suave y cálida al tacto.",
    "scripts": {
        "on_look": "script_curacion_menor(cantidad=10)"
    }
}
```

Este ciclo de desarrollo (crear, registrar, usar) permite al motor crecer en capacidades sin mezclar su lógica con la definición del contenido.
# === FIN: docs/04_CONTENT_CREATION/03_WRITING_SCRIPTS.md ===


# === INICIO: game_data/__init__.py ===
# === FIN: game_data/__init__.py ===


# === INICIO: game_data/channel_prototypes.py ===
# game_data/channel_prototypes.py
"""
Definición de Prototipos de Canales de Chat.

Este archivo actúa como la "Fuente de la Verdad" para todos los canales de
comunicación globales disponibles en el juego. El `channel_service` utiliza
esta información para gestionar las suscripciones y formatear los mensajes.

Añadir un nuevo canal al juego es tan simple como añadir una nueva entrada
a este diccionario.

Estructura de un Prototipo de Canal:
- <clave_unica>: (ej: "novato")
    - "name": (str) El nombre del canal que ven los jugadores.
    - "icon": (str) Un icono emoji que precede a los mensajes del canal.
    - "description": (str) Una breve explicación que se muestra en el comando /canales.
    - "type": (str) Define si se debe generar un comando para hablar en el canal.
        - "CHAT": Se generará un comando dinámico (ej: /novato) para que los jugadores hablen.
    - "default_on": (bool) Si es `True`, los nuevos personajes se suscriben
                    automáticamente a este canal al ser creados.
    - "lock": (str, opcional) Un lock string que se aplica al comando de chat generado.
             Permite restringir quién puede hablar en el canal.
"""

CHANNEL_PROTOTYPES = {
    # Canal para que los nuevos jugadores puedan hacer preguntas.
    "novato": {
        "name": "Novato",
        "icon": "📢",
        "description": "Un canal para que los nuevos aventureros pidan ayuda.",
        "type": "CHAT",
        "default_on": True,
        "lock": "", # Sin lock, cualquiera puede hablar.
    },

    # Canal para notificaciones automáticas del juego y comunicación de administradores.
    "sistema": {
        "name": "Sistema",
        "icon": "⚙️",
        "description": "Anuncios del juego y notificaciones automáticas.",
        "type": "CHAT", # Es de tipo CHAT para que se genere el comando /sistema.
        "default_on": True,
        # Se añade un lock para que solo los ADMINS o superior puedan hablar en él.
        "lock": "rol(ADMIN)"
    },

    # --- Futuros canales podrían ir aquí ---
    # "comercio": {
    #     "name": "Comercio",
    #     "icon": "💰",
    #     "description": "Para comprar y vender objetos con otros jugadores.",
    #     "type": "CHAT",
    #     "default_on": True,
    #     "lock": "",
    # },
}
# === FIN: game_data/channel_prototypes.py ===


# === INICIO: game_data/item_prototypes.py ===
# game_data/item_prototypes.py
"""
Definición de Prototipos de Objetos (Items).

Este archivo es el catálogo central de todos los objetos que pueden existir
en el mundo de Runegram. Sigue un sistema de prototipos, lo que significa que
este archivo define las "plantillas" de los objetos.

Estructura de un Prototipo de Objeto:
- <clave_unica>:
    - "name": (str) El nombre que ven los jugadores.
    - "keywords": (list[str]) Palabras clave para interactuar con el objeto.
    - "description": (str) El texto que se muestra al mirar el objeto.
    - "scripts": (dict, opcional) Scripts reactivos a eventos.
    - "tickers": (list[dict], opcional) Scripts proactivos que se ejecutan periódicamente.
    - "grants_command_sets": (list[str], opcional) CommandSets que este objeto otorga.
    - "locks": (str, opcional) Restricciones para interactuar. En un objeto normal,
               se usa para el comando 'coger'. En un contenedor, se usa para 'abrir',
               'meter' o 'sacar'.

    - "is_container": (bool, opcional) Si es `True`, este objeto puede contener otros.
    - "capacity": (int, opcional) El número máximo de objetos que puede contener.
"""

ITEM_PROTOTYPES = {
    # Un objeto mágico que susurra secretos periódicamente.
    "espada_viviente": {
        "name": "una espada viviente",
        "description": "La hoja de acero parece retorcerse y susurrarte secretos.",
        "keywords": ["espada", "viviente"],
        "scripts": {
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        },
        "tickers": [
            {
                "schedule": "*/2 * * * *",
                "script": "script_espada_susurra_secreto",
                "category": "ambient"
            }
        ]
    },

    # --- NUEVOS EJEMPLOS DE CONTENEDORES ---

    # Un contenedor simple que se puede llevar en el inventario.
    "mochila_cuero": {
        "name": "una mochila de cuero",
        "keywords": ["mochila", "cuero"],
        "description": "Una mochila simple pero resistente, hecha de cuero curtido. Parece que tiene espacio para algunas cosas.",
        "is_container": True,
        "capacity": 10, # Puede contener hasta 10 objetos.
    },

    # Un contenedor fijo que no se puede coger y necesita una llave (futuro).
    "cofre_roble": {
        "name": "un cofre de roble",
        "keywords": ["cofre", "roble"],
        "description": "Un pesado cofre de madera de roble con refuerzos de hierro. Está cerrado.",
        "is_container": True,
        "capacity": 20,
        # Este lock evita que el objeto sea cogido con `/coger`.
        "locks": "rol(SUPERADMIN)",
        # Futuro: Podríamos tener un lock específico para abrir/cerrar.
        # "open_lock": "tiene_objeto(llave_cofre_roble)"
    },
}
# === FIN: game_data/item_prototypes.py ===


# === INICIO: game_data/room_prototypes.py ===
# game_data/room_prototypes.py
"""
Definición de Prototipos de Salas (Rooms).

Este archivo es el "mapa maestro" del mundo de Runegram. Define todas las
salas estáticas, sus descripciones, conexiones y detalles interactivos.

El `world_loader_service` lee este archivo al arrancar el bot para construir
o sincronizar el mundo en la base de datos.

Estructura de un Prototipo de Sala:
- <clave_unica>: (ej: "plaza_central")
    - "name": (str) El nombre de la sala.
    - "description": (str) El texto principal que se muestra al entrar.
    - "exits": (dict, opcional) Conexiones a otras salas.
        - "<direccion>": (str) La clave única de la sala de destino.
    - "grants_command_sets": (list[str], opcional) CommandSets que la sala otorga.
    - "details": (dict, opcional) Elementos descriptivos de la sala que se
                 pueden mirar, pero no son objetos físicos.
        - "<keyword>": (dict)
            - "keywords": (list[str]) Palabras clave para mirar el detalle.
            - "description": (str) El texto que se muestra al mirar el detalle.
"""

ROOM_PROTOTYPES = {
    # La sala de inicio.
    "limbo": {
        "name": "El Limbo",
        "description": "Te encuentras en una habitación vacía, suspendida en la nada. Es el comienzo de tu aventura y un refugio seguro.",
        "exits": {
            "norte": "plaza_central"
        }
    },

    # Un nexo central con un nuevo detalle interactivo.
    "plaza_central": {
        "name": "Plaza Central de Runegard",
        "description": "Estás en el corazón de la ciudad. El bullicio de mercaderes y aventureros llena el aire. Una imponente fuente de mármol domina el centro de la plaza. Varios caminos parten desde aquí.",
        "exits": {
            "este": "calle_mercaderes"
        },
        "details": {
            # Este diccionario permite que el comando `/mirar fuente` funcione en esta sala.
            "fuente_plaza": {
                "keywords": ["fuente", "marmol", "fuente de marmol"],
                "description": "Es una magnífica fuente esculpida en mármol blanco. El agua cristalina fluye desde la boca de tres leones de piedra. En el fondo, puedes ver el brillo de algunas monedas arrojadas por los transeúntes."
            }
        }
    },

    # Una sala temática.
    "calle_mercaderes": {
        "name": "Calle de los Mercaderes",
        "description": "Decenas de puestos se alinean en esta calle, ofreciendo todo tipo de mercancías exóticas.",
        "exits": {
            "oeste": "plaza_central"
        }
    },

    # --- Futuras salas podrían ir aquí ---
    # "forja_del_enano": {
    #     "name": "La Forja del Enano Errante",
    #     "description": "El calor del fuego y el rítmico martilleo sobre el yunque llenan esta sala.",
    #     "exits": {
    #         "sur": "plaza_central"
    #     },
    #     # Cualquier jugador en esta sala obtiene acceso a los comandos de herrería.
    #     "grants_command_sets": ["smithing"]
    # }
}
# === FIN: game_data/room_prototypes.py ===


# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
REM ##################################################################
REM #                                                                #
REM #           SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM              #
REM #                                                                #
REM #  Este script automatiza el proceso de limpiar por completo el  #
REM #  entorno de desarrollo de Docker y reconstruirlo desde cero.   #
REM #                                                                #
REM #  Es la herramienta principal para asegurar un estado limpio    #
REM #  después de cambios en dependencias, migraciones o si algo     #
REM #  se ha corrompido.                                             #
REM #                                                                #
REM ##################################################################

TITLE Reinicio Completo de Runegram

CLS
ECHO.
ECHO  ##################################################################
ECHO  #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO  ##################################################################
ECHO.
ECHO  ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES DE FORMA DESTRUCTIVA:
ECHO.
ECHO    1. Detendra todos los contenedores de la aplicacion.
ECHO    2. Eliminara los contenedores detenidos.
ECHO    3. [!] Eliminara el VOLUMEN de la base de datos, borrando TODOS los datos.
ECHO    4. Reconstruira la imagen Docker de la aplicacion desde cero.
ECHO    5. Levantara todos los servicios en segundo plano.
ECHO.
ECHO  Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.
ECHO  Presiona cualquier tecla para continuar o cierra esta ventana para cancelar.
PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen de datos... ---
ECHO.
REM `docker-compose down` detiene y elimina los contenedores.
REM La bandera `-v` (o `--volumes`) es crucial, ya que elimina los volúmenes
REM nombrados asociados, como `postgres_data`, asegurando un borrado total.
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo la imagen y levantando servicios... ---
ECHO.
REM `docker-compose up` levanta los servicios.
REM La bandera `--build` fuerza la reconstrucción de la imagen 'bot' desde el Dockerfile.
REM La bandera `-d` (o `--detach`) ejecuta los contenedores en segundo plano.
docker-compose up --build -d

ECHO.
ECHO  ##################################################################
ECHO  #                ¡PROCESO COMPLETADO CON EXITO!                  #
ECHO  #----------------------------------------------------------------#
ECHO  #  Los contenedores estan corriendo en segundo plano.            #
ECHO  #  Puedes ver los logs con: docker-compose logs -f bot            #
ECHO  ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/generate_snapshot.py ===
# scripts/generate_snapshot.py

import os
from pathlib import Path

# --- CONFIGURACIÓN ---

# Directorio raíz del proyecto (sube dos niveles desde este script)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# Nombre del archivo de salida
OUTPUT_FILENAME = "project_snapshot.txt"

# --- LISTA NEGRA: Directorios y archivos a IGNORAR SIEMPRE ---
# Usamos sets para una búsqueda más eficiente.
EXCLUDED_DIRS = {
    ".git",
    ".idea",
    ".vscode",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    "postgres_data",
    "node_modules",
}

EXCLUDED_FILES = {
    ".env",
    OUTPUT_FILENAME,
    "poetry.lock",
    "Pipfile.lock",
}

# Extensiones de archivo a ignorar (ej: binarios, compilados)
EXCLUDED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".egg-info",
    ".swp",
    ".db",
    ".sqlite3",
}

# --- FIN DE LA CONFIGURACIÓN ---


def write_file_content(output_file, file_path):
    """Escribe el contenido de un archivo en el archivo de salida, con un encabezado."""
    # Obtenemos la ruta relativa usando el estándar POSIX (barras /)
    relative_path = file_path.relative_to(PROJECT_ROOT).as_posix()
    print(f"  -> Añadiendo: {relative_path}")

    header = f"# === INICIO: {relative_path} ===\n"
    footer = f"# === FIN: {relative_path} ===\n\n\n"

    output_file.write(header)
    try:
        # Leemos el contenido del archivo
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            # Añadimos un salto de línea al final si no lo tiene, para un formato limpio
            if content and not content.endswith('\n'):
                content += '\n'
            output_file.write(content)
    except Exception as e:
        output_file.write(f"*** No se pudo leer el archivo: {e} ***\n")
    output_file.write(footer)


def main():
    """Función principal para generar el snapshot del proyecto."""
    output_path = PROJECT_ROOT / OUTPUT_FILENAME
    print(f"Generando snapshot del proyecto en: {output_path}\n")

    # Usaremos una lista para almacenar las rutas de los archivos a incluir
    files_to_process = []

    # os.walk recorre todos los directorios y archivos desde la raíz del proyecto
    for root, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        # Modificamos la lista de directorios 'in-place' para evitar que os.walk entre en ellos
        dirs[:] = [d for d in sorted(dirs) if d not in EXCLUDED_DIRS]

        # Procesamos los archivos del directorio actual
        for filename in sorted(files):
            # Comprobamos si el archivo o su extensión están en la lista negra
            if filename in EXCLUDED_FILES:
                continue

            file_path = Path(root) / filename
            if file_path.suffix in EXCLUDED_EXTENSIONS:
                continue

            # Si el archivo pasa todos los filtros, lo añadimos a la lista
            files_to_process.append(file_path)

    # Escribimos todos los archivos encontrados en el archivo de salida
    with open(output_path, 'w', encoding='utf-8') as output_file:
        for file_path in files_to_process:
            write_file_content(output_file, file_path)

    print(f"\n¡Snapshot generado con éxito! {len(files_to_process)} archivos procesados.")


if __name__ == "__main__":
    main()
# === FIN: scripts/generate_snapshot.py ===


# === INICIO: scripts/run_migrations.sh ===
# === FIN: scripts/run_migrations.sh ===


# === INICIO: src/__init__.py ===
# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===
# src/config.py
"""
Módulo de Configuración Centralizado.

Este archivo define la clase `Settings` que utiliza Pydantic para cargar, validar
y gestionar todas las variables de entorno necesarias para la aplicación.

Pydantic se encarga de:
1. Leer las variables desde un archivo `.env`.
2. Validar que las variables existan y tengan el tipo de dato correcto (ej: int, str).
3. Proveer un objeto `settings` único y fuertemente tipado que puede ser importado
   y utilizado en cualquier parte del proyecto.

Esto evita la dispersión de `os.getenv()` por el código y asegura que la aplicación
no arranque si falta una configuración crítica.
"""

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    """
    Define y carga todas las variables de entorno de la aplicación.
    """
    # Telegram
    bot_token: SecretStr

    # El ID de Telegram del usuario que tendrá el rol de Superadmin.
    # Este rol tiene todos los permisos y se asigna al arrancar la aplicación.
    superadmin_telegram_id: int

    # Database (PostgreSQL)
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Cache y Estados (Redis)
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        """
        Genera la URL de conexión a la base de datos para el motor ASÍNCRONO.
        Utiliza el driver 'asyncpg', que es el principal para la aplicación.
        """
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @property
    def sync_database_url(self) -> str:
        """
        Genera la URL de conexión a la base de datos para operaciones SÍNCRONAS.
        Utiliza el driver 'psycopg2'. Su uso principal es para componentes que no
        son compatibles con asyncio, como el `SQLAlchemyJobStore` de APScheduler.
        """
        return (
            f"postgresql+psycopg2://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        """
        Configuración interna de Pydantic para indicarle cómo cargar las variables.
        """
        # Nombre del archivo del que se leerán las variables de entorno.
        env_file = '.env'
        # Codificación del archivo .env.
        env_file_encoding = 'utf-8'

# Creamos una instancia única de la configuración que será importada
# por el resto de la aplicación.
settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
"""
Módulo de Configuración de la Base de Datos.

Este archivo es el responsable de crear y configurar la conexión a la base de
datos para toda la aplicación utilizando SQLAlchemy en modo asíncrono.

Componentes Clave:
1. `async_engine`: Una instancia única del motor de base de datos que gestiona
   las conexiones a bajo nivel. Se crea una sola vez cuando se inicia la app.
2. `async_session_factory`: Una "fábrica" que produce objetos de sesión de
   SQLAlchemy (`AsyncSession`). Cada vez que se necesita interactuar con la
   base de datos (ej: dentro de un manejador de comandos), se solicita una nueva
   sesión a esta fábrica.
"""

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Se crea una única instancia del motor asíncrono para toda la aplicación.
# Este objeto gestiona un pool de conexiones a la base de datos.
async_engine = create_async_engine(
    settings.database_url,

    # `echo=True` mostraría todas las sentencias SQL que se ejecutan en la consola.
    # Es muy útil para depurar, pero debe estar en `False` en producción.
    echo=False,
)

# Se crea una fábrica de sesiones. Esta fábrica se usará en toda la aplicación
# para obtener una nueva sesión de corta duración cada vez que se necesite
# realizar una operación en la base de datos.
async_session_factory = async_sessionmaker(
    bind=async_engine,

    # `expire_on_commit=False` es crucial en aplicaciones asíncronas.
    # Evita que SQLAlchemy invalide los objetos (ej: un 'Character') después de un
    # `session.commit()`. Sin esto, acceder a un atributo de un objeto después
    # de un commit podría lanzar un error al intentar recargarlo desde una
    # sesión ya cerrada.
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===
# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
# src/bot/bot.py
"""
Módulo para la Instanciación del Objeto Bot de Aiogram.

Este archivo tiene una única y simple responsabilidad: crear una instancia
global del objeto `Bot` de Aiogram.

Centralizar la creación de esta instancia aquí permite que cualquier otro
módulo en la aplicación (como los servicios) pueda importarla para interactuar
directamente con la API de Telegram (por ejemplo, para enviar mensajes
proactivos fuera del flujo normal de un comando).
"""

from aiogram import Bot

from src.config import settings

# Se crea una instancia única del Bot para toda la aplicación.
# El token se lee de forma segura desde el objeto de configuración `settings`,
# que a su vez lo carga desde las variables de entorno.
# `settings.bot_token.get_secret_value()` es la forma correcta de acceder
# al valor de un `SecretStr` de Pydantic.
bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py
"""
Módulo para la Instanciación del Dispatcher de Aiogram.

Este archivo crea y configura la instancia global del `Dispatcher`, que es el
componente central de Aiogram para el procesamiento de actualizaciones (mensajes,
callbacks, etc.).

Responsabilidades:
1.  **Enrutamiento:** El `Dispatcher` (`dp`) es el objeto al que se registran
    todos los manejadores de mensajes (handlers). Se encarga de decidir qué
    función debe procesar cada mensaje entrante.
2.  **Gestión de Estados (FSM):** Configura el almacenamiento de estados finitos
    (Finite State Machine), que permite crear conversaciones de varios pasos
    (ej: creación de personaje, menús interactivos).
"""

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# 1. Configuración del Almacenamiento de Estados (FSM - Finite State Machine)
# Se utiliza Redis (`RedisStorage2`) como backend para almacenar el estado de
# la conversación de cada usuario. Esto es esencial para funcionalidades
# de varios pasos, como la creación de personajes.
#
# `pool_size` se establece explícitamente para evitar el error 'Too many connections'
# que puede ocurrir si muchos usuarios interactúan con el bot simultáneamente.
storage = RedisStorage2(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    pool_size=20,
)

# 2. Creación de la Instancia del Dispatcher
# Se crea una instancia única del `Dispatcher` para toda la aplicación,
# vinculándola con la instancia del `bot` y el `storage` configurado.
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
"""
Módulo del Dispatcher Principal de Comandos.

Este archivo contiene el manejador (`handler`) más importante de la aplicación.
La función `main_command_dispatcher` está registrada para interceptar **todos**
los mensajes de texto enviados por los jugadores.

Actúa como el "cerebro" del juego, orquestando el siguiente flujo para cada mensaje:
1. Obtiene el contexto del jugador (Cuenta, Personaje) desde la base de datos.
2. Actualiza el estado de actividad del jugador (online/AFK).
3. Maneja casos especiales como el comando `/start`.
4. Utiliza el `command_service` para determinar dinámicamente qué `CommandSets`
   están activos para el jugador en ese preciso momento.
5. Busca el comando invocado dentro de los sets activos.
6. Verifica los permisos (`permission_service`).
7. Ejecuta el método `.execute()` del comando encontrado.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service, online_service, command_service

# Importaciones de CommandSets de Jugador
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.player.movement import MOVEMENT_COMMANDS
from commands.player.channels import CHANNEL_COMMANDS
from commands.player.dynamic_channels import DYNAMIC_CHANNEL_COMMANDS
from commands.player.settings import SETTINGS_COMMANDS

# Importaciones de CommandSets de Administrador
from commands.admin.building import SPAWN_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from commands.admin.info import INFO_COMMANDS
from commands.admin.diagnostics import DIAGNOSTICS_COMMANDS
from commands.admin.management import MANAGEMENT_COMMANDS

from src.utils.presenters import show_current_room

# El diccionario `COMMAND_SETS` es el catálogo maestro que contiene una instancia
# de cada comando disponible en el juego, agrupados por funcionalidad.
COMMAND_SETS = {
    # Comandos de Jugador
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "movement": MOVEMENT_COMMANDS,
    "channels": CHANNEL_COMMANDS,
    "dynamic_channels": DYNAMIC_CHANNEL_COMMANDS,
    "settings": SETTINGS_COMMANDS,
    # Comandos de Administrador
    "spawning": SPAWN_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
    "admin_info": INFO_COMMANDS,
    "diagnostics": DIAGNOSTICS_COMMANDS,
    "management": MANAGEMENT_COMMANDS,
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Manejador principal que intercepta todos los mensajes de texto y los
    enruta al comando correspondiente.
    """
    async with async_session_factory() as session:
        try:
            # 1. Obtener el contexto del jugador.
            account = await player_service.get_or_create_account(session, message.from_user.id)
            if not account:
                await message.answer("Error crítico al acceder a tu cuenta.")
                return
            character = account.character
            input_text = message.text.strip()

            # 2. Actualizar estado de actividad (online/AFK).
            if character:
                await online_service.update_last_seen(session, character)

            # 3. Manejo especial para el comando /start.
            if input_text.lower().startswith('/start'):
                if character is None:
                    await message.answer(
                        "¡Bienvenido a Runegram! Veo que eres nuevo por aquí.\n"
                        "Para empezar, necesitas crear tu personaje. Usa el comando:\n"
                        "/crearpersonaje [nombre]"
                    )
                else:
                    await command_service.update_telegram_commands(character)
                    await show_current_room(message)
                return

            # 4. Validar que el jugador tenga un personaje para la mayoría de los comandos.
            # Esta lógica se ha movido dentro del parseo para simplificar.

            # 5. Parsear el comando y sus argumentos.
            if not input_text.startswith('/'):
                await message.answer("Comando desconocido. Los comandos deben empezar con / (ej: /mirar, /norte).")
                return

            cmd_name = message.get_command(pure=True).lower()
            args = message.get_args().split() if message.get_args() else []

            # 6. Obtener la lista dinámica de CommandSets activos.
            active_sets_names = await command_service.get_active_command_sets_for_character(character)

            # 7. Buscar y ejecutar el comando.
            found_cmd = None
            for set_name in active_sets_names:
                for cmd_instance in COMMAND_SETS.get(set_name, []):
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
                if found_cmd:
                    break

            if not found_cmd:
                # Si el jugador no tiene personaje y el comando no es de creación, damos un mensaje específico.
                if not character and cmd_name != "crearpersonaje":
                     await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                else:
                    await message.answer("No conozco ese comando.")
                return

            can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
            if not can_run:
                await message.answer(error_message or "No puedes hacer eso.")
                return

            await found_cmd.execute(character, session, message, args)

        except Exception:
            # Captura final para cualquier error no manejado en las capas inferiores.
            await message.answer("Ocurrió un error inesperado al procesar tu comando.")
            logging.exception(f"Error crítico no manejado en el dispatcher principal para el usuario {message.from_user.id}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
from .character_setting import CharacterSetting
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
"""
Módulo que define el Modelo de Datos para una Cuenta de Usuario.

Este archivo contiene la clase `Account`, que se mapea a la tabla `accounts`
en la base de datos. Una cuenta representa a un usuario real a nivel de aplicación,
identificado de forma única por su `telegram_id`.

La cuenta es la entidad "propietaria" de un personaje (`Character`) y almacena
metadatos sobre el usuario, como su rol (JUGADOR, ADMIN, SUPERADMIN) y su estado
(ACTIVE, BLOCKED).
"""

from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    """
    Representa una cuenta de usuario en la base de datos.
    """
    __tablename__ = 'accounts'

    # Identificador único de la cuenta en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El ID de usuario único proporcionado por Telegram.
    # Es crucial para vincular nuestra cuenta interna con el usuario de Telegram.
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)

    # El rol del usuario en el juego. Determina el acceso a comandos especiales.
    # Jerarquía de roles (de mayor a menor): SUPERADMIN > ADMIN > JUGADOR.
    role = Column(String, default='JUGADOR', nullable=False, server_default='JUGADOR')

    # El estado de la cuenta (ej: 'ACTIVE', 'BLOCKED').
    # Permite gestionar el acceso de los usuarios a nivel de cuenta.
    status = Column(String(20), default='ACTIVE', nullable=False, server_default='ACTIVE')

    # --- Relaciones de SQLAlchemy ---

    # Relación uno-a-uno con el personaje del juego.
    # `uselist=False` indica que una cuenta solo puede tener un personaje.
    # `back_populates` asegura que la relación sea bidireccional.
    character = relationship("Character", back_populates="account", uselist=False)

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Account(id={self.id}, telegram_id={self.telegram_id}, role='{self.role}')>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
"""
Módulo que define la Base Declarativa para todos los Modelos de SQLAlchemy.

Este archivo contiene un único pero crucial objeto: `Base`.

SQLAlchemy utiliza un sistema "declarativo" donde las clases de Python se mapean
directamente a tablas de la base de datos. Para que esto funcione, todas las
clases de modelo (como `Account`, `Character`, `Room`, etc.) deben heredar de
una clase base común.

Esta clase `Base` actúa como un registro central que recopila metadatos sobre
todas las clases de modelo que heredan de ella. Herramientas como Alembic
utilizan estos metadatos para comparar los modelos con el estado de la base
de datos y generar así las migraciones automáticamente.
"""

from sqlalchemy.orm import declarative_base

# `declarative_base()` es una función de fábrica que construye la clase base.
# Todos nuestros modelos de datos en el proyecto heredarán de este objeto `Base`.
Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
"""
Módulo que define el Modelo de Datos para un Personaje del Juego.

Este archivo contiene la clase `Character`, que se mapea a la tabla `characters`
en la base de datos. Un personaje es el "avatar" o la entidad con la que un
jugador interactúa dentro del mundo de Runegram.

El personaje está vinculado a una `Account` (el usuario real) y actúa como el
punto central para las relaciones de juego, como su ubicación (`Room`), su
inventario (`Item`), y sus configuraciones (`CharacterSetting`).
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class Character(Base):
    """
    Representa un personaje jugable en la base de datos.
    """
    __tablename__ = 'characters'

    # --- Atributos Principales ---
    id = Column(BigInteger, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)

    # --- Claves Foráneas ---
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Atributos de Juego (Datos Estructurados) ---
    command_sets = Column(
        JSONB,
        nullable=False,
        server_default='["general", "interaction", "movement", "channels", "dynamic_channels", "settings"]',
        default=["general", "interaction", "movement", "channels", "dynamic_channels", "settings"]
    )

    # --- Relaciones de SQLAlchemy ---
    account = relationship("Account", back_populates="character")
    room = relationship("Room", back_populates="characters")
    items = relationship("Item", back_populates="character")
    settings = relationship(
        "CharacterSetting",
        back_populates="character",
        uselist=False,
        cascade="all, delete-orphan"
    )

    def get_description(self) -> str:
        """
        Genera la descripción que otros ven al mirar a este personaje.

        Futuro: Esta función podría ser mucho más compleja, mostrando el equipo
        del personaje, su estado (luchando, durmiendo), etc. Los jugadores
        también podrían establecer su propia descripción personalizada.
        """
        # Por ahora, una descripción genérica.
        return f"Ves a {self.name}, un aventurero como tú. No parece tener nada de especial por el momento."

    def __repr__(self):
        return f"<Character(id={self.id}, name='{self.name}')>"
# === FIN: src/models/character.py ===


# === INICIO: src/models/character_setting.py ===
# src/models/character_setting.py
"""
Módulo que define el Modelo de Datos para las Configuraciones de un Personaje.

Este archivo contiene la clase `CharacterSetting`, que se mapea a la tabla
`character_settings`. Esta tabla almacena configuraciones personalizables
para cada personaje, manteniendo el modelo `Character` principal más limpio.

El uso de una columna `JSONB` (`active_channels`) permite añadir futuras
configuraciones (ej: colores, flags de tutorial) sin necesidad de modificar
el esquema de la base de datos, lo que hace que el sistema sea muy flexible
y extensible.
"""

from sqlalchemy import BigInteger, Column, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class CharacterSetting(Base):
    """
    Representa una fila de configuraciones para un personaje específico.
    """
    __tablename__ = 'character_settings'

    # --- Clave Primaria y Foránea ---

    # Usamos el ID del personaje como clave primaria (`primary_key=True`).
    # Esto impone una relación estricta de uno-a-uno a nivel de base de datos:
    # no puede haber más de una fila de configuraciones por personaje.
    character_id = Column(BigInteger, ForeignKey('characters.id'), primary_key=True)

    # --- Atributos de Configuración ---

    # Columna JSONB para guardar una lista de los canales a los que el personaje
    # está suscrito. Usar JSONB es muy flexible.
    # Ejemplo de contenido: `{"active_channels": ["novato", "comercio"]}`
    active_channels = Column(JSONB, nullable=False, server_default='{}')

    # --- Relaciones de SQLAlchemy ---

    # Relación inversa uno-a-uno con el personaje.
    # Permite acceder al objeto `Character` desde la configuración vía `settings.character`.
    character = relationship("Character", back_populates="settings")

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<CharacterSetting(character_id={self.character_id})>"
# === FIN: src/models/character_setting.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py
"""
Módulo que define el Modelo de Datos para una Salida entre Salas.

Este archivo contiene la clase `Exit`, que se mapea a la tabla `exits`.
Cada fila en esta tabla representa una conexión UNIDIRECCIONAL desde una sala
de origen (`from_room_id`) hacia una sala de destino (`to_room_id`).

Una conexión bidireccional (ej: una puerta entre la sala A y la sala B) se
representa como dos filas separadas en esta tabla:
1. Una salida desde A hacia B (ej: "norte").
2. Una salida desde B hacia A (ej: "sur").
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    # --- Atributos Principales ---

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta").
    name = Column(String(50), nullable=False, index=True)

    # El string de permisos para esta salida específica.
    locks = Column(String, nullable=False, default="")

    # --- Claves Foráneas ---

    # El ID de la sala desde la que parte esta salida.
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El ID de la sala a la que lleva esta salida.
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Relaciones de SQLAlchemy ---

    # Relación para poder acceder al objeto `Room` de origen.
    # `foreign_keys=[from_room_id]` es necesario para que SQLAlchemy sepa cuál de
    # las dos claves foráneas a 'rooms.id' debe usar para esta relación.
    # `back_populates="exits_from"` la conecta con la lista de salidas en el modelo Room.
    from_room = relationship("Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relación para poder acceder al objeto `Room` de destino.
    # `back_populates="exits_to"` la conecta con la lista de "llegadas" en el modelo Room.
    to_room = relationship("Room", foreign_keys=[to_room_id], back_populates="exits_to")

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Exit(id={self.id}, name='{self.name}', from={self.from_room_id}, to={self.to_room_id})>"
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py
"""
Módulo que define el Modelo de Datos para una Instancia de Objeto (Item).

Este archivo contiene la clase `Item`, que se mapea a la tabla `items`.
Representa una INSTANCIA única de un objeto en el mundo.

Este modelo es deliberadamente "ligero". La mayoría de sus propiedades se
obtienen en tiempo de ejecución a través de la columna `key`, que lo vincula
a su prototipo en `game_data/item_prototypes.py`.

Un `Item` también puede actuar como un contenedor para otros `Items` a través
de una relación de auto-referencia.
"""

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship

from game_data.item_prototypes import ITEM_PROTOTYPES
from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo del juego.
    """
    __tablename__ = 'items'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)
    key = Column(String(50), nullable=False, index=True)
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)

    # --- Ubicación del Objeto ---
    # Un objeto solo puede estar en una ubicación a la vez. Por lo tanto,
    # solo una de las siguientes tres columnas (`room_id`, `character_id`,
    # `parent_item_id`) debe tener un valor.

    # 1. En el suelo de una sala.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)

    # 2. En el inventario de un personaje.
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    # 3. Dentro de otro objeto (contenedor).
    # Esta es una clave foránea que apunta a la misma tabla `items`.
    parent_item_id = Column(BigInteger, ForeignKey('items.id'), nullable=True)

    # --- Relaciones de SQLAlchemy ---

    # Relación con la sala donde se encuentra el objeto.
    room = relationship("Room", back_populates="items")

    # Relación con el personaje que lleva el objeto.
    character = relationship("Character", back_populates="items")

    # --- Relaciones de Contenedor (Auto-Referencia) ---

    # Relación para acceder al inventario de este objeto (si es un contenedor).
    # Es una lista de `Item` que tienen a este objeto como su `parent_item_id`.
    contained_items = relationship("Item", back_populates="parent_container", cascade="all, delete-orphan")

    # Relación para acceder al contenedor de este objeto (si está dentro de uno).
    # `remote_side=[id]` es necesario para que SQLAlchemy entienda la dirección
    # de esta relación de auto-referencia.
    parent_container = relationship("Item", back_populates="contained_items", remote_side=[id])


    @property
    def prototype(self) -> dict:
        """
        Devuelve el diccionario del prototipo para este objeto desde `game_data`.
        """
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """
        Obtiene el nombre del item, priorizando el `override` sobre el prototipo.
        """
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """
        Obtiene la descripción del item, priorizando el `override` sobre el prototipo.
        """
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """
        Obtiene las palabras clave del item, que siempre provienen del prototipo.
        """
        return self.prototype.get("keywords", [])

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Item(id={self.id}, key='{self.key}')>"
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py
"""
Módulo que define el Modelo de Datos para una Sala del Mundo.

Este archivo contiene la clase `Room`, que se mapea a la tabla `rooms`.
Cada fila en esta tabla representa una ubicación única en el juego.

Siguiendo la filosofía de diseño del motor, una `Room` en la base de datos
es principalmente una instancia que se corresponde con un prototipo definido en
`game_data/room_prototypes.py`, vinculado a través de la columna `key`.
"""

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base
from game_data.room_prototypes import ROOM_PROTOTYPES

class Room(Base):
    """
    Representa una sala o ubicación en el mundo del juego.
    """
    __tablename__ = 'rooms'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)
    key = Column(String(50), unique=True, nullable=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")
    locks = Column(String, nullable=False, default="")

    # --- Relaciones de SQLAlchemy ---

    # Relación uno-a-muchos con los objetos que se encuentran en esta sala.
    items = relationship("Item", back_populates="room")

    # Relación uno-a-muchos con los personajes que se encuentran en esta sala.
    # Permite acceder a una lista de `Character` vía `room.characters`.
    # No necesita `back_populates` porque la relación en `Character` (`character.room`)
    # ya está definida y es suficiente.
    characters = relationship("Character")

    # Relación uno-a-muchos con las salidas QUE PARTEN DESDE ESTA SALA.
    exits_from = relationship(
        "Exit",
        foreign_keys="[Exit.from_room_id]",
        back_populates="from_room",
        cascade="all, delete-orphan"
    )

    # Relación uno-a-muchos con las salidas QUE LLEGAN A ESTA SALA.
    exits_to = relationship(
        "Exit",
        foreign_keys="[Exit.to_room_id]",
        back_populates="to_room",
        cascade="all, delete-orphan"
    )

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para esta sala desde `game_data`.
        """
        if not self.key:
            return {}
        return ROOM_PROTOTYPES.get(self.key, {})

    def __repr__(self):
        """
        Representación en string del objeto, útil para logging y depuración.
        """
        return f"<Room(id={self.id}, key='{self.key}', name='{self.name}')>"
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===
# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster_service.py ===
# src/services/broadcaster_service.py
"""
Módulo de Servicio de Transmisión (Broadcasting).

Este archivo centraliza toda la lógica para enviar mensajes a los jugadores
a través del bot de Telegram. Actúa como una capa de abstracción sobre la API
directa del bot.

Centralizar la comunicación aquí ofrece varias ventajas:
1.  **Consistencia:** Todos los mensajes enviados por el juego pueden tener un
    formato y comportamiento consistentes.
2.  **Manejo de Errores Unificado:** La lógica para manejar errores de la API de
    Telegram (ej: un usuario bloquea el bot) se encuentra en un solo lugar.
3.  **Desacoplamiento:** El resto de los servicios (scripts, canales, etc.) no
    necesitan saber los detalles de cómo se envía un mensaje; simplemente
    llaman a una función en este servicio.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.bot.bot import bot
from src.models import Character


async def send_message_to_character(
    character: Character,
    message_text: str,
    parse_mode: str = "HTML"
):
    """
    Envía un mensaje formateado a un personaje específico.

    Args:
        character (Character): La instancia del modelo Character a la que se enviará el mensaje.
                               Es crucial que este objeto tenga su relación `.account` precargada.
        message_text (str): El contenido del mensaje a enviar.
        parse_mode (str): El modo de parseo de Telegram (por defecto 'HTML').
    """
    if not character:
        logging.warning("BROADCASTER: Se intentó enviar un mensaje a un personaje nulo.")
        return

    # Salvaguarda para asegurar que la relación con la cuenta está cargada.
    if not character.account:
        logging.error(f"BROADCASTER: El personaje {character.name} (ID: {character.id}) no tiene su cuenta cargada. No se puede enviar mensaje.")
        return

    try:
        logging.info(f"[BROADCASTER DEBUG] Intentando enviar mensaje a {character.name} (Chat ID: {character.account.telegram_id})")
        await bot.send_message(
            chat_id=character.account.telegram_id,
            text=message_text,
            parse_mode=parse_mode
        )
        logging.info(f"[BROADCASTER DEBUG] Mensaje enviado con éxito a {character.name}")
    except Exception:
        # Usamos logging.exception para obtener un traceback completo si el envío falla.
        # Esto es común si un usuario ha bloqueado el bot. No debe detener el juego.
        logging.exception(f"BROADCASTER: No se pudo enviar mensaje a {character.name} (ID: {character.id})")


async def send_message_to_room(
    session: AsyncSession,
    room_id: int,
    message_text: str,
    exclude_character_id: int | None = None,
    parse_mode: str = "HTML"
):
    """
    Envía un mensaje a todos los personajes presentes en una sala específica.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        room_id (int): El ID de la sala a la que se enviará el mensaje.
        message_text (str): El contenido del mensaje a enviar.
        exclude_character_id (int, optional): El ID de un personaje a excluir de la transmisión.
        parse_mode (str): El modo de parseo de Telegram.
    """
    if not room_id:
        logging.warning("BROADCASTER: Se intentó enviar un mensaje a un room_id nulo.")
        return

    # 1. Obtenemos todos los personajes en la sala.
    #    Usamos `selectinload(Character.account)` para cargar eficientemente la
    #    información de la cuenta de todos los personajes en una sola consulta.
    query = (
        select(Character)
        .where(Character.room_id == room_id)
        .options(selectinload(Character.account))
    )
    result = await session.execute(query)
    characters_in_room = result.scalars().all()

    # 2. Iteramos y enviamos el mensaje a cada personaje.
    for char in characters_in_room:
        if char.id == exclude_character_id:
            continue

        # Reutilizamos nuestra propia función para mantener la lógica de envío en un solo lugar.
        await send_message_to_character(
            character=char,
            message_text=message_text,
            parse_mode=parse_mode
        )
# === FIN: src/services/broadcaster_service.py ===


# === INICIO: src/services/channel_service.py ===
# src/services/channel_service.py
"""
Módulo de Servicio para la Gestión de Canales de Chat.

Este servicio encapsula toda la lógica de negocio relacionada con los canales
de comunicación globales. Sus responsabilidades incluyen:
- Gestionar la configuración de canales por personaje (suscripciones).
- Formatear y transmitir mensajes a todos los jugadores suscritos a un canal.
- Proveer funciones de ayuda para comprobar el estado de los canales.

Depende de `broadcaster_service` para el envío final de mensajes y de
`game_data/channel_prototypes.py` como fuente de la verdad sobre los
canales disponibles.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Character, CharacterSetting
from src.services import broadcaster_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

async def get_or_create_settings(session: AsyncSession, character: Character) -> CharacterSetting:
    """
    Obtiene las configuraciones para un personaje. Si no existen, las crea con
    los valores por defecto definidos en los prototipos de canal.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        character (Character): El personaje para el que se obtienen las configuraciones.

    Returns:
        CharacterSetting: El objeto de configuración del personaje.
    """
    # Si las settings ya están cargadas en el objeto character, las devolvemos directamente.
    if character.settings:
        return character.settings

    # Si no, las creamos.
    logging.info(f"Creando configuraciones por defecto para el personaje {character.name}")

    # Leemos los prototipos para ver qué canales deben estar activados por defecto.
    default_channels = [
        key for key, data in CHANNEL_PROTOTYPES.items() if data.get("default_on", False)
    ]

    new_settings = CharacterSetting(
        character_id=character.id,
        active_channels={"active_channels": default_channels}
    )
    session.add(new_settings)
    await session.commit()

    # Refrescamos el objeto 'character' para que la relación 'settings' se cargue.
    await session.refresh(character, attribute_names=["settings"])

    return character.settings

async def is_channel_active(settings: CharacterSetting, channel_key: str) -> bool:
    """Comprueba si un canal está en la lista de canales activos de un jugador."""
    if not settings:
        return False
    return channel_key in settings.active_channels.get("active_channels", [])

async def broadcast_to_channel(session: AsyncSession, channel_key: str, message: str, exclude_character_id: int | None = None):
    """
    Envía un mensaje a todos los jugadores que estén suscritos a un canal.
    """
    try:
        if channel_key not in CHANNEL_PROTOTYPES:
            logging.warning(f"Intento de transmitir a un canal desconocido: {channel_key}")
            return

        # 1. Formatear el mensaje con el ícono y nombre del canal.
        proto = CHANNEL_PROTOTYPES[channel_key]
        formatted_message = f"{proto['icon']} <b>{proto['name']}:</b> {message}"

        # 2. Obtener todos los personajes del juego.
        #    Precargamos sus settings y cuentas para evitar consultas adicionales en el bucle.
        query = select(Character).options(selectinload(Character.settings), selectinload(Character.account))
        result = await session.execute(query)
        all_characters = result.scalars().all()

        # 3. Iterar y enviar el mensaje a los que estén suscritos.
        for char in all_characters:
            if char.id == exclude_character_id:
                continue

            settings = await get_or_create_settings(session, char)
            if await is_channel_active(settings, channel_key):
                await broadcaster_service.send_message_to_character(char, formatted_message)
    except Exception:
        logging.exception(f"Error al transmitir al canal '{channel_key}'")

async def set_channel_status(session: AsyncSession, character: Character, channel_key: str, activate: bool):
    """Activa o desactiva un canal para un personaje."""
    if channel_key not in CHANNEL_PROTOTYPES:
        raise ValueError("El canal especificado no existe.")

    settings = await get_or_create_settings(session, character)

    # SQLAlchemy es capaz de detectar cambios en listas dentro de un JSONB "mutable".
    # Obtenemos la lista actual de canales activos.
    active_channels_list = settings.active_channels.get("active_channels", [])

    if activate:
        # Añadir el canal si no está ya en la lista.
        if channel_key not in active_channels_list:
            active_channels_list.append(channel_key)
    else: # Desactivar
        # Quitar el canal si está en la lista.
        if channel_key in active_channels_list:
            active_channels_list.remove(channel_key)

    # Reasignamos la lista modificada al campo JSONB.
    settings.active_channels["active_channels"] = active_channels_list

    # Marcamos el objeto como "modificado" para que SQLAlchemy sepa que debe guardarlo.
    from sqlalchemy.orm.attributes import flag_modified
    flag_modified(settings, "active_channels")

    await session.commit()
# === FIN: src/services/channel_service.py ===


# === INICIO: src/services/command_service.py ===
"""
Módulo de Servicio para la Gestión de Comandos.

Este servicio es el cerebro detrás del sistema de comandos dinámicos.
No define los comandos en sí, sino que orquesta cuáles están disponibles
para un jugador en un momento dado y cómo se presentan en la interfaz.

Responsabilidades Clave:
1. Calcular la lista de `CommandSets` activos para un personaje basándose
   en su estado, equipo y ubicación (contexto).
2. Sincronizar la lista de comandos disponibles con la interfaz del cliente
   de Telegram, proporcionando una experiencia de usuario (UX) reactiva.
"""

import logging
from aiogram.types import BotCommand, BotCommandScopeChat
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.bot import bot
from src.models import Character

def get_command_sets() -> dict:
    """
    Obtiene el diccionario `COMMAND_SETS` del dispatcher de forma segura para
    evitar importaciones circulares.
    """
    from src.handlers.player.dispatcher import COMMAND_SETS
    return COMMAND_SETS

async def get_active_command_sets_for_character(character: Character) -> list[str]:
    """
    Construye la lista de nombres de CommandSets activos para un personaje
    basándose en su contexto actual (base, equipo, sala, rol).
    """
    if not character:
        return ["character_creation"]

    # 1. Empezamos con los sets base del personaje desde la BD.
    active_sets = set(character.command_sets)

    # 2. Añadimos sets otorgados por los objetos en el inventario.
    for item in character.items:
        granted_sets = item.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 3. Añadimos sets otorgados por la sala actual.
    if character.room and character.room.prototype:
        granted_sets = character.room.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 4. Añadimos sets de administrador si el rol de la cuenta es el adecuado.
    if character.account and character.account.role in ["ADMIN", "SUPERADMIN"]:
        active_sets.update(["spawning", "admin_movement", "admin_info", "diagnostics", "management"])

    return sorted(list(active_sets))


async def update_telegram_commands(character: Character):
    """
    Actualiza la lista de comandos visibles en el menú '/' del cliente de Telegram
    para un personaje específico.
    """
    if not character or not character.account:
        return

    try:
        COMMAND_SETS = get_command_sets()
        active_set_names = await get_active_command_sets_for_character(character)

        telegram_commands = []
        seen_commands = set()

        # Construimos la lista de objetos BotCommand que la API de Telegram espera.
        for set_name in active_set_names:
            for command_instance in COMMAND_SETS.get(set_name, []):
                main_name = command_instance.names[0]
                if main_name not in seen_commands:
                    telegram_commands.append(
                        BotCommand(command=main_name, description=command_instance.description)
                    )
                    seen_commands.add(main_name)

        # Usamos un `BotCommandScopeChat` para aplicar estos comandos únicamente
        # al chat con este jugador específico.
        scope = BotCommandScopeChat(chat_id=character.account.telegram_id)
        await bot.set_my_commands(commands=telegram_commands, scope=scope)

        logging.info(f"Actualizados {len(telegram_commands)} comandos de Telegram para {character.name}.")

    except Exception as e:
        # Los errores al actualizar comandos no son críticos y no deben detener el juego.
        logging.warning(f"No se pudieron actualizar los comandos de Telegram para {character.name}: {e}")
# === FIN: src/services/command_service.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py
"""
Módulo de Servicio para la Gestión de Objetos (Items).

Este servicio encapsula la lógica de negocio para crear y manipular instancias
de objetos en el mundo del juego. Se encarga de la interacción directa con el
modelo `Item`.

Responsabilidades:
- Crear nuevas instancias de objetos a partir de prototipos (`spawn`).
- Mover objetos entre salas, inventarios de personajes y contenedores.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
from game_data.item_prototypes import ITEM_PROTOTYPES
from src.services import ticker_service


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto, la coloca en una sala
    y registra sus tickers.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    try:
        new_item = Item(room_id=room_id, key=item_key)
        session.add(new_item)
        await session.commit()
        await session.refresh(new_item)
        await ticker_service.schedule_tickers_for_entity(new_item)
        return new_item
    except Exception:
        logging.exception(f"Error inesperado al generar el objeto con clave '{item_key}'")
        raise


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """
    Mueve un objeto al inventario de un personaje, quitándolo de cualquier
    otra ubicación (sala o contenedor).
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=None, character_id=character_id, parent_item_id=None)
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """
    Mueve un objeto al suelo de una sala, quitándolo de cualquier
    otra ubicación (inventario o contenedor).
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=room_id, character_id=None, parent_item_id=None)
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_container(session: AsyncSession, item_id: int, container_id: int):
    """
    Mueve un objeto al interior de otro objeto (contenedor), quitándolo de
    cualquier otra ubicación (sala o inventario).
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=None, character_id=None, parent_item_id=container_id)
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/online_service.py ===
# src/services/online_service.py
"""
Módulo de Servicio para el Seguimiento de Actividad (Presencia).

Este servicio gestiona el estado de "online" o "AFK" (Away From Keyboard) de los
personajes. Utiliza Redis para un almacenamiento y recuperación de datos de alta
velocidad, lo cual es ideal para datos volátiles como el timestamp de la última
actividad.

Responsabilidades:
- Registrar la última vez que un jugador envía un comando.
- Determinar si un jugador está "online" basándose en un umbral de inactividad.
- Gestionar las notificaciones cuando un jugador pasa a estado AFK o vuelve.
- Proveer una tarea global (`check_for_newly_afk_players`) para ser ejecutada
  periódicamente por el `ticker_service`.
"""

import time
import logging
import redis.asyncio as redis
from datetime import timedelta

from src.config import settings
from src.models import Character
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from src.db import async_session_factory


# --- Configuración del Servicio ---

# Si un jugador no ha enviado un comando en este tiempo, se considera "offline".
ONLINE_THRESHOLD = timedelta(minutes=5)

# Cliente de Redis dedicado para este servicio.
redis_client = redis.Redis(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    decode_responses=True
)

# Variable global en memoria para rastrear quién estaba online en el último chequeo.
PREVIOUSLY_ONLINE_IDS = set()


# --- Funciones de Ayuda (Internas) ---

def _get_last_seen_key(character_id: int) -> str:
    """Genera la clave de Redis estandarizada para el timestamp de un personaje."""
    return f"last_seen:{character_id}"

def _get_afk_notified_key(character_id: int) -> str:
    """Genera la clave de Redis para el flag que indica si ya se notificó el estado AFK."""
    return f"afk_notified:{character_id}"


# --- Funciones Principales del Servicio ---

async def update_last_seen(session: AsyncSession, character: Character):
    """
    Actualiza la última actividad de un personaje y le notifica si vuelve de estar AFK.
    Esta función es llamada por el dispatcher en cada mensaje.
    """
    # Importamos aquí para evitar importaciones circulares.
    from src.services import broadcaster_service

    char_id = character.id

    # 1. Actualizar el timestamp de "última vez visto" en Redis.
    key = _get_last_seen_key(char_id)
    await redis_client.set(key, time.time())
    await redis_client.expire(key, timedelta(days=7))

    # 2. Comprobar si el personaje estaba marcado como AFK.
    afk_notified_key = _get_afk_notified_key(char_id)
    # `getdel` obtiene y borra la clave atómicamente si existe.
    was_afk = await redis_client.getdel(afk_notified_key)

    if was_afk:
        # El personaje estaba AFK y acaba de volver. Se le notifica directamente.
        logging.info(f"Personaje {character.name} ha vuelto de su inactividad (AFK).")
        await broadcaster_service.send_message_to_character(
            character,
            "<i>Has vuelto de tu inactividad.</i>"
        )


async def is_character_online(character_id: int) -> bool:
    """
    Verifica si un personaje se considera "online" (activo recientemente).
    """
    key = _get_last_seen_key(character_id)
    last_seen_timestamp_str = await redis_client.get(key)
    if not last_seen_timestamp_str:
        return False

    try:
        elapsed_time = time.time() - float(last_seen_timestamp_str)
        return elapsed_time < ONLINE_THRESHOLD.total_seconds()
    except (ValueError, TypeError):
        return False

async def get_online_characters(session: AsyncSession) -> list[Character]:
    """
    Devuelve una lista de todos los objetos Character que se consideran "online".
    """
    result = await session.execute(select(Character))
    all_characters = result.scalars().all()

    online_characters = []
    for char in all_characters:
        if await is_character_online(char.id):
            online_characters.append(char)

    return online_characters

async def check_for_newly_afk_players():
    """
    Tarea global periódica para detectar y notificar sobre personajes que se
    han vuelto inactivos (AFK).
    """
    # Importamos aquí para evitar importaciones circulares.
    from src.services import broadcaster_service, player_service
    global PREVIOUSLY_ONLINE_IDS
    logging.info("[AFK CHECK] Ejecutando chequeo de jugadores inactivos...")

    async with async_session_factory() as session:
        try:
            result = await session.execute(select(Character.id))
            all_char_ids = set(result.scalars().all())

            currently_online_ids = set()
            for char_id in all_char_ids:
                if await is_character_online(char_id):
                    currently_online_ids.add(char_id)

            # Compara la lista de jugadores online de ahora con la de la última vez.
            newly_afk_ids = PREVIOUSLY_ONLINE_IDS - currently_online_ids

            for char_id in newly_afk_ids:
                afk_notified_key = _get_afk_notified_key(char_id)
                # Solo notificamos si no se ha notificado ya.
                if not await redis_client.exists(afk_notified_key):
                    character = await player_service.get_character_with_relations_by_id(session, char_id)
                    if character:
                        logging.info(f"Personaje {character.name} ha entrado en inactividad (AFK).")
                        await broadcaster_service.send_message_to_character(
                            character,
                            "<i>Has entrado en modo de inactividad (AFK).</i>"
                        )
                        # Marcamos que ya fue notificado para no spamear.
                        await redis_client.set(afk_notified_key, "1", ex=timedelta(days=1))
        except Exception:
            logging.exception("[AFK CHECK] Ocurrió un error durante el chequeo de AFK.")

    # Actualizamos el estado global para la próxima comprobación.
    PREVIOUSLY_ONLINE_IDS = currently_online_ids
    logging.info(f"[AFK CHECK] Chequeo finalizado. {len(PREVIOUSLY_ONLINE_IDS)} jugadores online.")
# === FIN: src/services/online_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
"""
Módulo de Servicio para la Gestión de Permisos y Locks.

Este servicio es el "guardián" de acceso a acciones en el juego. Interpreta
"lock strings" (cadenas de permisos) para determinar si un personaje tiene
permiso, utilizando el módulo `ast` de Python para un parseo seguro y potente.

El sistema es extensible y soporta lógica booleana compleja:
1. Un `lock_string` es una expresión similar a Python (ej: "rol(ADMIN) or (tiene_objeto(llave) and not rol(SUPERADMIN))").
2. `ast.parse` convierte el string en un árbol de sintaxis abstracta (AST) de forma segura.
3. La clase `LockEvaluator` (un `ast.NodeVisitor`) recorre el árbol y evalúa el resultado.
4. Las funciones de lock (ej: `rol()`) están registradas en `LOCK_FUNCTIONS`.
"""

import logging
import ast # Módulo para parsear la sintaxis de Python de forma segura
from src.models import Character

# --- Jerarquía de Roles ---
ROLE_HIERARCHY = {
    "JUGADOR": 1,
    "ADMIN": 2,
    "SUPERADMIN": 3,
}

# ==============================================================================
# SECCIÓN DE FUNCIONES DE LOCK
#
# Estas funciones no cambian. Siguen siendo los bloques de construcción
# de nuestra lógica de permisos.
# ==============================================================================

def _lock_rol(character: Character, args: list[str]) -> bool:
    """Chequea si el rol del personaje es igual o superior al requerido."""
    if not character or not character.account or not args:
        return False

    required_role = args[0].upper()
    user_role = character.account.role.upper()

    required_level = ROLE_HIERARCHY.get(required_role, 99)
    user_level = ROLE_HIERARCHY.get(user_role, 0)

    return user_level >= required_level

def _lock_tiene_objeto(character: Character, args: list[str]) -> bool:
    """Chequea si el personaje lleva en su inventario un objeto con la clave dada."""
    if not character or not args:
        return False

    item_key = args[0]
    return any(item.key == item_key for item in character.items)

# ==============================================================================
# REGISTRO DE FUNCIONES DE LOCK
# ==============================================================================

LOCK_FUNCTIONS = {
    "rol": _lock_rol,
    "tiene_objeto": _lock_tiene_objeto,
}

# ==============================================================================
# MOTOR DEL SERVICIO DE PERMISOS (BASADO EN AST)
# ==============================================================================

class LockEvaluator(ast.NodeVisitor):
    """
    Un visitante de nodos AST que evalúa un lock string de forma segura.
    Recorre el árbol de sintaxis y calcula el resultado booleano final.
    """
    def __init__(self, character: Character):
        self.character = character

    def visit_BoolOp(self, node: ast.BoolOp) -> bool:
        """Maneja operadores `and` y `or`."""
        # Obtenemos los resultados de cada sub-expresión.
        sub_results = [self.visit(value) for value in node.values]
        if isinstance(node.op, ast.And):
            return all(sub_results)
        elif isinstance(node.op, ast.Or):
            return any(sub_results)
        return False

    def visit_UnaryOp(self, node: ast.UnaryOp) -> bool:
        """Maneja el operador `not`."""
        if isinstance(node.op, ast.Not):
            return not self.visit(node.operand)
        return False

    def visit_Call(self, node: ast.Call) -> bool:
        """Maneja las llamadas a funciones de lock (ej: `rol(...)`)."""
        func_name = node.func.id.lower()
        if func_name in LOCK_FUNCTIONS:
            # Evaluamos los argumentos (que también son nodos AST).
            args = [self.visit(arg) for arg in node.args]
            lock_func = LOCK_FUNCTIONS[func_name]
            return lock_func(self.character, args)

        logging.warning(f"Función de lock desconocida llamada: {func_name}")
        return False # Falla de forma segura si la función no está registrada.

    def visit_Constant(self, node: ast.Constant) -> any:
        """Maneja valores constantes como strings o números."""
        return node.value

    def visit_Name(self, node: ast.Name) -> str:
        """
        Maneja nombres/identificadores. Los tratamos como strings.
        Esto permite escribir `rol(ADMIN)` en lugar de `rol('ADMIN')`.
        """
        return node.id

    def generic_visit(self, node):
        """
        Método de captura para cualquier tipo de nodo no soportado.
        Esto es una medida de seguridad crucial para prevenir la ejecución
        de código no deseado (bucles, asignaciones, etc.).
        """
        raise TypeError(f"Construcción no soportada en lock string: {type(node).__name__}")

async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Evalúa un `lock_string` contra un personaje para ver si puede pasar el lock.
    """
    if not lock_string:
        return True, ""

    try:
        # 1. Parsear el string a un árbol AST. `mode='eval'` espera una sola expresión.
        tree = ast.parse(lock_string, mode='eval')

        # 2. Crear una instancia de nuestro evaluador con el contexto del personaje.
        evaluator = LockEvaluator(character)

        # 3. Visitar el árbol para obtener el resultado booleano.
        result = evaluator.visit(tree.body)

        if result:
            return True, ""
        else:
            return False, "Permiso denegado."

    except SyntaxError:
        logging.error(f"Error de sintaxis en el lock string: '{lock_string}'")
        return False, "Error en la definición de permisos de esta acción."
    except Exception as e:
        logging.exception(f"Error inesperado al evaluar el lock string: '{lock_string}'")
        return False, "Error interno al comprobar los permisos."
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py
"""
Módulo de Servicio para la Gestión de Jugadores y Personajes.

Este es uno de los servicios centrales de la aplicación. Encapsula toda la
lógica de negocio para crear, recuperar y modificar las entidades `Account` y
`Character`.

Actúa como la única capa que interactúa directamente con los modelos de jugador,
asegurando que toda la lógica de negocio esté centralizada y sea consistente.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.services import channel_service, command_service


async def get_character_with_relations_by_id(session: AsyncSession, character_id: int) -> Character | None:
    """
    Busca un personaje por su ID y carga explícitamente todas sus relaciones
    críticas (sala, inventario, cuenta, configuraciones) en una sola consulta.

    Esta es una función de ayuda crucial para evitar errores de "carga perezosa"
    (lazy loading) en un entorno asíncrono.
    """
    try:
        query = (
            select(Character)
            .where(Character.id == character_id)
            .options(
                selectinload(Character.room).selectinload(Room.items),
                selectinload(Character.room).selectinload(Room.exits_from),
                selectinload(Character.items),
                selectinload(Character.account),
                selectinload(Character.settings)
            )
        )
        result = await session.execute(query)
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al obtener el personaje completo con ID {character_id}")
        return None

async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Garantiza que el objeto `Account` devuelto contenga un `Character` completamente
    cargado si este existe.
    """
    try:
        # 1. Buscar la cuenta y su personaje asociado.
        account_query = select(Account).where(Account.telegram_id == telegram_id).options(selectinload(Account.character))
        result = await session.execute(account_query)
        account = result.scalar_one_or_none()

        # 2. Si la cuenta no existe, crearla y devolverla.
        if not account:
            logging.info(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
            new_account = Account(telegram_id=telegram_id)
            session.add(new_account)
            await session.commit()
            await session.refresh(new_account)
            return new_account

        # 3. Si la cuenta existe pero no tiene personaje, devolverla tal cual.
        if not account.character:
            return account

        # 4. Si la cuenta y el personaje existen, usar nuestra función de ayuda para
        #    asegurarnos de que el personaje está completamente cargado con todas sus relaciones.
        full_character = await get_character_with_relations_by_id(session, account.character.id)
        account.character = full_character
        return account
    except Exception:
        logging.exception(f"Error al obtener o crear la cuenta para telegram_id {telegram_id}")
        # En caso de un fallo crítico, es más seguro devolver None.
        return None

async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje, lo asocia a una cuenta, y dispara los hooks de bienvenida.
    """
    account = await get_or_create_account(session, telegram_id)
    if not account:
        raise RuntimeError("No se pudo obtener o crear una cuenta de usuario.")

    # Validaciones de negocio
    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya está en uso. Por favor, elige otro.")

    # Creación y persistencia
    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1 # Asigna a la sala de inicio "limbo"
    )
    session.add(new_character)
    await session.commit()

    # Recargamos el personaje por completo para tener todas las relaciones disponibles.
    full_character = await get_character_with_relations_by_id(session, new_character.id)
    if not full_character:
        raise RuntimeError("No se pudo recargar el personaje recién creado.")

    # Hooks de post-creación
    await channel_service.get_or_create_settings(session, full_character)
    welcome_message = (
        f"¡Bienvenido al mundo, {full_character.name}! "
        "Usa los comandos de movimiento como <b>/norte</b> o <b>/sur</b> para explorar. "
        "Si necesitas ayuda, puedes preguntar en este canal usando <b>/novato [tu pregunta]</b>. "
        "Para una lista de comandos más detallada, escribe <b>/ayuda</b>."
    )
    await channel_service.broadcast_to_channel(session, "novato", welcome_message)

    await command_service.update_telegram_commands(full_character)

    return full_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala actualizando su `room_id`."""
    # Validación: asegurar que la sala de destino existe.
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    # Actualización atómica
    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py
"""
Módulo de Servicio para la Ejecución de Scripts.

Este servicio actúa como el "traductor" entre el contenido del juego (definido
como strings en los archivos de prototipos) y la lógica del motor (código Python).
Permite que los diseñadores de contenido invoquen funcionalidades del motor
sin necesidad de escribir código.

Funciona con un sistema de registro:
1.  Las funciones de script se definen en este archivo.
2.  Se registran en el diccionario `SCRIPT_REGISTRY` con un nombre único.
3.  Los archivos de prototipos en `game_data` usan ese nombre para referirse a ellas.
4.  El método `execute_script` se encarga de parsear el string, buscar la
    función en el registro y ejecutarla con el contexto adecuado.
"""

import re
import random
import logging
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.character import Character
from src.models.item import Item
from src.models.room import Room
from src.services import broadcaster_service


# ==============================================================================
# SECCIÓN 1: DEFINICIONES DE LAS FUNCIONES DE SCRIPT
#
# Cada función aquí es una "habilidad" que el motor ofrece a los diseñadores
# de contenido. Deben ser genéricas y reutilizables.
# ==============================================================================

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Notifica al jugador que un objeto brilla al ser mirado.

    - Disparador Típico: `on_look` en un prototipo de objeto.
    - Contexto Esperado: `character` (quien mira), `target` (el objeto mirado).
    - Argumentos: `color` (str, opcional) - el color del brillo.
    """
    color = kwargs.get("color", "una luz misteriosa")
    message = f"🌟 Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."
    await broadcaster_service.send_message_to_character(character, message)


async def script_espada_susurra_secreto(session: AsyncSession, target: Item, character: Character, **kwargs):
    """
    Script de ticker: Hace que un objeto emita un susurro a un personaje activo
    que se encuentre en la misma sala.

    - Disparador Típico: `tickers` en un prototipo de objeto.
    - Contexto Esperado: `target` (el objeto que susurra), `character` (el jugador que escucha).
    - Argumentos: Ninguno.
    """
    secretos = [
        "El tesoro se encuentra bajo la sombra del roble marchito...",
        "La llave oxidada no abre una puerta, sino un corazón...",
        "Cuidado con el que no proyecta sombra...",
    ]
    secreto_elegido = random.choice(secretos)
    mensaje = f"<i>Un susurro escalofriante parece emanar de {target.get_name()}: \"{secreto_elegido}\"</i>"
    await broadcaster_service.send_message_to_character(character, mensaje)


# ==============================================================================
# SECCIÓN 2: REGISTRO DE SCRIPTS
#
# Este diccionario es el puente entre los nombres de los scripts (strings)
# y las funciones de Python reales. Para que un script pueda ser llamado
# desde `game_data`, DEBE estar registrado aquí.
# ==============================================================================

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,
    # Futuros scripts se añadirían aquí.
}


# ==============================================================================
# SECCIÓN 3: EL MOTOR DE EJECUCIÓN
#
# Lógica interna del servicio para interpretar y ejecutar los scripts.
# ==============================================================================

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre(clave=valor, ...)' y devuelve
    el nombre de la función y un diccionario de argumentos.

    Limitación actual: solo soporta argumentos simples de tipo `clave=valor`.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        # Si el script no tiene paréntesis, se asume que no tiene argumentos.
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            logging.warning(f"Argumentos de script mal formados en '{script_string}'. Ignorando argumentos.")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El corazón del motor de scripts. Parsea el string, busca la función en
    el registro y la ejecuta con el contexto proporcionado.

    Args:
        script_string (str): El string del script a ejecutar (ej: "mi_script(arg=val)").
        session (AsyncSession): La sesión de base de datos activa.
        **context: Un diccionario con las entidades relevantes al evento
                   (ej: `character`, `target`, `room`).
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        try:
            # Ejecutamos la función encontrada, pasando el contexto y los argumentos parseados.
            await script_function(session=session, **context, **kwargs)
        except Exception:
            # Si un script falla, registramos el error con un traceback completo
            # pero no detenemos la ejecución del resto del juego.
            logging.exception(f"Ocurrió un error al ejecutar el script '{script_name}'")
    else:
        logging.warning(f"ADVERTENCIA: Se intentó ejecutar un script desconocido: '{script_name}'")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/ticker_service.py ===
# src/services/ticker_service.py
"""
Módulo de Servicio para Tareas Programadas (Tickers).

Este servicio es el "corazón" que hace que el mundo de Runegram se sienta vivo.
Utiliza la librería APScheduler para ejecutar scripts de forma periódica,
independientemente de las acciones de los jugadores.

Responsabilidades:
- Inicializar y configurar el scheduler global (APScheduler).
- Cargar las definiciones de tickers desde los prototipos de `game_data`.
- Programar, ejecutar y gestionar el ciclo de vida de estas tareas.
- Determinar el contexto correcto para un ticker (ej: la sala de un objeto)
  y filtrar su ejecución (ej: solo para jugadores activos).
"""

import logging
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.db import async_session_factory
from src.services import script_service, online_service, player_service
from src.models import Item, Room, Character

# Instancia única del scheduler para toda la aplicación.
scheduler = AsyncIOScheduler()


# ==============================================================================
# SECCIÓN DE FUNCIONES AUXILIARES
# ==============================================================================

def parse_schedule(schedule_str: str) -> tuple[str, dict]:
    """
    Parsea el string de schedule del prototipo y lo convierte en argumentos para APScheduler.
    """
    if schedule_str.startswith("interval:"):
        seconds = int(schedule_str.split(':')[1])
        return 'interval', {'seconds': seconds}
    if schedule_str.startswith("date:"):
        date_val = schedule_str.split(':', 1)[1]
        return 'date', {'run_date': date_val}
    cron_expr = schedule_str
    if schedule_str.startswith("cron:"):
        cron_expr = schedule_str.split(':', 1)[1]
    parts = cron_expr.strip().split()
    if len(parts) != 5:
        logging.warning(f"ADVERTENCIA: Expresión cron mal formada en '{schedule_str}'. Se ignora.")
        return 'cron', {}
    cron_args = { 'minute': parts[0], 'hour': parts[1], 'day': parts[2], 'month': parts[3], 'day_of_week': parts[4] }
    return 'cron', cron_args


async def get_entity_by_id(session: AsyncSession, entity_id: int, entity_type: str):
    """
    Busca una entidad por su ID y tipo, cargando explícitamente las relaciones
    necesarias para evitar errores de carga perezosa.
    """
    MODEL_MAP = {"Item": Item, "Room": Room, "Character": Character}
    model_class = MODEL_MAP.get(entity_type)
    if not model_class:
        logging.warning(f"ADVERTENCIA: Tipo de entidad desconocido '{entity_type}' para ticker.")
        return None

    query = select(model_class)
    if model_class is Item:
        query = query.options(
            selectinload(Item.room),
            selectinload(Item.character).selectinload(Character.room)
        )
    elif model_class is Character:
        query = query.options(selectinload(Character.room), selectinload(Character.account))

    query = query.where(model_class.id == entity_id)
    result = await session.execute(query)
    return result.scalar_one_or_none()


# ==============================================================================
# SECCIÓN DE INICIALIZACIÓN Y CARGA
# ==============================================================================

def initialize_scheduler():
    """Configura y arranca el scheduler global. Debe llamarse al iniciar el bot."""
    jobstores = {'default': SQLAlchemyJobStore(url=settings.sync_database_url)}
    scheduler.configure(jobstores=jobstores)
    scheduler.start()
    logging.info("⏰ Ticker Service iniciado y listo para programar tareas.")

async def load_and_schedule_all_tickers(session: AsyncSession):
    """
    Busca todas las entidades con tickers en la base de datos (actualmente solo Items)
    y las programa. Debe llamarse una vez al iniciar el bot para asegurar la persistencia.
    """
    logging.info("Cargando y programando tickers para todas las entidades existentes...")
    try:
        result = await session.execute(select(Item))
        all_items = result.scalars().all()
        for item in all_items:
            if item.prototype.get("tickers"):
                logging.info(f"  -> Programando tickers para el item '{item.key}' (ID: {item.id})")
                await schedule_tickers_for_entity(item)
        logging.info("Carga de tickers existentes finalizada.")
    except Exception:
        logging.exception("Error al cargar los tickers de entidades existentes.")


# ==============================================================================
# SECCIÓN DE EJECUCIÓN DE TAREAS
# ==============================================================================

async def schedule_tickers_for_entity(entity):
    """
    Lee los tickers del prototipo de una entidad y los añade al scheduler.
    """
    prototype_tickers = entity.prototype.get("tickers", [])
    for ticker_data in prototype_tickers:
        schedule_str = ticker_data.get("schedule")
        script_str = ticker_data.get("script")
        category = ticker_data.get("category", "ambient")

        if not schedule_str or not script_str:
            continue
        trigger_type, trigger_args = parse_schedule(schedule_str)
        if not trigger_args:
            continue

        job_id = f"ticker_{type(entity).__name__}_{entity.id}_{schedule_str}_{script_str}"
        scheduler.add_job(
            execute_ticker_script, trigger=trigger_type,
            args=[entity.id, type(entity).__name__, script_str, category],
            id=job_id, replace_existing=True, **trigger_args
        )

async def execute_ticker_script(entity_id: int, entity_type: str, script_string: str, category: str):
    """
    Función que APScheduler llama. Prepara el contexto, comprueba la actividad
    del jugador y delega la ejecución al script_service.
    """
    async with async_session_factory() as session:
        try:
            entity = await get_entity_by_id(session, entity_id, entity_type)
            if not entity: return

            # 1. Determinar la sala de contexto del ticker.
            room = None
            if hasattr(entity, 'room') and entity.room:
                room = entity.room
            elif hasattr(entity, 'character') and entity.character and entity.character.room:
                room = entity.character.room

            if not room: return

            # 2. Encontrar los IDs de los personajes en esa sala.
            char_ids_query = select(Character.id).where(Character.room_id == room.id)
            result = await session.execute(char_ids_query)
            char_ids_in_room = result.scalars().all()

            # 3. Iterar sobre cada personaje, aplicar filtros y ejecutar el script.
            for char_id in char_ids_in_room:
                is_online = await online_service.is_character_online(char_id)
                if category == "ambient" and not is_online:
                    continue

                full_character = await player_service.get_character_with_relations_by_id(session, char_id)
                if not full_character:
                    continue

                context = {
                    "target": entity,
                    "room": full_character.room,
                    "character": full_character
                }

                await script_service.execute_script(
                    script_string=script_string,
                    session=session,
                    **context
                )
        except Exception:
            logging.exception(f"Error crítico en la ejecución del ticker para {entity_type} {entity_id}")
# === FIN: src/services/ticker_service.py ===


# === INICIO: src/services/world_loader_service.py ===
# src/services/world_loader_service.py
"""
Módulo de Servicio para la Carga del Mundo.

Este servicio es el responsable de construir y sincronizar el mundo estático del
juego (salas y salidas) con la base de datos. Se ejecuta una sola vez durante
el arranque de la aplicación.

Lee las definiciones de contenido desde `game_data/room_prototypes.py` y se
asegura de que el estado de la base de datos refleje fielmente esa "fuente de
la verdad".
"""

import logging
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Room, Exit
from game_data.room_prototypes import ROOM_PROTOTYPES

# Mapa de direcciones opuestas para crear automáticamente las salidas bidireccionales.
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def sync_world_from_prototypes(session: AsyncSession):
    """
    Sincroniza la base de datos con los prototipos de salas. Esta función es
    idempotente: se puede ejecutar de forma segura en cada arranque.

    Su lógica es:
    1. Crea/actualiza las salas.
    2. Borra todas las salidas existentes.
    3. Recrea todas las salidas, aplicando los `locks` definidos en los prototipos.
    """
    logging.info("Sincronizando el mundo estático desde los prototipos...")
    try:
        # --- PASO 1: Sincronizar Salas ---
        room_key_to_id_map = {}

        existing_rooms_query = await session.execute(select(Room))
        existing_rooms = {room.key: room for room in existing_rooms_query.scalars().all()}

        for key, data in ROOM_PROTOTYPES.items():
            room = existing_rooms.get(key)
            if not room:
                logging.info(f"  -> Creando sala '{key}'...")
                room = Room(key=key, name=data['name'], description=data['description'])
                session.add(room)
            else:
                room.name = data['name']
                room.description = data['description']

            await session.flush()
            room_key_to_id_map[key] = room.id

        # --- PASO 2: Limpiar Salidas Viejas ---
        logging.info("  -> Limpiando todas las salidas existentes para reconstruir...")
        await session.execute(delete(Exit))

        # --- PASO 3: Crear Salidas Nuevas con Locks ---
        for key, data in ROOM_PROTOTYPES.items():
            from_room_id = room_key_to_id_map[key]
            for direction, exit_data in data.get("exits", {}).items():
                # El prototipo ahora puede ser un string simple o un diccionario.
                if isinstance(exit_data, str):
                    to_room_key = exit_data
                    lock_string = ""
                elif isinstance(exit_data, dict):
                    to_room_key = exit_data.get("to")
                    lock_string = exit_data.get("locks", "")
                else:
                    continue # Ignorar formato incorrecto

                if to_room_key in room_key_to_id_map:
                    to_room_id = room_key_to_id_map[to_room_key]

                    # Crear la salida principal, incluyendo su lock.
                    exit_forward = Exit(
                        name=direction.lower(),
                        from_room_id=from_room_id,
                        to_room_id=to_room_id,
                        locks=lock_string
                    )
                    session.add(exit_forward)

                    # Crear la salida de vuelta automáticamente (sin lock por defecto).
                    opposite = OPPOSITE_DIRECTIONS.get(direction.lower())
                    if opposite:
                        # La salida de vuelta no hereda el lock, debe definirse explícitamente.
                        exit_backward = Exit(name=opposite, from_room_id=to_room_id, to_room_id=from_room_id)
                        session.add(exit_backward)
                else:
                    logging.warning(f"  -> La sala de destino '{to_room_key}' definida en la sala '{key}' no existe. Se ignora la salida.")

        await session.commit()
        logging.info("¡Sincronización del mundo completada!")
    except Exception:
        logging.exception("Error fatal durante la sincronización del mundo.")
        raise
# === FIN: src/services/world_loader_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py
"""
Módulo de Servicio con Utilidades para el Mundo.

Este servicio contiene funciones de ayuda de bajo nivel para interactuar
con las entidades del mundo, principalmente el modelo `Room`.

A diferencia del `world_loader_service` que construye el mundo al arrancar,
las funciones aquí presentes son utilidades genéricas que pueden ser llamadas
desde otras partes del código, como los comandos.

NOTA: Varias funciones en este archivo (`create_room`, `link_rooms`) han quedado
obsoletas por el sistema de carga de mundo basado en prototipos, pero se
mantienen por si son de utilidad para futuras herramientas de administración
o para depuración.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit


async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """
    Busca y devuelve una sala por su ID numérico.

    Args:
        session (AsyncSession): La sesión de base de datos activa.
        room_id (int): El ID de la sala a buscar.

    Returns:
        Room | None: El objeto de la sala si se encuentra, de lo contrario None.
    """
    try:
        result = await session.execute(select(Room).where(Room.id == room_id))
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al buscar la sala con ID {room_id}")
        return None

# ==============================================================================
# Las siguientes funciones han sido mayormente reemplazadas por el sistema de
# carga de mundo (`world_loader_service`) y ya no se usan en el flujo principal.
# Se conservan para posible uso futuro en herramientas de administración.
# ==============================================================================

async def create_room(session: AsyncSession, name: str) -> Room:
    """
    (Obsoleto) Crea una nueva sala en la base de datos.
    """
    if not name:
        raise ValueError("El nombre de la sala no puede estar vacío.")
    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """
    (Obsoleto) Actualiza la descripción de una sala existente.
    """
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """
    (Obsoleto) Crea una salida (y opcionalmente su opuesta) entre dos salas.
    """
    # Mapa de direcciones opuestas, duplicado aquí para que la función sea autónoma.
    OPPOSITE_DIRECTIONS = {
        "norte": "sur", "sur": "norte", "este": "oeste", "oeste": "este",
        "arriba": "abajo", "abajo": "arriba", "dentro": "fuera", "fuera": "dentro",
        "noreste": "suroeste", "suroeste": "noreste", "noroeste": "sureste", "sureste": "noroeste",
    }

    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===
# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py
"""
Módulo de Utilidades de Presentación (Presenters).

Este archivo contiene funciones cuya única responsabilidad es tomar los objetos
de datos del juego (como `Room`, `Item`, `Character`) y convertirlos en texto
formateado listo para ser mostrado al jugador en Telegram.

Esta capa de "presentación" separa la lógica de cómo se ven las cosas (formato
HTML, colores, etc.) de la lógica de negocio del juego (que reside en los
servicios).
"""

import logging
from aiogram import types
from collections import Counter

from src.models.room import Room
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripción completa de una sala para ser
    mostrada al jugador.

    Args:
        room (Room): El objeto de la sala a formatear, con sus relaciones
                     (`items`, `exits_from`) ya cargadas.

    Returns:
        str: Un string formateado con HTML (`<pre>`, `<b>`) listo para ser enviado.
    """
    try:
        parts = []

        # 1. Título de la Sala
        parts.append(f"<b>{room.name}</b>")

        # 2. Descripción principal
        parts.append(room.description.strip())

        # 3. Objetos en la sala
        if room.items:
            # Usamos `collections.Counter` para agrupar objetos idénticos.
            # Por ejemplo, tres objetos con `get_name()`="una moneda de oro"
            # se mostrarán como "una moneda de oro (3)".
            item_names = [item.get_name() for item in room.items]
            item_counts = Counter(item_names)
            formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
            items_str = ", ".join(formatted_items)
            parts.append(f"\n<b>Ves aquí:</b> {items_str}.")

        # 4. Salidas
        if room.exits_from:
            # Ordenamos las salidas alfabéticamente para una visualización consistente.
            exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
            exits_str = ", ".join(exits_list)
            parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
        else:
            parts.append("\n<b>Salidas:</b> [ Ninguna ]")

        # Unimos todas las partes y las envolvemos en una etiqueta <pre>
        # para mantener el formato de monoespaciado y los saltos de línea.
        description_body = "\n".join(parts)
        return f"<pre>{description_body}</pre>"

    except Exception:
        logging.exception(f"Error al formatear la descripción de la sala ID {room.id}")
        return "<pre><b>Error:</b> No se pudo mostrar la descripción de la sala.</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripción formateada.
    Esta función centraliza la lógica común de "mirar" el entorno.
    """
    try:
        async with async_session_factory() as session:
            # Usamos el servicio para obtener la cuenta y sus relaciones precargadas.
            account = await player_service.get_or_create_account(session, message.from_user.id)

            if not account or not account.character or not account.character.room:
                # Esta es una salvaguarda. No debería ocurrir en un flujo normal.
                await message.answer("Parece que estás perdido en el vacío. Te hemos llevado a un lugar seguro.")
                # Futuro: Aquí podríamos teletransportar al jugador a la sala de inicio.
                return

            room = account.character.room
            # Usamos nuestro formateador para construir el texto de la sala.
            formatted_room = await format_room(room)

            await message.answer(formatted_room, parse_mode="HTML")

    except Exception:
        await message.answer("❌ Ocurrió un error al mostrar tu ubicación actual.")
        logging.exception(f"Fallo en show_current_room para el usuario {message.from_user.id}")
# === FIN: src/utils/presenters.py ===


