# === INICIO: .gitignore ===
project_snapshot.txt
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¬°Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Cach√© de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Cach√© de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querr√°s subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de c√≥digo
# Configuraciones espec√≠ficas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena pr√°ctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: Dockerfile ===
# Dockerfile para la Aplicaci√≥n Runegram MUD
#
# Este archivo define los pasos para construir la imagen Docker que contendr√°
# y ejecutar√° la aplicaci√≥n del bot. Docker utiliza esta "receta" para crear un
# entorno autocontenido y reproducible.
#
# El proceso de construcci√≥n sigue estos pasos:
# 1. FROM: Se parte de una imagen base oficial de Python sobre Alpine Linux.
# 2. RUN (apk): Se instalan las dependencias a nivel de sistema operativo que
#    necesita nuestra aplicaci√≥n (ej: librer√≠as de PostgreSQL, herramientas de red).
# 3. WORKDIR: Se establece el directorio de trabajo dentro del contenedor.
# 4. COPY / RUN (pip): Se copia primero el archivo de dependencias de Python y se
#    instalan. Este paso se hace por separado para aprovechar la cach√© de Docker.
#    Si el `requirements.txt` no cambia, Docker no volver√° a ejecutar este paso,
#    acelerando construcciones futuras.
# 5. COPY (c√≥digo fuente): Se copia el resto del c√≥digo de la aplicaci√≥n.
# 6. CMD: Se define el comando por defecto que se ejecutar√° al iniciar el contenedor,
#    el cual es interceptado y gestionado por nuestro `entrypoint.sh`.

# 1. Imagen Base
# Usamos la imagen oficial de Python 3.11 basada en Alpine Linux.
# Alpine es una distribuci√≥n muy ligera, lo que resulta en una imagen final m√°s peque√±a.
FROM python:3.11-alpine

# 2. Dependencias del Sistema
# Usamos el gestor de paquetes de Alpine (`apk`) para instalar software necesario.
# --no-cache: No guarda el √≠ndice de paquetes, manteniendo la imagen ligera.
# - postgresql-libs: Librer√≠as C requeridas por el driver `psycopg2-binary`.
# - netcat-openbsd: Herramienta de red utilizada en `entrypoint.sh` para esperar a PostgreSQL.
# - git: Puede ser √∫til para instalar dependencias de Python directamente desde repositorios.
RUN apk add --no-cache postgresql-libs netcat-openbsd git

# 3. Directorio de Trabajo
# Establece el directorio de trabajo por defecto dentro del contenedor.
# Todos los comandos `RUN`, `CMD`, `ENTRYPOINT`, `COPY` y `ADD` posteriores
# se ejecutar√°n en este directorio.
WORKDIR /app

# 4. Dependencias de Python
# Copiamos solo el archivo de requerimientos primero. Esto es una optimizaci√≥n
# de la cach√© de Docker. Si nuestro c√≥digo cambia pero `requirements.txt` no,
# Docker reutilizar√° la capa de imagen ya existente donde se instalaron las
# dependencias, haciendo que la reconstrucci√≥n sea mucho m√°s r√°pida.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. C√≥digo Fuente de la Aplicaci√≥n
# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable.
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

# Copiamos el resto del c√≥digo fuente del proyecto al directorio de trabajo (`/app`).
COPY . .

# 6. Comando de Ejecuci√≥n
# Define el comando por defecto que se ejecutar√° al iniciar un contenedor
# a partir de esta imagen.
# IMPORTANTE: Este comando se pasa como argumento a nuestro `entrypoint.sh`
# (definido en `docker-compose.yml`), que lo ejecuta al final con `exec "$@"`.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: NOTAS.md ===
## Telegram

### Mi ID de usuario (benabbhi)

1648877346

## Postgres

### Conectarse

```shell
docker-compose exec postgres psql -U runegram -d runegram_db
```
### Ver tablas

```
\dt
```

## Docker

### Prune

```shell
docker system prune -a --volumes
```

## TODO

* Las salas no muestran los objetos caidos
* Como se determina que comando le corresponde a quie?
* No se actualizan ambos extremos de las salidas
# === FIN: NOTAS.md ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

Runegram es un proyecto para crear un juego de rol textual multijugador (MUD - Multi-User Dungeon) que se juega a trav√©s de la interacci√≥n con un bot de Telegram. Este repositorio contiene el motor de un juego funcional, con una arquitectura escalable lista para la expansi√≥n masiva de contenido.

## Filosof√≠a de Dise√±o

### Motor vs. Contenido
La arquitectura del proyecto se divide en dos conceptos clave para m√°xima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **c√≥digo fuente** de la aplicaci√≥n. Es la maquinaria gen√©rica que hace que el juego funcione (conexi√≥n a la base de datos, comunicaci√≥n con Telegram, ejecuci√≥n de l√≥gica). No sabe qu√© es una "espada", solo sabe c√≥mo manejar un "√çtem".
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** que dan vida al mundo. Aqu√≠ se define qu√© es una "espada", qu√© hace el comando "atacar", o qu√© monstruos existen. Est√° dise√±ado para que los dise√±adores de juego puedan a√±adir contenido sin tocar el motor principal.

### Filosof√≠a de Comandos
Los comandos en Runegram buscan ser simples, descriptivos e intuitivos. Se prefiere la claridad de tener m√°s comandos dedicados (ej: `/activarcanal`, `/desactivarcanal`) a la complejidad de un √∫nico comando con m√∫ltiples subcomandos. El formato preferido es `/<acci√≥n> [argumentos]`.

Adem√°s, el motor del juego genera din√°micamente comandos de comunicaci√≥n a partir del contenido definido en `game_data`. Si un dise√±ador crea un nuevo canal de chat llamado "Comercio" (`comercio`), el comando `/comercio [mensaje]` estar√° disponible autom√°ticamente para los jugadores, asegurando que el contenido y la interfaz est√©n siempre sincronizados.

## Sistemas Clave Implementados

### 1. Carga del Mundo Dirigida por Datos
El mundo est√°tico del juego se define enteramente en `game_data/room_prototypes.py`. Al iniciar el bot, un `world_loader_service` lee este "mapa maestro" y sincroniza la base de datos, garantizando un mundo consistente en cada reinicio.

### 2. Sistema de Comandos Din√°micos y Contextuales
La lista de comandos disponibles para un jugador cambia en tiempo real seg√∫n su contexto (rol, inventario, ubicaci√≥n). Un `command_service` centralizado construye la lista de comandos activos y la sincroniza con la interfaz del cliente de Telegram en cada cambio de contexto.

### 3. Sistema de Permisos (Locks) Extensible
Inspirado en frameworks de MUDs como Evennia, el sistema de `locks` permite un control de acceso granular.
*   **Sintaxis Potente:** Los `locks` son strings que soportan l√≥gica booleana (`rol(ADMIN) or tiene_objeto(llave)`).
*   **Parser Seguro:** Un `permission_service` utiliza el m√≥dulo `ast` de Python para parsear y evaluar estos `locks` de forma segura.
*   **Extensible:** A√±adir nuevos tipos de chequeos (ej: `habilidad(magia)>50`) es tan simple como registrar una nueva funci√≥n de `lock`.

### 4. Sistema Dual de Scripts: Eventos y Tickers
El motor permite que el contenido ejecute l√≥gica a trav√©s de dos sistemas:
*   **Scripts Reactivos (Eventos):** Disparados por acciones del jugador (ej: `"on_look": "..."`).
*   **Scripts Proactivos (Tickers):** Se ejecutan de forma programada (`APScheduler`), haciendo que el mundo se sienta vivo (ej: un objeto que susurra cada 5 minutos). Los tickers de categor√≠a `"ambient"` se pausan para jugadores inactivos.

### 5. Sistema de Canales y Presencia
Para facilitar la comunicaci√≥n y la inmersi√≥n:
*   **Seguimiento de Actividad (`online_service.py`):** Utiliza Redis para rastrear si un jugador est√° "online" (activo en los √∫ltimos 5 minutos) y notifica los cambios de estado a AFK.
*   **Canales (`channel_service.py`):** Permiten la comunicaci√≥n global. Los comandos de chat (`/novato`, etc.) se generan din√°micamente a partir de `game_data/channel_prototypes.py`.

## Estructura del Proyecto
*(La estructura del proyecto se mantiene igual, no necesita cambios)*

## Puesta en Marcha
*(Las instrucciones de puesta en marcha se mantienen igual, no necesitan cambios)*

---

## Visi√≥n a Futuro y Tareas Pendientes (TODO)
*(Esta secci√≥n se actualiza para reflejar el progreso)*

### üöÄ **Pr√≥ximas Grandes Funcionalidades**

*   #### **Sistema de Combate y Habilidades**
    *   **Visi√≥n:** Crear un sistema de combate y progresi√≥n de habilidades basado en una mec√°nica de d100.
    *   **Tareas:**
        1.  **Modelos de Datos:** Crear `Skill`, `CharacterSkill` y a√±adir atributos de combate (Salud, Man√°) a `Character`.
        2.  **Mec√°nica d100:** Implementar la l√≥gica de "aprender haciendo".
        3.  **PNJs y Spawners:** Crear `npc_prototypes.py`, un modelo `NPC` y un `npc_service` para gestionar su IA y respawns.
        4.  **Comandos de Combate:** Crear el `CommandSet` de combate (`/atacar`, `/huir`, etc.).

*   #### **Expandir el Sistema de Locks y Permisos**
    *   **Visi√≥n:** Utilizar el nuevo motor de `locks` para crear interacciones m√°s complejas.
    *   **Tareas:**
        1.  **A√±adir Nuevas Funciones de Lock:** Implementar y registrar funciones como `habilidad(nombre)>valor`, `clase(nombre)`, etc.
        2.  **Aplicar a Contenido:** A√±adir `locks` a prototipos de objetos (ej: un arma que requiere una habilidad) y salidas (ej: una puerta que requiere una llave).
        3.  **Comandos de Admin:** Crear comandos `/lock` y `/unlock` para que los administradores puedan modificar los `locks` de las entidades en vivo.

### ‚ú® **Mejoras del Motor y Calidad de Vida**

*   **Bandeja de Entrada para Notificaciones:** Implementar un sistema que guarde los tickers de categor√≠a `important` o `quest` para jugadores inactivos y se los presente al volver a conectarse.
*   **Sistema de Contenedores:** Expandir los √≠tems para que puedan ser contenedores (mochilas, cofres) con su propio inventario, capacidad y `locks`.
*   **Mejorar Comando `/decir`:** Hacer que el comando env√≠e mensajes a todos los jugadores *online* en la misma sala, utilizando el `broadcaster_service`.
*   **Sistema de Clases y Razas (FSM):** Usar una M√°quina de Estados Finitos (FSM) de Aiogram para guiar la creaci√≥n de personaje, permitiendo elegir clase y raza, lo que establecer√° sus `CommandSets` base y atributos iniciales.

# === FIN: README.md ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCI√ìN PRINCIPAL DE ALEMBIC
# Aqu√≠ se definen las configuraciones m√°s importantes.
# ==============================================================================
[alembic]

# --- Ubicaci√≥n de los Scripts de Migraci√≥n ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la ra√≠z del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA L√çNEA M√ÅS IMPORTANTE.
# Le dice a Alembic c√≥mo conectarse a tu base de datos PostgreSQL.
# La magia aqu√≠ es que no ponemos la contrase√±a directamente.
# El archivo `alembic/env.py` se encargar√° de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define c√≥mo se nombran los nuevos archivos de migraci√≥n.
# {rev} es el ID de la revisi√≥n, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos despu√©s de que se genera un nuevo archivo de migraci√≥n.
# Es muy √∫til para formatear autom√°ticamente el c√≥digo con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACI√ìN DE LOGGING
# Define c√≥mo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aqu√≠, la configuraci√≥n por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml
#
# Este archivo es la pieza central para orquestar los diferentes servicios
# (contenedores) que componen la aplicaci√≥n Runegram. Docker Compose lee
# este archivo para construir, iniciar, conectar y gestionar todos los
# contenedores de forma conjunta.
#
# Servicios definidos:
# 1. bot:       El contenedor principal de la aplicaci√≥n Python que ejecuta el bot de Telegram.
# 2. postgres:  El servicio de base de datos PostgreSQL.
# 3. redis:     El servicio de cach√© en memoria, utilizado para la gesti√≥n de estados
#               de Aiogram y el seguimiento de actividad de los jugadores.

services:
  # --- Servicio de la Aplicaci√≥n Principal del Bot ---
  bot:
    # `build: .` le dice a Docker Compose que construya una imagen para este servicio
    # utilizando el Dockerfile que se encuentra en el directorio actual ('.').
    build: .

    # `entrypoint`: Sobrescribe el ENTRYPOINT por defecto de la imagen. Aqu√≠ especificamos
    # nuestro script `entrypoint.sh`, que se encargar√° de las tareas de preparaci√≥n
    # (esperar a la BD, ejecutar migraciones) antes de lanzar la aplicaci√≥n principal.
    entrypoint: /app/entrypoint.sh

    # `command`: Especifica el comando que se pasa como argumento al `entrypoint`.
    # Nuestro `entrypoint.sh` ejecuta este comando al final con `exec "$@"`.
    command: python run.py

    # `environment`: Define variables de entorno dentro del contenedor.
    # `PYTHONPATH=/app` asegura que Python pueda encontrar nuestros m√≥dulos en `src/`.
    environment:
      - PYTHONPATH=/app

    # `env_file`: Carga las variables de entorno desde el archivo `.env` en la ra√≠z
    # del proyecto. Esto mantiene las credenciales y configuraciones fuera del c√≥digo.
    env_file:
      - .env

    # `depends_on`: Asegura que los servicios `postgres` y `redis` se inicien
    # *antes* de que se inicie el servicio `bot`. No garantiza que est√©n "listos",
    # por eso nuestro `entrypoint.sh` se encarga de esperar activamente.
    depends_on:
      - postgres
      - redis

    # `volumes`: Mapea directorios de nuestra m√°quina local al interior del contenedor.
    # Esto es crucial para el desarrollo, ya que cualquier cambio en nuestro c√≥digo
    # se refleja instant√°neamente dentro del contenedor sin necesidad de reconstruir la imagen.
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      - ./entrypoint.sh:/app/entrypoint.sh

  # --- Servicio de la Base de Datos ---
  postgres:
    # `image`: Utiliza una imagen preconstruida oficial de PostgreSQL desde Docker Hub.
    # La etiqueta `:15-alpine` especifica la versi√≥n 15 sobre Alpine Linux, que es ligera.
    image: postgres:15-alpine

    # `environment`: Configura las credenciales y el nombre de la base de datos
    # inicial. Los valores `${...}` se leen del archivo `.env` en nuestra m√°quina.
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}

    # `volumes`: Mapea un "volumen nombrado" de Docker (`postgres_data`) al directorio
    # donde PostgreSQL guarda sus datos. Esto hace que los datos de la base de datos
    # sean persistentes, sobreviviendo a reinicios o eliminaciones del contenedor.
    volumes:
      - postgres_data:/var/lib/postgresql/data/

    # `ports`: Mapea el puerto 5432 del contenedor al puerto 5432 de nuestra m√°quina local.
    # Esto nos permite conectarnos a la base de datos desde herramientas locales si es necesario.
    ports:
      - "5432:5432"

  # --- Servicio de Cach√© en Memoria ---
  redis:
    # Utiliza la imagen oficial de Redis, versi√≥n 7 sobre Alpine.
    image: redis:7-alpine

    # Mapea el puerto por defecto de Redis para permitir conexiones locales.
    ports:
      - "6379:6379"

# Define los vol√∫menes nombrados que hemos utilizado. Docker se encarga de gestionarlos.
volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: entrypoint.sh ===
#!/bin/sh
#
# Entrypoint para el Contenedor de la Aplicaci√≥n Runegram
#
# Este script se ejecuta cada vez que el contenedor de la aplicaci√≥n ('bot') se inicia.
# Su principal responsabilidad es preparar el entorno antes de lanzar la aplicaci√≥n
# de Python principal.
#
# Tareas:
# 1. Esperar a que el servicio de PostgreSQL est√© completamente disponible y acepte conexiones.
#    Esto evita que la aplicaci√≥n falle al arrancar si el contenedor de la base de datos
#    tarda m√°s en iniciarse.
# 2. Ejecutar las migraciones de la base de datos con Alembic para asegurar que el
#    esquema de la base de datos est√© actualizado con la √∫ltima versi√≥n del c√≥digo.
# 3. Ejecutar el comando principal del contenedor (CMD), que en nuestro caso es
#    `python run.py`, para iniciar el bot.
#
# `set -e`: Este comando es crucial. Asegura que el script se detenga inmediatamente
# si cualquier comando falla (devuelve un c√≥digo de salida distinto de cero).
#
set -e

# --- PASO 1: Esperar a PostgreSQL ---
echo "--- [Entrypoint] Esperando a que PostgreSQL est√© disponible... ---"
# El host 'postgres' es el nombre del servicio definido en docker-compose.yml.
# El comando `nc -z` (netcat) intenta establecer una conexi√≥n sin enviar datos.
# El bucle `while` se repetir√° hasta que el puerto 5432 de 'postgres' est√© abierto.
while ! nc -z postgres 5432; do
  sleep 0.1
done
echo "--- [Entrypoint] ‚úÖ PostgreSQL est√° listo. ---"


# --- PASO 2: Ejecutar Migraciones de la Base de Datos ---
echo "--- [Entrypoint] Ejecutando migraciones de la base de datos con Alembic... ---"
# `alembic upgrade head` aplica todas las migraciones pendientes desde la √∫ltima
# versi√≥n registrada en la base de datos hasta la √∫ltima versi√≥n en los archivos.
alembic upgrade head
echo "--- [Entrypoint] ‚úÖ Migraciones completadas. ---"


# --- PASO 3: Ejecutar el Comando Principal ---
echo "--- [Entrypoint] Iniciando la aplicaci√≥n principal del bot... ---"
# `exec "$@"` es una construcci√≥n de shell especial.
# 'exec' reemplaza el proceso actual del script con el nuevo comando, lo que es
# m√°s eficiente y permite que las se√±ales del sistema (como un 'docker stop')
# lleguen directamente a la aplicaci√≥n de Python.
# `"$@"` expande todos los argumentos que se pasaron al script. En nuestro caso,
# `docker-compose.yml` pasa `python run.py`, por lo que este comando se convierte en
# `exec python run.py`.
exec "$@"
# === FIN: entrypoint.sh ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
APScheduler==3.10.1
python-dateutil
psycopg2-binary==2.9.9
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
"""
Punto de Entrada Principal de la Aplicaci√≥n Runegram MUD.

Este script es el responsable de orquestar el arranque del bot. Sus tareas principales son:
1. Configurar el sistema de logging global para toda la aplicaci√≥n.
2. Definir y registrar las funciones `on_startup` y `on_shutdown` que se ejecutar√°n
   al iniciar y detener el bot, respectivamente.
3. Iniciar el "polling" de Aiogram, que es el bucle principal que escucha los
   mensajes de Telegram.

Para ejecutar la aplicaci√≥n, se llama a este script desde el `entrypoint.sh`
dentro del contenedor Docker.
"""

import logging
import asyncio
import sys
from aiogram import executor
from sqlalchemy import select

from src.bot.dispatcher import dp
from src.services import world_loader_service, ticker_service, online_service
from src.db import async_session_factory
from src.config import settings
from src.models import Account

# Esta importaci√≥n es crucial para que los manejadores de mensajes se registren.
import src.handlers

async def _ensure_superadmin_exists(session):
    """
    Verifica que la cuenta del Superadmin (definida en .env) exista y tenga
    el rol correcto. La crea o actualiza si es necesario.

    Esta funci√≥n de "autocorrecci√≥n" se ejecuta en cada arranque para garantizar
    que el Superadmin siempre est√© configurado correctamente, eliminando la
    necesidad de sembrar datos fr√°giles en las migraciones.
    """
    superadmin_id = settings.superadmin_telegram_id
    if not superadmin_id:
        logging.warning("No se ha definido un SUPERADMIN_TELEGRAM_ID en el archivo .env.")
        return

    result = await session.execute(select(Account).where(Account.telegram_id == superadmin_id))
    superadmin_account = result.scalar_one_or_none()

    if not superadmin_account:
        logging.info(f"Creando cuenta de Superadmin para el telegram_id: {superadmin_id}")
        superadmin_account = Account(telegram_id=superadmin_id, role="SUPERADMIN")
        session.add(superadmin_account)
        await session.commit()
    elif superadmin_account.role != "SUPERADMIN":
        logging.info(f"Actualizando cuenta {superadmin_id} al rol de Superadmin.")
        superadmin_account.role = "SUPERADMIN"
        await session.commit()
    else:
        logging.info("Cuenta de Superadmin verificada.")


async def on_startup(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se inicia con √©xito.
    Inicializa todos los sistemas principales del juego.
    """
    logging.info("Iniciando secuencia de arranque del bot...")

    try:
        # 1. Inicia el scheduler. Es importante que se inicie antes de que cualquier
        #    otro servicio intente a√±adir tareas.
        ticker_service.initialize_scheduler()

        # 2. Crea una sesi√≥n de base de datos para las tareas de inicializaci√≥n.
        async with async_session_factory() as session:
            # Asegura que la cuenta del Superadmin exista y tenga el rol correcto.
            await _ensure_superadmin_exists(session)

            # Sincroniza el mundo est√°tico (salas, salidas) desde los archivos de prototipos.
            await world_loader_service.sync_world_from_prototypes(session)

            # Carga y programa los tickers de los objetos que ya existen en la base de datos.
            await ticker_service.load_and_schedule_all_tickers(session)

        # 3. A√±ade el ticker global para el chequeo de inactividad.
        ticker_service.scheduler.add_job(
            online_service.check_for_newly_afk_players,
            'interval',
            seconds=60,
            id="global_afk_check",
            replace_existing=True
        )
        logging.info("Ticker global para chequeo de AFK a√±adido.")

        logging.info("‚úÖ Secuencia de arranque finalizada. El bot est√° en l√≠nea.")

    except Exception:
        # Si algo falla catastr√≥ficamente durante el arranque, lo registramos
        # y detenemos la aplicaci√≥n para evitar un estado inconsistente.
        logging.exception("‚ùå Error fatal durante la secuencia de arranque. El bot se detendr√°.")
        loop = asyncio.get_running_loop()
        loop.stop()


async def on_shutdown(dispatcher):
    """
    Se ejecuta una sola vez cuando el bot se detiene.
    Se asegura de que los servicios se apaguen de forma limpia.
    """
    logging.warning("Iniciando secuencia de apagado del bot...")
    if ticker_service.scheduler.running:
        ticker_service.scheduler.shutdown()
        logging.info("Scheduler detenido limpiamente.")
    logging.warning("Bot detenido.")


def main():
    """
    Configura el logging principal y arranca el bot.
    """
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s [%(levelname)s] - %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)


if __name__ == "__main__":
    main()
# === FIN: run.py ===


# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACI√ìN DEL PATH ---
# A√±ade el directorio ra√≠z del proyecto al sys.path para que Python
# pueda encontrar nuestros m√≥dulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACI√ìN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneraci√≥n
# y la configuraci√≥n (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---
# Aqu√≠ sobrescribimos la URL de la base de datos que est√° en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuraci√≥n de la aplicaci√≥n.
# Esto centraliza la configuraci√≥n y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACI√ìN DIN√ÅMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Funci√≥n auxiliar que Alembic ejecutar√° de forma s√≠ncrona
    una vez que la conexi√≥n as√≠ncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor as√≠ncrono
    # a partir de la URL de nuestra configuraci√≥n.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma as√≠ncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""A√±adir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser m√°s expl√≠citos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # Nota: La columna 'exits' de tipo JSONB ser√° eliminada por una migraci√≥n posterior,
        # as√≠ que la dejamos aqu√≠ por ahora para mantener la consistencia hist√≥rica.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # A√±adimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Rellenamos las filas existentes con un ID de sala por defecto (1).
    # Esto es necesario para que la siguiente l√≠nea (nullable=False) no falle en bases de datos existentes.
    # El `create_character` service y el `world_loader` aseguran que la sala con ID 1 (limbo) exista.
    op.execute('UPDATE characters SET room_id = 1 WHERE room_id IS NULL')

    # Ahora s√≠, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final.
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_a√±adir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""A√±adir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_a√±adir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""A√±adir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_a√±adir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/abe6da21ae81_a√±adir_columna_de_estado_a_las_cuentas.py ===
"""A√±adir columna de estado a las cuentas

Revision ID: abe6da21ae81
Revises: f17a871c68a1
Create Date: <LA FECHA SE GENERA AUTOM√ÅTICamente>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'abe6da21ae81'
down_revision = 'f17a871c68a1'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('accounts', sa.Column('status', sa.String(length=20), server_default='ACTIVE', nullable=False))
    # NOTA: Se han eliminado las l√≠neas autogeneradas que intentaban
    # borrar la tabla 'apscheduler_jobs', ya que esa tabla es gestionada
    # por otra migraci√≥n y no por los modelos de la aplicaci√≥n.
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('accounts', 'status')
    # NOTA: Se han eliminado las l√≠neas autogeneradas que intentaban
    # recrear la tabla 'apscheduler_jobs' en el downgrade.
    # ### end Alembic commands ###
# === FIN: alembic/versions/abe6da21ae81_a√±adir_columna_de_estado_a_las_cuentas.py ===


# === INICIO: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===
# alembic/script.py.mako

"""A√±adir key a las salas para prototipos

Revision ID: cdb486941d55
Revises: 57531370cbd7
Create Date: 2025-09-30 12:53:43.463923+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cdb486941d55'
down_revision = '57531370cbd7'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('key', sa.String(length=50), nullable=True))
    op.create_index(op.f('ix_rooms_key'), 'rooms', ['key'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_rooms_key'), table_name='rooms')
    op.drop_column('rooms', 'key')
    # ### end Alembic commands ###
# === FIN: alembic/versions/cdb486941d55_a√±adir_key_a_las_salas_para_prototipos.py ===


# === INICIO: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===
"""Crear tabla para apscheduler jobs

Revision ID: db2dac1704aa
Revises: cdb486941d55
Create Date: <LA FECHA SE GENERA AUTOM√ÅTICAMENTE>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db2dac1704aa'
down_revision = 'cdb486941d55'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Crea la tabla 'apscheduler_jobs' con el esquema exacto que espera
    la librer√≠a APScheduler para su SQLAlchemyJobStore.
    """
    op.create_table(
        'apscheduler_jobs',
        sa.Column('id', sa.Unicode(191), primary_key=True),
        sa.Column('next_run_time', sa.Float(25), index=True),
        sa.Column('job_state', sa.LargeBinary, nullable=False)
    )


def downgrade() -> None:
    """
    Elimina la tabla 'apscheduler_jobs' si se revierte la migraci√≥n.
    """
    op.drop_table('apscheduler_jobs')
# === FIN: alembic/versions/db2dac1704aa_crear_tabla_para_apscheduler_jobs.py ===


# === INICIO: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===
"""Crear tabla de configuraciones de personaje

Revision ID: f17a871c68a1
Revises: db2dac1704aa
Create Date: 2025-09-30 14:49:51.717892+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'f17a871c68a1'
down_revision = 'db2dac1704aa'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('character_settings',
    sa.Column('character_id', sa.BigInteger(), nullable=False),
    sa.Column('active_channels', postgresql.JSONB(astext_type=sa.Text()), server_default='{}', nullable=False),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.PrimaryKeyConstraint('character_id')
    )
    # --- Las l√≠neas problem√°ticas han sido eliminadas de aqu√≠ ---
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('character_settings')
    # --- Las l√≠neas problem√°ticas han sido eliminadas de aqu√≠ ---
    # ### end Alembic commands ###
# === FIN: alembic/versions/f17a871c68a1_crear_tabla_de_configuraciones_de_.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Define los cambios para aplicar esta migraci√≥n.
    Crea las tablas iniciales `accounts` y `characters`.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

def downgrade() -> None:
    """
    Define los cambios para revertir esta migraci√≥n.
    Elimina las tablas `characters` y `accounts`.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    # Ya no es necesario eliminar el usuario de seeding, ya que no se crea aqu√≠.
    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###```
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===


# === INICIO: commands/__init__.py ===
# === FIN: commands/__init__.py ===


# === INICIO: commands/command.py ===
# commands/command.py
"""
M√≥dulo que define la Clase Base para todos los Comandos.

Este archivo contiene la clase `Command`, que act√∫a como una plantilla o "contrato"
para todos los comandos del juego. Cada comando, ya sea de jugador o de administrador,
debe heredar de esta clase.

Esto asegura que todos los comandos tengan una estructura consistente y puedan ser
manejados de manera uniforme por el dispatcher principal.
"""

from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character

class Command:
    """
    Clase base abstracta para todos los comandos del juego.

    Atributos:
        names (list[str]): Una lista de alias que pueden invocar este comando.
                           El primer nombre de la lista se considera el principal.
        lock (str): Un string de permisos que el `permission_service` evaluar√°
                    para determinar si el personaje puede ejecutar el comando.
        description (str): Una breve descripci√≥n del prop√≥sito del comando, utilizada
                           para actualizar la lista de comandos en el cliente de Telegram.
    """
    lock: str = ""
    description: str = "Un comando sin descripci√≥n."

    def __init__(self, names: list[str] = None, description: str = None):
        """
        Inicializador que permite la creaci√≥n de instancias de comandos
        con alias y descripciones din√°micas.

        Esto es especialmente √∫til para crear m√∫ltiples comandos a partir de una
        sola clase, como los comandos de movimiento (`/norte`, `/sur`, etc.).

        Args:
            names (list[str], optional): La lista de alias para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
            description (str, optional): La descripci√≥n para esta instancia del comando.
                                         Si no se proporciona, se usa el atributo de clase.
        """
        if names:
            self.names = names
        elif not hasattr(self, 'names'):
            self.names = []

        if description:
            self.description = description
        elif not hasattr(self, 'description'):
            # Asegura que siempre haya una descripci√≥n por defecto.
            self.description = "Un comando sin descripci√≥n."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        """
        El m√©todo principal que se ejecuta cuando se llama al comando.

        Este m√©todo debe ser sobrescrito por cada clase de comando hija.

        Args:
            character (Character): El objeto del personaje que ejecuta el comando,
                                   precargado con todas sus relaciones.
            session (AsyncSession): La sesi√≥n de base de datos activa para esta
                                    interacci√≥n.
            message (types.Message): El objeto de mensaje de Aiogram que contiene
                                     el texto original, el ID del chat, etc.
            args (list[str]): Una lista de los argumentos proporcionados por el
                              usuario despu√©s del nombre del comando.
        """
        # Este m√©todo est√° pensado para ser sobrescrito. Si una subclase no lo
        # implementa, lanzar un NotImplementedError es una buena pr√°ctica para
        # detectar errores durante el desarrollo.
        raise NotImplementedError
# === FIN: commands/command.py ===


# === INICIO: commands/admin/__init__.py ===
from . import building
from . import movement
from . import info
from . import diagnostics
from . import management
# === FIN: commands/admin/__init__.py ===


# === INICIO: commands/admin/building.py ===
# commands/admin/building.py
"""
M√≥dulo de Comandos Administrativos para la Generaci√≥n de Entidades.

Este archivo contiene los comandos que permiten a los administradores "generar"
o "invocar" (`spawn`) entidades en el mundo a partir de sus prototipos
definidos en `game_data`.

Estos comandos no se usan para construir el mundo est√°tico (eso lo hace el
`world_loader_service`), sino para a√±adir contenido din√°mico durante el juego,
como objetos para un evento o PNJ para una misi√≥n.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service
from game_data.item_prototypes import ITEM_PROTOTYPES

class CmdGenerarObjeto(Command):
    """
    Comando para que un administrador cree una instancia de un objeto
    a partir de un prototipo y la coloque en la sala actual.
    """
    names = ["generarobjeto", "genobj"]
    lock = "rol(ADMIN)"  # Solo usuarios con rol ADMIN o superior pueden usarlo.
    description = "Genera un objeto en la sala a partir de su clave de prototipo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # Validaci√≥n de entrada
        if not args:
            await message.answer("Uso: /generarobjeto [key_del_prototipo]")
            return

        item_key = args[0].lower()

        try:
            # Llama al servicio para crear la instancia del objeto en la base de datos.
            item = await item_service.spawn_item_in_room(session, character.room_id, item_key)

            # Obtenemos el nombre "bonito" del prototipo para el mensaje de confirmaci√≥n.
            item_name = ITEM_PROTOTYPES.get(item.key, {}).get("name", "un objeto desconocido")

            await message.answer(f"‚úÖ Objeto '{item_name}' generado en la sala actual.")

        except ValueError as e:
            # Este error se lanza desde `item_service` si la `item_key` no existe.
            await message.answer(f"‚ùå Error: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creaci√≥n.
            await message.answer("‚ùå Ocurri√≥ un error inesperado al generar el objeto.")
            logging.exception(f"Fallo al ejecutar /generarobjeto con la clave '{item_key}'")

# Exportamos la lista de comandos de este m√≥dulo.
SPAWN_COMMANDS = [
    CmdGenerarObjeto(),
]
# === FIN: commands/admin/building.py ===


# === INICIO: commands/admin/diagnostics.py ===
# commands/admin/diagnostics.py
"""
M√≥dulo de Comandos Administrativos para Diagn√≥stico e Inspecci√≥n.

Contiene herramientas para que los administradores puedan inspeccionar el estado
detallado de las entidades del juego, como personajes, objetos y salas.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from sqlalchemy import select

from commands.command import Command
from src.models import Character, Item, Room

class CmdExaminarPersonaje(Command):
    """
    Comando para obtener informaci√≥n detallada sobre un personaje.
    """
    names = ["examinarpersonaje", "exchar"]
    lock = "rol(ADMIN)"
    description = "Muestra informaci√≥n detallada de un personaje. Uso: /exchar [nombre o ID]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /examinarpersonaje [nombre o ID del personaje]")
            return

        target_string = " ".join(args)

        try:
            target_char = None
            try:
                # Buscar por ID
                char_id = int(target_string)
                target_char = await session.get(Character, char_id)
            except ValueError:
                # Buscar por nombre si no es un ID
                query = select(Character).where(Character.name.ilike(f"%{target_string}%"))
                result = await session.execute(query)
                target_char = result.scalar_one_or_none()

            if not target_char:
                await message.answer(f"No se encontr√≥ ning√∫n personaje que coincida con '{target_string}'.")
                return

            # Cargar todas las relaciones para mostrar la informaci√≥n completa
            full_char = await session.get(Character, target_char.id, options=[selectinload("*")])

            lines = [
                f"<b>--- Personaje: {full_char.name} ---</b>",
                f"<b>ID:</b> {full_char.id}",
                f"<b>Cuenta ID:</b> {full_char.account_id} (Rol: {full_char.account.role})",
                f"<b>Sala Actual:</b> {full_char.room.name} (ID: {full_char.room_id})",
                f"<b>CommandSets Base:</b> {', '.join(full_char.command_sets)}",
            ]
            if full_char.items:
                lines.append("<b>Inventario:</b>")
                for item in full_char.items:
                    lines.append(f"  - {item.get_name()} (ID: {item.id}, Key: {item.key})")
            else:
                lines.append("<b>Inventario:</b> Vac√≠o")

            body = '\n'.join(lines)
            await message.answer(f"<pre>{body}</pre>", parse_mode="HTML")

        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al examinar el personaje.")
            logging.exception(f"Fallo al ejecutar /examinarpersonaje para '{target_string}'")


class CmdExaminarObjeto(Command):
    """
    Comando para obtener informaci√≥n detallada sobre una instancia de objeto.
    """
    names = ["examinarobjeto", "exobj"]
    lock = "rol(ADMIN)"
    description = "Muestra informaci√≥n detallada de un objeto. Uso: /exobj [ID]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /examinarobjeto [ID del objeto]")
            return

        try:
            item_id = int(args[0])
            target_item = await session.get(Item, item_id, options=[selectinload("*")])

            if not target_item:
                await message.answer(f"No se encontr√≥ ning√∫n objeto con el ID '{item_id}'.")
                return

            lines = [
                f"<b>--- Objeto: {target_item.get_name()} ---</b>",
                f"<b>ID de Instancia:</b> {target_item.id}",
                f"<b>Clave de Prototipo:</b> {target_item.key}",
            ]
            if target_item.room:
                lines.append(f"<b>Ubicaci√≥n:</b> Sala '{target_item.room.name}' (ID: {target_item.room_id})")
            elif target_item.character:
                lines.append(f"<b>Ubicaci√≥n:</b> Inventario de '{target_item.character.name}' (ID: {target_item.character_id})")
            else:
                lines.append("<b>Ubicaci√≥n:</b> En el limbo (ninguna sala/personaje)")

            lines.append(f"<b>Nombre Overr.:</b> {target_item.name_override or 'N/A'}")
            lines.append(f"<b>Desc. Overr.:</b> {target_item.description_override or 'N/A'}")

            body = '\n'.join(lines)
            await message.answer(f"<pre>{body}</pre>", parse_mode="HTML")

        except ValueError:
            await message.answer("El ID del objeto debe ser un n√∫mero.")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al examinar el objeto.")
            logging.exception(f"Fallo al ejecutar /examinarobjeto para '{args[0]}'")

# Exportamos la lista de comandos de este m√≥dulo.
DIAGNOSTICS_COMMANDS = [
    CmdExaminarPersonaje(),
    CmdExaminarObjeto(),
]
# === FIN: commands/admin/diagnostics.py ===


# === INICIO: commands/admin/info.py ===
# commands/admin/info.py
"""
M√≥dulo de Comandos Administrativos de Informaci√≥n.

Este archivo contiene comandos dise√±ados para que los administradores puedan
consultar el estado interno del juego. Son herramientas de solo lectura
que ayudan a supervisar, depurar y obtener una visi√≥n general del mundo
sin modificarlo.

Ejemplos futuros podr√≠an incluir: /donde [jugador], /infoobjeto [id], etc.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character, Room

class CmdListarSalas(Command):
    """
    Comando que muestra una lista de todas las salas existentes en el mundo,
    incluyendo su ID, su clave de prototipo y su nombre.
    """
    names = ["listarsalas", "lsalas"]
    lock = "rol(ADMIN)"
    description = "Muestra ID, Clave y Nombre de todas las salas del mundo."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """Ejecuta la consulta y formatea la lista de salas."""
        try:
            # 1. Realizar la consulta a la base de datos para obtener todas las salas.
            # Se ordenan por ID para una visualizaci√≥n consistente.
            result = await session.execute(select(Room).order_by(Room.id))
            all_rooms = result.scalars().all()

            if not all_rooms:
                await message.answer("No se encontraron salas en la base de datos.")
                return

            # 2. Construir el mensaje de respuesta l√≠nea por l√≠nea.
            response_lines = ["<b>Lista de Salas del Mundo:</b>"]
            for room in all_rooms:
                # El formato con `<` alinea el texto a la izquierda, rellenando con espacios.
                response_lines.append(f"ID: {room.id:<4} | Key: {room.key:<20} | Nombre: {room.name}")

            body = "\n".join(response_lines)

            # 3. Envolver el cuerpo completo en una etiqueta <pre> para asegurar
            #    un formato de monoespaciado y una alineaci√≥n perfecta de las columnas.
            response_text = f"<pre>{body}</pre>"

            await message.answer(response_text, parse_mode="HTML")

        except Exception:
            # Captura cualquier error inesperado durante la consulta a la base de datos.
            await message.answer("‚ùå Ocurri√≥ un error al intentar listar las salas.")
            logging.exception("Fallo al ejecutar /listarsalas")

# Exportamos la lista de comandos de este m√≥dulo para que el dispatcher pueda importarla.
INFO_COMMANDS = [
    CmdListarSalas(),
]
# === FIN: commands/admin/info.py ===


# === INICIO: commands/admin/management.py ===
# commands/admin/management.py
"""
M√≥dulo de Comandos Administrativos para la Gesti√≥n del Juego.

Este archivo contiene comandos de alto nivel que permiten a los administradores
modificar el estado persistente de las entidades del juego, como cambiar el
rol de un jugador.

Estos comandos son generalmente restrictivos y solo accesibles para los roles
m√°s altos, como SUPERADMIN.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from commands.command import Command
from src.models import Character, Account
from src.services.permission_service import ROLE_HIERARCHY

class CmdAsignarRol(Command):
    """
    Comando de Superadmin para cambiar el rol de la cuenta de un personaje.
    """
    names = ["asignarrol"]
    lock = "rol(SUPERADMIN)"
    description = "Cambia el rol de un jugador. Uso: /asignarrol <nombre> <rol>"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if len(args) != 2:
            roles = ", ".join(ROLE_HIERARCHY.keys())
            await message.answer(f"Uso: /asignarrol <nombre_personaje> <rol>\nRoles disponibles: {roles}")
            return

        target_name, new_role = args
        new_role = new_role.upper()

        if new_role not in ROLE_HIERARCHY:
            roles = ", ".join(ROLE_HIERARCHY.keys())
            await message.answer(f"El rol '{new_role}' no es v√°lido. Roles disponibles: {roles}")
            return

        try:
            # 1. Buscar al personaje por nombre.
            query = select(Character).where(Character.name.ilike(target_name))
            result = await session.execute(query)
            target_char = result.scalar_one_or_none()

            if not target_char:
                await message.answer(f"No se encontr√≥ un personaje con el nombre '{target_name}'.")
                return

            # 2. Obtener su cuenta.
            target_account = await session.get(Account, target_char.account_id)
            if not target_account:
                # Esto no deber√≠a ocurrir si la base de datos es consistente.
                await message.answer("Error: El personaje encontrado no tiene una cuenta asociada.")
                return

            # 3. Validar jerarqu√≠a: no se puede asignar un rol igual o superior al propio.
            user_level = ROLE_HIERARCHY.get(character.account.role.upper(), 0)
            new_role_level = ROLE_HIERARCHY.get(new_role, 0)

            if new_role_level >= user_level and character.id != target_char.id:
                 await message.answer("No puedes asignar un rol igual o superior a tu propio rango.")
                 return

            # 4. Actualizar el rol y guardar en la base de datos.
            old_role = target_account.role
            target_account.role = new_role
            await session.commit()

            await message.answer(f"‚úÖ Se ha cambiado el rol de {target_char.name} de '{old_role}' a '{new_role}'.")

        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar asignar el rol.")
            logging.exception(f"Fallo al ejecutar /asignarrol para '{target_name}'")

# Exportamos la lista de comandos de este m√≥dulo.
MANAGEMENT_COMMANDS = [
    CmdAsignarRol(),
]
# === FIN: commands/admin/management.py ===


# === INICIO: commands/admin/movement.py ===
# commands/admin/movement.py
"""
M√≥dulo de Comandos Administrativos para el Movimiento.

Este archivo contiene comandos que otorgan a los administradores capacidades
de movimiento especiales, que no est√°n sujetas a las reglas normales del juego
(como las salidas definidas en una sala).

Son herramientas esenciales para la construcci√≥n, supervisi√≥n y depuraci√≥n del mundo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service # Importamos command_service para actualizar comandos
from src.utils.presenters import show_current_room

class CmdTeleport(Command):
    """
    Comando para teletransportar al administrador a cualquier sala del juego
    especificando su ID num√©rico.
    """
    names = ["teleport", "tp"]
    lock = "rol(ADMIN)"  # Solo usuarios con rol ADMIN o superior pueden usarlo.
    description = "Teletransp√≥rtate a cualquier sala usando su ID."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        # 1. Validar la entrada del usuario.
        if not args:
            await message.answer("Uso: /teleport [ID_sala]")
            return

        try:
            # Intentamos convertir el primer argumento a un n√∫mero entero.
            to_room_id = int(args[0])
        except (ValueError, IndexError):
            # Falla si no hay argumentos o si el argumento no es un n√∫mero.
            await message.answer("El ID de la sala debe ser un n√∫mero v√°lido.")
            return

        try:
            # 2. Llamar al servicio que contiene la l√≥gica de negocio.
            await player_service.teleport_character(session, character.id, to_room_id)

            # 3. Notificar al administrador del √©xito.
            await message.answer(f"üöÄ Teletransportado a la sala {to_room_id}.")

            # 4. Actualizar los comandos de Telegram, ya que la nueva sala puede otorgar sets.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            if refreshed_character:
                 await command_service.update_telegram_commands(refreshed_character)

            # 5. Mostrar la nueva ubicaci√≥n.
            await show_current_room(message)

        except Exception as e:
            # Capturamos cualquier error que pueda ocurrir durante el teletransporte,
            # como un ID de sala que no existe (manejado por `player_service`).
            await message.answer(f"‚ùå Error al teletransportar: {e}")
            logging.warning(f"Fallo al ejecutar /teleport a la sala {args[0]}: {e}")

# Exportamos la lista de comandos de este m√≥dulo.
ADMIN_MOVEMENT_COMMANDS = [
    CmdTeleport(),
]
# === FIN: commands/admin/movement.py ===


# === INICIO: commands/player/__init__.py ===
from . import general
from . import character
from . import interaction
from . import movement
from . import channels
from . import dynamic_channels
from . import settings
# === FIN: commands/player/__init__.py ===


# === INICIO: commands/player/channels.py ===
# commands/player/channels.py
"""
M√≥dulo de Comandos para la Gesti√≥n de Canales de Chat.

Este archivo contiene los comandos que permiten a los jugadores gestionar
sus suscripciones a los canales de comunicaci√≥n globales. No contiene los
comandos para hablar por los canales (esos se generan din√°micamente).

Incluye:
- /canales: Para listar todos los canales y el estado de la suscripci√≥n.
- /activarcanal: Para suscribirse a un canal.
- /desactivarcanal: Para cancelar la suscripci√≥n a un canal.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdCanales(Command):
    """
    Comando para listar todos los canales disponibles y el estado de suscripci√≥n del jugador.
    """
    names = ["canales"]
    description = "Muestra los canales disponibles y tu estado de suscripci√≥n."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # 1. Obtener la configuraci√≥n de canales del jugador.
            settings = await channel_service.get_or_create_settings(session, character)
            user_channels = settings.active_channels.get("active_channels", [])

            # 2. Construir la lista formateada para el mensaje.
            response = ["<b>Estado de tus Canales:</b>"]
            for key, proto in CHANNEL_PROTOTYPES.items():
                status = "‚úÖ Activado" if key in user_channels else "‚ùå Desactivado"
                response.append(f"- <b>{proto['name']}</b> ({key}): {status}\n  <i>{proto['description']}</i>")

            await message.answer("\n".join(response), parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al listar los canales.")
            logging.exception(f"Fallo al ejecutar /canales para {character.name}")

class CmdActivarCanal(Command):
    """
    Comando para que un jugador se suscriba (active) un canal.
    """
    names = ["activarcanal"]
    description = "Activa un canal para recibir sus mensajes. Uso: /activarcanal [nombre]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /activarcanal [nombre_del_canal]")
            return

        channel_key = args[0].lower()

        try:
            await channel_service.set_channel_status(session, character, channel_key, activate=True)
            await message.answer(f"‚úÖ Has activado el canal '{channel_key}'.")
        except ValueError as e:
            await message.answer(f"‚ùå Error: {e}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al activar el canal.")
            logging.exception(f"Fallo al ejecutar /activarcanal para {character.name}")

class CmdDesactivarCanal(Command):
    """
    Comando para que un jugador cancele la suscripci√≥n (desactive) de un canal.
    """
    names = ["desactivarcanal"]
    description = "Desactiva un canal para no recibir sus mensajes. Uso: /desactivarcanal [nombre]"

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("Uso: /desactivarcanal [nombre_del_canal]")
            return

        channel_key = args[0].lower()

        try:
            await channel_service.set_channel_status(session, character, channel_key, activate=False)
            await message.answer(f"‚úÖ Has desactivado el canal '{channel_key}'.")
        except ValueError as e:
            await message.answer(f"‚ùå Error: {e}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al desactivar el canal.")
            logging.exception(f"Fallo al ejecutar /desactivarcanal para {character.name}")

# Exportamos la lista de comandos de gesti√≥n de canales.
CHANNEL_COMMANDS = [
    CmdCanales(),
    CmdActivarCanal(),
    CmdDesactivarCanal(),
]
# === FIN: commands/player/channels.py ===


# === INICIO: commands/player/character.py ===
# commands/player/character.py
"""
M√≥dulo de Comandos para la Gesti√≥n del Personaje.

Este archivo contiene los comandos que permiten a los jugadores gestionar
el ciclo de vida de su personaje en el juego.

El comando principal aqu√≠ es `/crearpersonaje`, que es el primer comando que
un nuevo jugador debe usar para entrar al mundo de Runegram.

Futuros comandos como `/borrarpersonaje` o `/descripcion` tambi√©n pertenecer√≠an
a este m√≥dulo.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service

class CmdCreateCharacter(Command):
    """
    Comando para que un nuevo usuario cree su personaje.
    """
    names = ["crearpersonaje"]
    description = "Crea tu personaje para empezar a jugar."
    lock = ""

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        """
        Gestiona la l√≥gica de creaci√≥n de un nuevo personaje.
        """
        # 1. Comprobar si el jugador ya tiene un personaje.
        # El objeto 'character' solo es None si la cuenta no tiene un personaje asociado.
        if character:
            await message.answer("Ya tienes un personaje.")
            return

        # 2. Validar el nombre proporcionado por el usuario.
        character_name = " ".join(args)
        if not character_name or len(character_name) > 50:
            await message.answer("Por favor, proporciona un nombre v√°lido (m√°x 50 caracteres). Uso: /crearpersonaje [nombre]")
            return

        try:
            # 3. Llamar al servicio que contiene la l√≥gica de negocio para la creaci√≥n.
            new_char = await player_service.create_character(session, message.from_user.id, character_name)

            # 4. Enviar un mensaje de √©xito al jugador.
            await message.answer(
                f"¬°Tu personaje, {new_char.name}, ha sido creado con √©xito!\n"
                "Ahora est√°s listo para explorar el mundo de Runegram. ¬°Env√≠a /start para comenzar!"
            )
        except ValueError as e:
            # Captura errores de negocio espec√≠ficos lanzados por `player_service`,
            # como "El nombre ya est√° en uso".
            await message.answer(f"No se pudo crear el personaje: {e}")
        except Exception:
            # Captura cualquier otro error inesperado durante el proceso de creaci√≥n.
            # Gracias al `logging.exception`, veremos el traceback completo en los logs
            # del contenedor, lo que es vital para depurar errores sutiles de la base de datos.
            await message.answer("Ocurri√≥ un error inesperado al crear tu personaje.")
            logging.exception(f"Error finalizando la creaci√≥n del personaje para {message.from_user.id}")

# Exportamos la lista de comandos de este m√≥dulo.
CHARACTER_COMMANDS = [
    CmdCreateCharacter(),
]
# === FIN: commands/player/character.py ===


# === INICIO: commands/player/dynamic_channels.py ===
# commands/player/dynamic_channels.py
"""
M√≥dulo para la Generaci√≥n Din√°mica de Comandos de Canal.

Este archivo contiene la l√≥gica para crear autom√°ticamente los comandos de chat
(ej: /novato, /sistema) a partir de las definiciones en
`game_data/channel_prototypes.py`.

Esto sigue la filosof√≠a "Data-Driven" del motor: para a√±adir un nuevo canal
de chat al juego, un dise√±ador solo necesita a√±adir una entrada al archivo
de prototipos (con `type: "CHAT"`), y este m√≥dulo se encargar√° de crear el
comando correspondiente, aplicando los permisos definidos en el `lock`.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character
from src.services import channel_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

class CmdDynamicChannel(Command):
    """
    Clase de comando gen√©rica para enviar un mensaje a un canal de chat.
    La instancia de esta clase sabe a qu√© canal pertenece por su nombre.
    """
    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # El nombre principal del comando (ej: "novato") es la clave del canal.
            channel_key = self.names[0]

            if not args:
                await message.answer(f"Uso: /{channel_key} [mensaje]")
                return

            proto = CHANNEL_PROTOTYPES.get(channel_key)
            if not proto:
                # Salvaguarda en caso de inconsistencia entre el comando y los prototipos.
                await message.answer("Error: El canal para este comando ya no existe.")
                return

            # 1. Verificar si el jugador tiene el canal activado para recibir mensajes.
            settings = await channel_service.get_or_create_settings(session, character)
            if not await channel_service.is_channel_active(settings, channel_key):
                await message.answer(f"Tienes el canal '{channel_key}' desactivado. Act√≠valo con:\n/activarcanal {channel_key}")
                return

            # 2. Formatear y transmitir el mensaje a trav√©s del servicio.
            text = " ".join(args)
            channel_message = f"[{character.name}] {text}"
            await channel_service.broadcast_to_channel(session, channel_key, channel_message, exclude_character_id=character.id)

            # 3. Enviar una confirmaci√≥n al propio jugador para que vea su mensaje.
            await message.answer(f"{proto['icon']} <b>{proto['name']}:</b> {channel_message}", parse_mode="HTML")

        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al enviar tu mensaje al canal.")
            logging.exception(f"Fallo al ejecutar un comando de canal din√°mico para {character.name}")

def generate_channel_commands() -> list[Command]:
    """
    Funci√≥n "f√°brica" que lee los prototipos de canal y genera una lista
    de instancias de `CmdDynamicChannel` para cada canal de tipo 'CHAT'.
    Asigna din√°micamente los permisos (locks) definidos en el prototipo.
    """
    commands = []
    for key, proto in CHANNEL_PROTOTYPES.items():
        # Solo se crean comandos para los canales que est√°n expl√≠citamente marcados como CHAT.
        if proto.get("type") == "CHAT":
            instance = CmdDynamicChannel(
                names=[key],
                description=f"Env√≠a un mensaje por el canal {proto['name']}."
            )
            # Asignamos el lock del prototipo al atributo de la instancia del comando.
            # Si el prototipo no tiene un lock, se asigna una cadena vac√≠a (sin restricciones).
            instance.lock = proto.get("lock", "")
            commands.append(instance)
    return commands

# Exportamos la lista de comandos generados din√°micamente.
# El dispatcher importar√° esta lista.
DYNAMIC_CHANNEL_COMMANDS = generate_channel_commands()
# === FIN: commands/player/dynamic_channels.py ===


# === INICIO: commands/player/general.py ===
# commands/player/general.py
"""
M√≥dulo de Comandos Generales del Jugador.

Este archivo agrupa los comandos m√°s b√°sicos y fundamentales que un jugador
utiliza para interactuar con el mundo y obtener informaci√≥n esencial sobre su
entorno y su personaje.

Estos comandos est√°n disponibles para todos los jugadores en todo momento.
"""

import logging
from aiogram import types
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.utils.presenters import show_current_room
from src.services import script_service, online_service

class CmdLook(Command):
    """
    Comando para observar el entorno actual (la sala) o un objeto o
    personaje espec√≠fico dentro de ella.
    """
    names = ["mirar", "m", "l"]
    lock = ""
    description = "Observa tu entorno o un objeto/personaje espec√≠fico."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            # Si no se proporcionan argumentos, el jugador mira la sala.
            if not args:
                await show_current_room(message)
                return

            target_name = " ".join(args).lower()
            found_target = None

            # 1. Buscar en los objetos de la sala.
            if character.room.items:
                for item in character.room.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # 2. Si no se encontr√≥, buscar en el inventario del personaje.
            if not found_target and character.items:
                for item in character.items:
                    if target_name in item.get_keywords() or target_name in item.get_name().lower():
                        found_target = item
                        break

            # Futuro: 3. Buscar otros personajes en la sala.
            # Futuro: 4. Buscar NPCs en la sala.

            if not found_target:
                await message.answer("No ves eso por aqu√≠.")
                return

            # Mostramos la descripci√≥n del objeto encontrado.
            await message.answer(f"<pre>{found_target.get_description()}</pre>", parse_mode="HTML")

            # Finalmente, disparamos el evento on_look si el objeto tiene un script asociado.
            if "on_look" in found_target.prototype.get("scripts", {}):
                await script_service.execute_script(
                    script_string=found_target.prototype["scripts"]["on_look"],
                    session=session,
                    character=character,
                    target=found_target
                )
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar mirar.")
            logging.exception(f"Fallo al ejecutar /mirar para {character.name}")

class CmdSay(Command):
    """
    Comando para que el personaje hable a otros en la misma sala.
    """
    names = ["decir", "'"]
    lock = ""
    description = "Habla con las personas que est√°n en tu misma sala."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        if not args:
            await message.answer("¬øQu√© quieres decir?")
            return

        # Futuro: Este mensaje deber√≠a ser transmitido a otros jugadores en la sala.
        say_text = " ".join(args)
        await message.answer(f"Dices: {say_text}")

class CmdInventory(Command):
    """
    Comando para mostrar al jugador los objetos que lleva en su inventario.
    """
    names = ["inventario", "inv", "i"]
    lock = ""
    description = "Muestra los objetos que llevas en tu inventario."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            inventory = character.items
            if not inventory:
                response = "No llevas nada."
            else:
                items_list = [f" - {item.get_name()}" for item in inventory]
                items_str = "\n".join(items_list)
                response = f"<b>Llevas lo siguiente:</b>\n{items_str}"

            await message.answer(f"<pre>{response}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al mostrar tu inventario.")
            logging.exception(f"Fallo al ejecutar /inventario para {character.name}")

class CmdHelp(Command):
    """
    Comando para mostrar un mensaje de ayuda b√°sico con los comandos principales.
    """
    names = ["ayuda", "help"]
    lock = ""
    description = "Muestra una lista con los comandos b√°sicos del juego."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        help_text = (
            "<b>Comandos B√°sicos de Runegram</b>\n"
            "---------------------------------\n"
            "/mirar - Muestra la descripci√≥n de tu entorno.\n"
            "/inventario - Muestra los objetos que llevas.\n"
            "/decir [mensaje] - Hablas a la gente en tu misma sala.\n"
            "/coger [objeto] - Recoges un objeto del suelo.\n"
            "/dejar [objeto] - Dejas un objeto que llevas.\n"
            "/quien - Muestra qui√©n est√° conectado.\n"
            "/canales - Gestiona tus suscripciones a canales.\n\n"
            "Para moverte, usa /norte, /sur, etc."
        )
        await message.answer(f"<pre>{help_text}</pre>", parse_mode="HTML")

class CmdWho(Command):
    """
    Comando social que muestra una lista de todos los personajes que
    est√°n actualmente conectados al juego.
    """
    names = ["quien", "who"]
    lock = ""
    description = "Muestra una lista de los jugadores conectados."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            online_characters = await online_service.get_online_characters(session)

            # Si la lista est√° vac√≠a o solo contiene al jugador actual, se muestra
            # un mensaje indicando que est√° solo.
            if not online_characters or (len(online_characters) == 1 and online_characters[0].id == character.id):
                await message.answer("Eres la √∫nica alma aventurera en este mundo ahora mismo.")
                return

            response_lines = [f"<b>Hay {len(online_characters)} aventureros en Runegram:</b>"]
            # Ordenamos la lista alfab√©ticamente por nombre para una visualizaci√≥n clara.
            for char in sorted(online_characters, key=lambda c: c.name):
                response_lines.append(f"- {char.name}")

            response_text = "\n".join(response_lines)
            await message.answer(f"<pre>{response_text}</pre>", parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al obtener la lista de jugadores.")
            logging.exception(f"Fallo al ejecutar /quien para {character.name}")

# Exportamos la lista de comandos de este m√≥dulo.
GENERAL_COMMANDS = [
    CmdLook(),
    CmdSay(),
    CmdInventory(),
    CmdHelp(),
    CmdWho(),
]
# === FIN: commands/player/general.py ===


# === INICIO: commands/player/interaction.py ===
# commands/player/interaction.py
"""
M√≥dulo de Comandos de Interacci√≥n con Objetos.

Este archivo contiene los comandos que permiten al jugador manipular directamente
los objetos (`Items`) en el mundo del juego.

Incluye acciones fundamentales como coger objetos del entorno y dejar
objetos del inventario.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import item_service, command_service, player_service, permission_service


class CmdGet(Command):
    """
    Comando para que un jugador recoja un objeto del suelo en su sala actual
    y lo a√±ada a su inventario.
    """
    names = ["coger", "g"]
    lock = ""
    description = "Recoge un objeto del suelo."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            if not args:
                await message.answer("¬øQu√© quieres coger?")
                return

            item_name_to_get = " ".join(args).lower()
            item_to_get = None

            for item in character.room.items:
                if item_name_to_get in item.get_name().lower():
                    item_to_get = item
                    break

            if not item_to_get:
                await message.answer("No ves eso por aqu√≠.")
                return

            # Comprobamos si el prototipo del objeto tiene una definici√≥n de lock.
            lock_string = item_to_get.prototype.get("locks", "")
            can_pass, error_message = await permission_service.can_execute(character, lock_string)
            if not can_pass:
                # Si el objeto est√° bloqueado, mostramos un mensaje y detenemos la acci√≥n.
                # Futuro: El mensaje de error podr√≠a venir del prototipo del objeto.
                await message.answer(error_message or "No puedes coger eso.")
                return

            # Llamamos al servicio para actualizar la ubicaci√≥n del objeto en la BD.
            await item_service.move_item_to_character(session, item_to_get.id, character.id)

            # Si el objeto que cogimos otorga un CommandSet, actualizamos la lista en Telegram.
            if item_to_get.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has cogido: {item_to_get.get_name()}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar coger el objeto.")
            logging.exception(f"Fallo al ejecutar /coger para {character.name}")


class CmdDrop(Command):
    """
    Comando para que un jugador deje un objeto de su inventario en el suelo
    de su sala actual.
    """
    names = ["dejar", "d"]
    lock = ""
    description = "Deja un objeto de tu inventario en el suelo."

    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            if not args:
                await message.answer("¬øQu√© quieres dejar?")
                return

            item_name_to_drop = " ".join(args).lower()
            item_to_drop = None

            for item in character.items:
                if item_name_to_drop in item.get_name().lower():
                    item_to_drop = item
                    break

            if not item_to_drop:
                await message.answer("No llevas eso.")
                return

            # Futuro: Aqu√≠ se podr√≠a a√±adir un chequeo de lock para "dejar" objetos.
            # Por ejemplo, un objeto maldito que no se puede soltar.

            await item_service.move_item_to_room(session, item_to_drop.id, character.room_id)

            # Si el objeto que dejamos otorgaba un CommandSet, actualizamos la lista en Telegram.
            if item_to_drop.prototype.get("grants_command_sets"):
                refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
                await command_service.update_telegram_commands(refreshed_character)

            await message.answer(f"Has dejado: {item_to_drop.get_name()}")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar dejar el objeto.")
            logging.exception(f"Fallo al ejecutar /dejar para {character.name}")


# Exportamos la lista de comandos de este m√≥dulo.
INTERACTION_COMMANDS = [
    CmdGet(),
    CmdDrop(),
]
# === FIN: commands/player/interaction.py ===


# === INICIO: commands/player/movement.py ===
# commands/player/movement.py
"""
M√≥dulo de Comandos de Movimiento del Jugador.

Este archivo centraliza toda la l√≥gica relacionada con el desplazamiento del
personaje por el mundo del juego.

Utiliza una √∫nica clase gen√©rica, `CmdMove`, que se instancia para cada una de
las direcciones posibles (norte, sur, etc.), cada una con sus propios alias.
Esto evita la duplicaci√≥n de c√≥digo y mantiene la l√≥gica de movimiento en un
solo lugar.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models.character import Character
from src.services import player_service, command_service, permission_service
from src.utils.presenters import show_current_room

class CmdMove(Command):
    """
    Comando gen√©rico que gestiona el movimiento del jugador en una direcci√≥n.
    La direcci√≥n espec√≠fica se determina por el nombre principal del comando
    (el primer elemento en la lista `names`).
    """
    async def execute(
        self,
        character: Character,
        session: AsyncSession,
        message: types.Message,
        args: list[str]
    ):
        try:
            # 1. Determinar la direcci√≥n bas√°ndose en el comando invocado.
            direction = self.names[0]

            # 2. Buscar si existe una salida v√°lida en esa direcci√≥n.
            target_exit = next(
                (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == direction),
                None
            )

            if not target_exit:
                await message.answer("No puedes ir en esa direcci√≥n.")
                return

            # 3. Comprobar permisos (Locks).
            #    Llamamos al permission_service para evaluar el lock_string de la salida.
            can_pass, error_message = await permission_service.can_execute(character, target_exit.locks)
            if not can_pass:
                # Si `can_execute` devuelve un mensaje personalizado, lo usamos.
                # Si no, usamos un mensaje gen√©rico.
                await message.answer(error_message or "Esa salida est√° bloqueada.")
                return

            # 4. Mover al personaje a la nueva sala.
            await player_service.teleport_character(session, character.id, target_exit.to_room_id)

            # 5. Actualizar la lista de comandos del jugador en Telegram.
            refreshed_character = await player_service.get_character_with_relations_by_id(session, character.id)
            if refreshed_character:
                await command_service.update_telegram_commands(refreshed_character)

            # 6. Mostrar al jugador la descripci√≥n de su nueva ubicaci√≥n.
            await show_current_room(message)

        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al intentar moverte.")
            logging.exception(f"Fallo al ejecutar /mover ({self.names[0]}) para {character.name}")

# --- Creaci√≥n del Command Set con descripciones ---
# Se crea una instancia de `CmdMove` para cada direcci√≥n, asignando sus alias
# y una descripci√≥n clara para la lista de comandos de Telegram.
MOVEMENT_COMMANDS = [
    CmdMove(names=["norte", "n"], description="Moverse hacia el norte."),
    CmdMove(names=["sur", "s"], description="Moverse hacia el sur."),
    CmdMove(names=["este", "e"], description="Moverse hacia el este."),
    CmdMove(names=["oeste", "o"], description="Moverse hacia el oeste."),
    CmdMove(names=["arriba", "ar"], description="Moverse hacia arriba."),
    CmdMove(names=["abajo", "ab"], description="Moverse hacia abajo."),
    CmdMove(names=["noreste", "ne"], description="Moverse hacia el noreste."),
    CmdMove(names=["noroeste", "no"], description="Moverse hacia el noroeste."),
    CmdMove(names=["sureste", "se"], description="Moverse hacia el sureste."),
    CmdMove(names=["suroeste", "so"], description="Moverse hacia el suroeste."),
]
# === FIN: commands/player/movement.py ===


# === INICIO: commands/player/settings.py ===
# commands/player/settings.py
"""
M√≥dulo de Comandos para la Configuraci√≥n del Personaje.

Este archivo contiene los comandos que permiten a los jugadores personalizar
su experiencia de juego, como ajustar las notificaciones, los colores (en el
futuro), u otras preferencias.

Actualmente, sirve como punto de entrada para la gesti√≥n de canales, pero
est√° dise√±ado para albergar m√°s comandos de configuraci√≥n a medida que el
juego crezca.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from commands.command import Command
from src.models import Character

class CmdConfig(Command):
    """
    Comando principal para que un jugador acceda a las opciones de configuraci√≥n.
    Actualmente, muestra una ayuda contextual sobre c√≥mo gestionar los canales.
    """
    names = ["config", "opciones"]
    description = "Muestra las opciones de configuraci√≥n disponibles."

    async def execute(self, character: Character, session: AsyncSession, message: types.Message, args: list[str]):
        try:
            help_text = (
                "<b>Configuraci√≥n de Runegram</b>\n"
                "---------------------------------\n"
                "Aqu√≠ podr√°s ajustar tus preferencias de juego.\n\n"
                "<b>Gesti√≥n de Canales:</b>\n"
                " - Usa <code>/canales</code> para ver una lista de todos los canales y su estado.\n"
                " - Usa <code>/activarcanal [nombre]</code> para suscribirte a un canal.\n"
                " - Usa <code>/desactivarcanal [nombre]</code> para cancelar tu suscripci√≥n."
            )
            await message.answer(help_text, parse_mode="HTML")
        except Exception:
            await message.answer("‚ùå Ocurri√≥ un error al mostrar las opciones de configuraci√≥n.")
            logging.exception(f"Fallo al ejecutar /config para {character.name}")

# Exportamos la lista de comandos de este m√≥dulo.
SETTINGS_COMMANDS = [
    CmdConfig(),
]
# === FIN: commands/player/settings.py ===


# === INICIO: game_data/__init__.py ===
# === FIN: game_data/__init__.py ===


# === INICIO: game_data/channel_prototypes.py ===
# game_data/channel_prototypes.py
"""
Definici√≥n de Prototipos de Canales de Chat.

Este archivo act√∫a como la "Fuente de la Verdad" para todos los canales de
comunicaci√≥n globales disponibles en el juego. El `channel_service` utiliza
esta informaci√≥n para gestionar las suscripciones y formatear los mensajes.

A√±adir un nuevo canal al juego es tan simple como a√±adir una nueva entrada
a este diccionario.

Estructura de un Prototipo de Canal:
- <clave_unica>: (ej: "novato")
    - "name": (str) El nombre del canal que ven los jugadores.
    - "icon": (str) Un icono emoji que precede a los mensajes del canal.
    - "description": (str) Una breve explicaci√≥n que se muestra en el comando /canales.
    - "type": (str) Define si se debe generar un comando para hablar en el canal.
        - "CHAT": Se generar√° un comando din√°mico (ej: /novato) para que los jugadores hablen.
    - "default_on": (bool) Si es `True`, los nuevos personajes se suscriben
                    autom√°ticamente a este canal al ser creados.
    - "lock": (str, opcional) Un lock string que se aplica al comando de chat generado.
             Permite restringir qui√©n puede hablar en el canal.
"""

CHANNEL_PROTOTYPES = {
    # Canal para que los nuevos jugadores puedan hacer preguntas.
    "novato": {
        "name": "Novato",
        "icon": "üì¢",
        "description": "Un canal para que los nuevos aventureros pidan ayuda.",
        "type": "CHAT",
        "default_on": True,
        "lock": "", # Sin lock, cualquiera puede hablar.
    },

    # Canal para notificaciones autom√°ticas del juego y comunicaci√≥n de administradores.
    "sistema": {
        "name": "Sistema",
        "icon": "‚öôÔ∏è",
        "description": "Anuncios del juego y notificaciones autom√°ticas.",
        "type": "CHAT", # Es de tipo CHAT para que se genere el comando /sistema.
        "default_on": True,
        # Se a√±ade un lock para que solo los ADMINS o superior puedan hablar en √©l.
        "lock": "rol(ADMIN)"
    },

    # --- Futuros canales podr√≠an ir aqu√≠ ---
    # "comercio": {
    #     "name": "Comercio",
    #     "icon": "üí∞",
    #     "description": "Para comprar y vender objetos con otros jugadores.",
    #     "type": "CHAT",
    #     "default_on": True,
    #     "lock": "",
    # },
}
# === FIN: game_data/channel_prototypes.py ===


# === INICIO: game_data/item_prototypes.py ===
# game_data/item_prototypes.py
"""
Definici√≥n de Prototipos de Objetos (Items).

Este archivo es el cat√°logo central de todos los objetos que pueden existir
en el mundo de Runegram. Sigue un sistema de prototipos, lo que significa que
este archivo define las "plantillas" o "planos" de los objetos, mientras que
la base de datos solo almacena las "instancias" individuales de esos objetos
(su ubicaci√≥n, si tienen un nombre personalizado, etc.).

Esta separaci√≥n es clave para la filosof√≠a de dise√±o del motor, permitiendo
a√±adir cientos de objetos nuevos sin modificar el c√≥digo fuente ni la
estructura de la base de datos.

Estructura de un Prototipo de Objeto:
- <clave_unica>: (ej: "espada_viviente")
    - "name": (str) El nombre que ven los jugadores (ej: "una espada viviente").
    - "keywords": (list[str]) Palabras clave para que los jugadores puedan interactuar
                    con el objeto (ej: /mirar espada).
    - "description": (str) El texto que se muestra al mirar el objeto.
    - "scripts": (dict, opcional) Define scripts reactivos a eventos.
        - "on_look": (str) El script a ejecutar cuando un jugador mira el objeto.
    - "tickers": (list[dict], opcional) Define scripts proactivos que se ejecutan
                 peri√≥dicamente.
        - "schedule": (str) El horario (cron o intervalo).
        - "script": (str) El script a ejecutar.
        - "category": (str) La categor√≠a del ticker (ej: "ambient").
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que este
                             objeto otorga al personaje que lo posea.
"""

ITEM_PROTOTYPES = {
    # Un objeto m√°gico que susurra secretos peri√≥dicamente.
    "espada_viviente": {
        "name": "una espada viviente",
        "description": "La hoja de acero parece retorcerse y susurrarte secretos.",
        "keywords": ["espada", "viviente"],
        "scripts": {
            # Cuando se mira, emite un brillo rojo.
            "on_look": "script_notificar_brillo_magico(color=rojo)"
        },
        "tickers": [
            {
                # Cada 2 minutos, ejecuta el script de susurrar.
                "schedule": "*/2 * * * *",
                "script": "script_espada_susurra_secreto",
                # Se categoriza como "ambient" para no molestar a jugadores inactivos.
                "category": "ambient"
            }
        ]
    },

    # Un objeto decorativo con un ticker de intervalo.
    "corazon_sangrante": {
        "name": "un coraz√≥n sangrante",
        "description": "Late d√©bilmente y gotea un icor oscuro.",
        "keywords": ["corazon", "sangrante"],
        "tickers": [
            {
                # Cada 30 segundos, ejecuta un script (a√∫n por definir).
                "schedule": "interval:30",
                "script": "script_objeto_sangra_en_el_suelo",
                "category": "ambient"
            }
        ]
    },

    # --- Futuros objetos podr√≠an ir aqu√≠ ---
    # "ganzuas_maestras": {
    #     "name": "unas ganz√∫as maestras",
    #     "keywords": ["ganzuas", "herramientas"],
    #     "description": "Unas herramientas de precisi√≥n para el ladr√≥n experto.",
    #     # Este objeto otorga acceso al CommandSet "thievery" mientras se posea.
    #     "grants_command_sets": ["thievery"]
    # },
}
# === FIN: game_data/item_prototypes.py ===


# === INICIO: game_data/room_prototypes.py ===
# game_data/room_prototypes.py
"""
Definici√≥n de Prototipos de Salas (Rooms).

Este archivo es el "mapa maestro" del mundo de Runegram. Define todas las
salas est√°ticas, sus descripciones y, lo m√°s importante, c√≥mo se conectan
entre s√≠.

El `world_loader_service` lee este archivo al arrancar el bot para construir
o sincronizar el mundo en la base de datos.

Estructura de un Prototipo de Sala:
- <clave_unica>: (ej: "plaza_central") Un identificador √∫nico para la sala que
                 nunca debe cambiar. Se usa para las conexiones.
    - "name": (str) El nombre de la sala que ven los jugadores.
    - "description": (str) El texto principal que se muestra al entrar o mirar la sala.
    - "exits": (dict, opcional) Define las salidas desde esta sala.
        - "<direccion>": (str) La clave √∫nica de la sala de destino.
          (ej: "norte": "camino_del_bosque"). El `world_loader_service` se
          encarga de crear autom√°ticamente la salida de vuelta (sur).
    - "grants_command_sets": (list[str], opcional) Lista de CommandSets que esta
                             sala otorga a cualquier personaje que se encuentre en ella.
"""

ROOM_PROTOTYPES = {
    # La sala de inicio, donde aparecen todos los nuevos personajes.
    "limbo": {
        "name": "El Limbo",
        "description": "Te encuentras en una habitaci√≥n vac√≠a, suspendida en la nada. Es el comienzo de tu aventura y un refugio seguro.",
        "exits": {
            # "direcci√≥n": "clave_de_la_sala_destino"
            "norte": "plaza_central"
        }
    },

    # Un nexo central desde el que parten varios caminos.
    "plaza_central": {
        "name": "Plaza Central de Runegard",
        "description": "Est√°s en el coraz√≥n de la ciudad. El bullicio de mercaderes y aventureros llena el aire. Varios caminos parten desde aqu√≠.",
        "exits": {
            # El cargador crear√° autom√°ticamente la salida 'sur' de vuelta al 'limbo'.
            "este": "calle_mercaderes"
        }
    },

    # Una sala tem√°tica.
    "calle_mercaderes": {
        "name": "Calle de los Mercaderes",
        "description": "Decenas de puestos se alinean en esta calle, ofreciendo todo tipo de mercanc√≠as ex√≥ticas.",
        "exits": {
            # El cargador crear√° autom√°ticamente la salida 'oeste' de vuelta a 'plaza_central'.
        }
    },

    # --- Futuras salas podr√≠an ir aqu√≠ ---
    # "forja_del_enano": {
    #     "name": "La Forja del Enano Errante",
    #     "description": "El calor del fuego y el r√≠tmico martilleo sobre el yunque llenan esta sala.",
    #     "exits": {
    #         "sur": "plaza_central"
    #     },
    #     # Cualquier jugador en esta sala obtiene acceso a los comandos de herrer√≠a.
    #     "grants_command_sets": ["smithing"]
    # }
}
# === FIN: game_data/room_prototypes.py ===


# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
REM ##################################################################
REM #                                                                #
REM #           SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM              #
REM #                                                                #
REM #  Este script automatiza el proceso de limpiar por completo el  #
REM #  entorno de desarrollo de Docker y reconstruirlo desde cero.   #
REM #                                                                #
REM #  Es la herramienta principal para asegurar un estado limpio    #
REM #  despu√©s de cambios en dependencias, migraciones o si algo     #
REM #  se ha corrompido.                                             #
REM #                                                                #
REM ##################################################################

TITLE Reinicio Completo de Runegram

CLS
ECHO.
ECHO  ##################################################################
ECHO  #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO  ##################################################################
ECHO.
ECHO  ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES DE FORMA DESTRUCTIVA:
ECHO.
ECHO    1. Detendra todos los contenedores de la aplicacion.
ECHO    2. Eliminara los contenedores detenidos.
ECHO    3. [!] Eliminara el VOLUMEN de la base de datos, borrando TODOS los datos.
ECHO    4. Reconstruira la imagen Docker de la aplicacion desde cero.
ECHO    5. Levantara todos los servicios en segundo plano.
ECHO.
ECHO  Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.
ECHO  Presiona cualquier tecla para continuar o cierra esta ventana para cancelar.
PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen de datos... ---
ECHO.
REM `docker-compose down` detiene y elimina los contenedores.
REM La bandera `-v` (o `--volumes`) es crucial, ya que elimina los vol√∫menes
REM nombrados asociados, como `postgres_data`, asegurando un borrado total.
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo la imagen y levantando servicios... ---
ECHO.
REM `docker-compose up` levanta los servicios.
REM La bandera `--build` fuerza la reconstrucci√≥n de la imagen 'bot' desde el Dockerfile.
REM La bandera `-d` (o `--detach`) ejecuta los contenedores en segundo plano.
docker-compose up --build -d

ECHO.
ECHO  ##################################################################
ECHO  #                ¬°PROCESO COMPLETADO CON EXITO!                  #
ECHO  #----------------------------------------------------------------#
ECHO  #  Los contenedores estan corriendo en segundo plano.            #
ECHO  #  Puedes ver los logs con: docker-compose logs -f bot            #
ECHO  ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/generate_snapshot.py ===
# scripts/generate_snapshot.py

import os
from pathlib import Path

# --- CONFIGURACI√ìN ---

# Directorio ra√≠z del proyecto (sube dos niveles desde este script)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# Nombre del archivo de salida
OUTPUT_FILENAME = "project_snapshot.txt"

# --- LISTA NEGRA: Directorios y archivos a IGNORAR SIEMPRE ---
# Usamos sets para una b√∫squeda m√°s eficiente.
EXCLUDED_DIRS = {
    ".git",
    ".idea",
    ".vscode",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    "postgres_data",
    "node_modules",
}

EXCLUDED_FILES = {
    ".env",
    OUTPUT_FILENAME,
    "poetry.lock",
    "Pipfile.lock",
}

# Extensiones de archivo a ignorar (ej: binarios, compilados)
EXCLUDED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".egg-info",
    ".swp",
    ".db",
    ".sqlite3",
}

# --- FIN DE LA CONFIGURACI√ìN ---


def write_file_content(output_file, file_path):
    """Escribe el contenido de un archivo en el archivo de salida, con un encabezado."""
    # Obtenemos la ruta relativa usando el est√°ndar POSIX (barras /)
    relative_path = file_path.relative_to(PROJECT_ROOT).as_posix()
    print(f"  -> A√±adiendo: {relative_path}")

    header = f"# === INICIO: {relative_path} ===\n"
    footer = f"# === FIN: {relative_path} ===\n\n\n"

    output_file.write(header)
    try:
        # Leemos el contenido del archivo
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            # A√±adimos un salto de l√≠nea al final si no lo tiene, para un formato limpio
            if content and not content.endswith('\n'):
                content += '\n'
            output_file.write(content)
    except Exception as e:
        output_file.write(f"*** No se pudo leer el archivo: {e} ***\n")
    output_file.write(footer)


def main():
    """Funci√≥n principal para generar el snapshot del proyecto."""
    output_path = PROJECT_ROOT / OUTPUT_FILENAME
    print(f"Generando snapshot del proyecto en: {output_path}\n")

    # Usaremos una lista para almacenar las rutas de los archivos a incluir
    files_to_process = []

    # os.walk recorre todos los directorios y archivos desde la ra√≠z del proyecto
    for root, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        # Modificamos la lista de directorios 'in-place' para evitar que os.walk entre en ellos
        dirs[:] = [d for d in sorted(dirs) if d not in EXCLUDED_DIRS]

        # Procesamos los archivos del directorio actual
        for filename in sorted(files):
            # Comprobamos si el archivo o su extensi√≥n est√°n en la lista negra
            if filename in EXCLUDED_FILES:
                continue

            file_path = Path(root) / filename
            if file_path.suffix in EXCLUDED_EXTENSIONS:
                continue

            # Si el archivo pasa todos los filtros, lo a√±adimos a la lista
            files_to_process.append(file_path)

    # Escribimos todos los archivos encontrados en el archivo de salida
    with open(output_path, 'w', encoding='utf-8') as output_file:
        for file_path in files_to_process:
            write_file_content(output_file, file_path)

    print(f"\n¬°Snapshot generado con √©xito! {len(files_to_process)} archivos procesados.")


if __name__ == "__main__":
    main()
# === FIN: scripts/generate_snapshot.py ===


# === INICIO: scripts/run_migrations.sh ===
# === FIN: scripts/run_migrations.sh ===


# === INICIO: src/__init__.py ===
# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===
# src/config.py
"""
M√≥dulo de Configuraci√≥n Centralizado.

Este archivo define la clase `Settings` que utiliza Pydantic para cargar, validar
y gestionar todas las variables de entorno necesarias para la aplicaci√≥n.

Pydantic se encarga de:
1. Leer las variables desde un archivo `.env`.
2. Validar que las variables existan y tengan el tipo de dato correcto (ej: int, str).
3. Proveer un objeto `settings` √∫nico y fuertemente tipado que puede ser importado
   y utilizado en cualquier parte del proyecto.

Esto evita la dispersi√≥n de `os.getenv()` por el c√≥digo y asegura que la aplicaci√≥n
no arranque si falta una configuraci√≥n cr√≠tica.
"""

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    """
    Define y carga todas las variables de entorno de la aplicaci√≥n.
    """
    # Telegram
    bot_token: SecretStr

    # El ID de Telegram del usuario que tendr√° el rol de Superadmin.
    # Este rol tiene todos los permisos y se asigna al arrancar la aplicaci√≥n.
    superadmin_telegram_id: int

    # Database (PostgreSQL)
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Cache y Estados (Redis)
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        """
        Genera la URL de conexi√≥n a la base de datos para el motor AS√çNCRONO.
        Utiliza el driver 'asyncpg', que es el principal para la aplicaci√≥n.
        """
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @property
    def sync_database_url(self) -> str:
        """
        Genera la URL de conexi√≥n a la base de datos para operaciones S√çNCRONAS.
        Utiliza el driver 'psycopg2'. Su uso principal es para componentes que no
        son compatibles con asyncio, como el `SQLAlchemyJobStore` de APScheduler.
        """
        return (
            f"postgresql+psycopg2://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        """
        Configuraci√≥n interna de Pydantic para indicarle c√≥mo cargar las variables.
        """
        # Nombre del archivo del que se leer√°n las variables de entorno.
        env_file = '.env'
        # Codificaci√≥n del archivo .env.
        env_file_encoding = 'utf-8'

# Creamos una instancia √∫nica de la configuraci√≥n que ser√° importada
# por el resto de la aplicaci√≥n.
settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
"""
M√≥dulo de Configuraci√≥n de la Base de Datos.

Este archivo es el responsable de crear y configurar la conexi√≥n a la base de
datos para toda la aplicaci√≥n utilizando SQLAlchemy en modo as√≠ncrono.

Componentes Clave:
1. `async_engine`: Una instancia √∫nica del motor de base de datos que gestiona
   las conexiones a bajo nivel. Se crea una sola vez cuando se inicia la app.
2. `async_session_factory`: Una "f√°brica" que produce objetos de sesi√≥n de
   SQLAlchemy (`AsyncSession`). Cada vez que se necesita interactuar con la
   base de datos (ej: dentro de un manejador de comandos), se solicita una nueva
   sesi√≥n a esta f√°brica.
"""

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Se crea una √∫nica instancia del motor as√≠ncrono para toda la aplicaci√≥n.
# Este objeto gestiona un pool de conexiones a la base de datos.
async_engine = create_async_engine(
    settings.database_url,

    # `echo=True` mostrar√≠a todas las sentencias SQL que se ejecutan en la consola.
    # Es muy √∫til para depurar, pero debe estar en `False` en producci√≥n.
    echo=False,
)

# Se crea una f√°brica de sesiones. Esta f√°brica se usar√° en toda la aplicaci√≥n
# para obtener una nueva sesi√≥n de corta duraci√≥n cada vez que se necesite
# realizar una operaci√≥n en la base de datos.
async_session_factory = async_sessionmaker(
    bind=async_engine,

    # `expire_on_commit=False` es crucial en aplicaciones as√≠ncronas.
    # Evita que SQLAlchemy invalide los objetos (ej: un 'Character') despu√©s de un
    # `session.commit()`. Sin esto, acceder a un atributo de un objeto despu√©s
    # de un commit podr√≠a lanzar un error al intentar recargarlo desde una
    # sesi√≥n ya cerrada.
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===
# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
# src/bot/bot.py
"""
M√≥dulo para la Instanciaci√≥n del Objeto Bot de Aiogram.

Este archivo tiene una √∫nica y simple responsabilidad: crear una instancia
global del objeto `Bot` de Aiogram.

Centralizar la creaci√≥n de esta instancia aqu√≠ permite que cualquier otro
m√≥dulo en la aplicaci√≥n (como los servicios) pueda importarla para interactuar
directamente con la API de Telegram (por ejemplo, para enviar mensajes
proactivos fuera del flujo normal de un comando).
"""

from aiogram import Bot

from src.config import settings

# Se crea una instancia √∫nica del Bot para toda la aplicaci√≥n.
# El token se lee de forma segura desde el objeto de configuraci√≥n `settings`,
# que a su vez lo carga desde las variables de entorno.
# `settings.bot_token.get_secret_value()` es la forma correcta de acceder
# al valor de un `SecretStr` de Pydantic.
bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py
"""
M√≥dulo para la Instanciaci√≥n del Dispatcher de Aiogram.

Este archivo crea y configura la instancia global del `Dispatcher`, que es el
componente central de Aiogram para el procesamiento de actualizaciones (mensajes,
callbacks, etc.).

Responsabilidades:
1.  **Enrutamiento:** El `Dispatcher` (`dp`) es el objeto al que se registran
    todos los manejadores de mensajes (handlers). Se encarga de decidir qu√©
    funci√≥n debe procesar cada mensaje entrante.
2.  **Gesti√≥n de Estados (FSM):** Configura el almacenamiento de estados finitos
    (Finite State Machine), que permite crear conversaciones de varios pasos
    (ej: creaci√≥n de personaje, men√∫s interactivos).
"""

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# 1. Configuraci√≥n del Almacenamiento de Estados (FSM - Finite State Machine)
# Se utiliza Redis (`RedisStorage2`) como backend para almacenar el estado de
# la conversaci√≥n de cada usuario. Esto es esencial para funcionalidades
# de varios pasos, como la creaci√≥n de personajes.
#
# `pool_size` se establece expl√≠citamente para evitar el error 'Too many connections'
# que puede ocurrir si muchos usuarios interact√∫an con el bot simult√°neamente.
storage = RedisStorage2(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    pool_size=20,
)

# 2. Creaci√≥n de la Instancia del Dispatcher
# Se crea una instancia √∫nica del `Dispatcher` para toda la aplicaci√≥n,
# vincul√°ndola con la instancia del `bot` y el `storage` configurado.
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
"""
M√≥dulo del Dispatcher Principal de Comandos.

Este archivo contiene el manejador (`handler`) m√°s importante de la aplicaci√≥n.
La funci√≥n `main_command_dispatcher` est√° registrada para interceptar **todos**
los mensajes de texto enviados por los jugadores.

Act√∫a como el "cerebro" del juego, orquestando el siguiente flujo para cada mensaje:
1. Obtiene el contexto del jugador (Cuenta, Personaje) desde la base de datos.
2. Actualiza el estado de actividad del jugador (online/AFK).
3. Maneja casos especiales como el comando `/start`.
4. Utiliza el `command_service` para determinar din√°micamente qu√© `CommandSets`
   est√°n activos para el jugador en ese preciso momento.
5. Busca el comando invocado dentro de los sets activos.
6. Verifica los permisos (`permission_service`).
7. Ejecuta el m√©todo `.execute()` del comando encontrado.
"""

import logging
from aiogram import types
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service, online_service, command_service
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.player.movement import MOVEMENT_COMMANDS
from commands.player.channels import CHANNEL_COMMANDS
from commands.player.dynamic_channels import DYNAMIC_CHANNEL_COMMANDS
from commands.player.settings import SETTINGS_COMMANDS
from commands.admin.building import SPAWN_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from commands.admin.info import INFO_COMMANDS
from commands.admin.diagnostics import DIAGNOSTICS_COMMANDS
from commands.admin.management import MANAGEMENT_COMMANDS
from src.utils.presenters import show_current_room

# El diccionario `COMMAND_SETS` es el cat√°logo maestro que contiene una instancia
# de cada comando disponible en el juego, agrupados por funcionalidad.
COMMAND_SETS = {
    # Comandos de Jugador
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "movement": MOVEMENT_COMMANDS,
    "channels": CHANNEL_COMMANDS,
    "dynamic_channels": DYNAMIC_CHANNEL_COMMANDS,
    "settings": SETTINGS_COMMANDS,
    # Comandos de Administrador
    "spawning": SPAWN_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
    "admin_info": INFO_COMMANDS,
    "diagnostics": DIAGNOSTICS_COMMANDS,
    "management": MANAGEMENT_COMMANDS,
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Manejador principal que intercepta todos los mensajes de texto y los
    enruta al comando correspondiente.
    """
    async with async_session_factory() as session:
        try:
            # 1. Obtener el contexto del jugador.
            account = await player_service.get_or_create_account(session, message.from_user.id)
            if not account:
                await message.answer("Error cr√≠tico al acceder a tu cuenta.")
                return
            character = account.character
            input_text = message.text.strip()

            # 2. Actualizar estado de actividad (online/AFK).
            if character:
                await online_service.update_last_seen(session, character)

            # 3. Manejo especial para el comando /start.
            if input_text.lower().startswith('/start'):
                if character is None:
                    await message.answer(
                        "¬°Bienvenido a Runegram! Veo que eres nuevo por aqu√≠.\n"
                        "Para empezar, necesitas crear tu personaje. Usa el comando:\n"
                        "/crearpersonaje [nombre]"
                    )
                else:
                    await command_service.update_telegram_commands(character)
                    await show_current_room(message)
                return

            # 4. Validar que el jugador tenga un personaje para la mayor√≠a de los comandos.
            if not character and not input_text.lower().startswith('/crearpersonaje'):
                await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                return

            # 5. Parsear el comando y sus argumentos.
            if not input_text.startswith('/'):
                await message.answer("Comando desconocido. Los comandos deben empezar con / (ej: /mirar, /norte).")
                return

            cmd_name = message.get_command(pure=True).lower()
            args = message.get_args().split() if message.get_args() else []

            # 6. Obtener la lista din√°mica de CommandSets activos.
            active_sets_names = await command_service.get_active_command_sets_for_character(character)

            # 7. Buscar y ejecutar el comando.
            found_cmd = None
            for set_name in active_sets_names:
                for cmd_instance in COMMAND_SETS.get(set_name, []):
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
                if found_cmd:
                    break

            if not found_cmd:
                await message.answer("No conozco ese comando.")
                return

            if not character and found_cmd.lock:
                await message.answer("Primero debes crear un personaje con /crearpersonaje [nombre].")
                return

            can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
            if not can_run:
                await message.answer(error_message or "No puedes hacer eso.")
                return

            await found_cmd.execute(character, session, message, args)

        except Exception:
            # Captura final para cualquier error no manejado en las capas inferiores.
            await message.answer("Ocurri√≥ un error inesperado al procesar tu comando.")
            logging.exception(f"Error cr√≠tico no manejado en el dispatcher principal para el usuario {message.from_user.id}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
from .character_setting import CharacterSetting
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
"""
M√≥dulo que define el Modelo de Datos para una Cuenta de Usuario.

Este archivo contiene la clase `Account`, que se mapea a la tabla `accounts`
en la base de datos. Una cuenta representa a un usuario real a nivel de aplicaci√≥n,
identificado de forma √∫nica por su `telegram_id`.

La cuenta es la entidad "propietaria" de un personaje (`Character`) y almacena
metadatos sobre el usuario, como su rol (JUGADOR, ADMIN, SUPERADMIN) y su estado
(ACTIVE, BLOCKED).
"""

from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    """
    Representa una cuenta de usuario en la base de datos.
    """
    __tablename__ = 'accounts'

    # Identificador √∫nico de la cuenta en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El ID de usuario √∫nico proporcionado por Telegram.
    # Es crucial para vincular nuestra cuenta interna con el usuario de Telegram.
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)

    # El rol del usuario en el juego. Determina el acceso a comandos especiales.
    # Jerarqu√≠a de roles (de mayor a menor): SUPERADMIN > ADMIN > JUGADOR.
    role = Column(String, default='JUGADOR', nullable=False, server_default='JUGADOR')

    # El estado de la cuenta (ej: 'ACTIVE', 'BLOCKED').
    # Permite gestionar el acceso de los usuarios a nivel de cuenta.
    status = Column(String(20), default='ACTIVE', nullable=False, server_default='ACTIVE')

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-uno con el personaje del juego.
    # `uselist=False` indica que una cuenta solo puede tener un personaje.
    # `back_populates` asegura que la relaci√≥n sea bidireccional.
    character = relationship("Character", back_populates="account", uselist=False)

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Account(id={self.id}, telegram_id={self.telegram_id}, role='{self.role}')>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
"""
M√≥dulo que define la Base Declarativa para todos los Modelos de SQLAlchemy.

Este archivo contiene un √∫nico pero crucial objeto: `Base`.

SQLAlchemy utiliza un sistema "declarativo" donde las clases de Python se mapean
directamente a tablas de la base de datos. Para que esto funcione, todas las
clases de modelo (como `Account`, `Character`, `Room`, etc.) deben heredar de
una clase base com√∫n.

Esta clase `Base` act√∫a como un registro central que recopila metadatos sobre
todas las clases de modelo que heredan de ella. Herramientas como Alembic
utilizan estos metadatos para comparar los modelos con el estado de la base
de datos y generar as√≠ las migraciones autom√°ticamente.
"""

from sqlalchemy.orm import declarative_base

# `declarative_base()` es una funci√≥n de f√°brica que construye la clase base.
# Todos nuestros modelos de datos en el proyecto heredar√°n de este objeto `Base`.
Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
"""
M√≥dulo que define el Modelo de Datos para un Personaje del Juego.

Este archivo contiene la clase `Character`, que se mapea a la tabla `characters`
en la base de datos. Un personaje es el "avatar" o la entidad con la que un
jugador interact√∫a dentro del mundo de Runegram.

El personaje est√° vinculado a una `Account` (el usuario real) y act√∫a como el
punto central para las relaciones de juego, como su ubicaci√≥n (`Room`), su
inventario (`Item`), y sus configuraciones (`CharacterSetting`).
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class Character(Base):
    """
    Representa un personaje jugable en la base de datos.
    """
    __tablename__ = 'characters'

    # --- Atributos Principales ---

    # Identificador √∫nico del personaje en nuestra base de datos.
    id = Column(BigInteger, primary_key=True)

    # El nombre del personaje, que debe ser √∫nico en todo el juego.
    name = Column(String(50), unique=True, nullable=False)

    # --- Claves For√°neas ---

    # V√≠nculo a la cuenta propietaria de este personaje.
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)

    # V√≠nculo a la sala donde se encuentra actualmente el personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Atributos de Juego (Datos Estructurados) ---

    # Almacena la lista de CommandSets base que el personaje conoce.
    # Por ejemplo: ["general", "interaction", "movement", "channels"].
    # Este campo es la base para el sistema de comandos din√°micos.
    command_sets = Column(
        JSONB,
        nullable=False,
        server_default='["general", "interaction", "movement", "channels"]',
        default=["general", "interaction", "movement", "channels"]
    )

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-uno con la cuenta.
    # Permite acceder al objeto `Account` desde el personaje v√≠a `character.account`.
    account = relationship("Account", back_populates="character")

    # Relaci√≥n muchos-a-uno con la sala.
    # Permite acceder al objeto `Room` desde el personaje v√≠a `character.room`.
    room = relationship("Room")

    # Relaci√≥n uno-a-muchos con los objetos del inventario.
    # Permite acceder a una lista de objetos `Item` v√≠a `character.items`.
    items = relationship("Item", back_populates="character")

    # Relaci√≥n uno-a-uno con las configuraciones del personaje.
    # Permite acceder al objeto `CharacterSetting` v√≠a `character.settings`.
    # `cascade="all, delete-orphan"` asegura que si se borra un personaje,
    # su fila de configuraciones asociada tambi√©n se borre autom√°ticamente.
    settings = relationship(
        "CharacterSetting",
        back_populates="character",
        uselist=False,
        cascade="all, delete-orphan"
    )

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Character(id={self.id}, name='{self.name}')>"
# === FIN: src/models/character.py ===


# === INICIO: src/models/character_setting.py ===
# src/models/character_setting.py
"""
M√≥dulo que define el Modelo de Datos para las Configuraciones de un Personaje.

Este archivo contiene la clase `CharacterSetting`, que se mapea a la tabla
`character_settings`. Esta tabla almacena configuraciones personalizables
para cada personaje, manteniendo el modelo `Character` principal m√°s limpio.

El uso de una columna `JSONB` (`active_channels`) permite a√±adir futuras
configuraciones (ej: colores, flags de tutorial) sin necesidad de modificar
el esquema de la base de datos, lo que hace que el sistema sea muy flexible
y extensible.
"""

from sqlalchemy import BigInteger, Column, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from .base import Base

class CharacterSetting(Base):
    """
    Representa una fila de configuraciones para un personaje espec√≠fico.
    """
    __tablename__ = 'character_settings'

    # --- Clave Primaria y For√°nea ---

    # Usamos el ID del personaje como clave primaria (`primary_key=True`).
    # Esto impone una relaci√≥n estricta de uno-a-uno a nivel de base de datos:
    # no puede haber m√°s de una fila de configuraciones por personaje.
    character_id = Column(BigInteger, ForeignKey('characters.id'), primary_key=True)

    # --- Atributos de Configuraci√≥n ---

    # Columna JSONB para guardar una lista de los canales a los que el personaje
    # est√° suscrito. Usar JSONB es muy flexible.
    # Ejemplo de contenido: `{"active_channels": ["novato", "comercio"]}`
    active_channels = Column(JSONB, nullable=False, server_default='{}')

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n inversa uno-a-uno con el personaje.
    # Permite acceder al objeto `Character` desde la configuraci√≥n v√≠a `settings.character`.
    character = relationship("Character", back_populates="settings")

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<CharacterSetting(character_id={self.character_id})>"
# === FIN: src/models/character_setting.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py
"""
M√≥dulo que define el Modelo de Datos para una Salida entre Salas.

Este archivo contiene la clase `Exit`, que se mapea a la tabla `exits`.
Cada fila en esta tabla representa una conexi√≥n UNIDIRECCIONAL desde una sala
de origen (`from_room_id`) hacia una sala de destino (`to_room_id`).

Una conexi√≥n bidireccional (ej: una puerta entre la sala A y la sala B) se
representa como dos filas separadas en esta tabla:
1. Una salida desde A hacia B (ej: "norte").
2. Una salida desde B hacia A (ej: "sur").
"""

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    # --- Atributos Principales ---

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta").
    name = Column(String(50), nullable=False, index=True)

    # El string de permisos para esta salida espec√≠fica.
    locks = Column(String, nullable=False, default="")

    # --- Claves For√°neas ---

    # El ID de la sala desde la que parte esta salida.
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El ID de la sala a la que lleva esta salida.
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n para poder acceder al objeto `Room` de origen.
    # `foreign_keys=[from_room_id]` es necesario para que SQLAlchemy sepa cu√°l de
    # las dos claves for√°neas a 'rooms.id' debe usar para esta relaci√≥n.
    # `back_populates="exits_from"` la conecta con la lista de salidas en el modelo Room.
    from_room = relationship("Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relaci√≥n para poder acceder al objeto `Room` de destino.
    # `back_populates="exits_to"` la conecta con la lista de "llegadas" en el modelo Room.
    to_room = relationship("Room", foreign_keys=[to_room_id], back_populates="exits_to")

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Exit(id={self.id}, name='{self.name}', from={self.from_room_id}, to={self.to_room_id})>"
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py
"""
M√≥dulo que define el Modelo de Datos para una Instancia de Objeto (Item).

Este archivo contiene la clase `Item`, que se mapea a la tabla `items`.
Es fundamental entender que este modelo NO representa un tipo de objeto, sino
una INSTANCIA √∫nica de un objeto en el mundo.

Este modelo es deliberadamente "ligero". La mayor√≠a de sus propiedades (nombre,
descripci√≥n, scripts, etc.) no se almacenan en la base de datos, sino que se
obtienen en tiempo de ejecuci√≥n a trav√©s de la columna `key`, que lo vincula
a su prototipo correspondiente en `game_data/item_prototypes.py`.
"""

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship

from game_data.item_prototypes import ITEM_PROTOTYPES
from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo del juego.
    """
    __tablename__ = 'items'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ITEM_PROTOTYPES.
    # Por ejemplo: "espada_viviente".
    key = Column(String(50), nullable=False, index=True)

    # Atributos `_override`: Permiten que una instancia espec√≠fica tenga
    # un nombre o descripci√≥n diferente a la de su prototipo, creando objetos √∫nicos.
    # Si son `NULL`, se usar√°n los valores del prototipo.
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)

    # --- Ubicaci√≥n del Objeto ---

    # El ID de la sala donde se encuentra el objeto.
    # Es `NULL` si el objeto est√° en el inventario de un personaje.
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)

    # El ID del personaje que lleva el objeto.
    # Es `NULL` si el objeto est√° en el suelo de una sala.
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n muchos-a-uno con la sala. Permite acceder a `item.room`.
    room = relationship("Room", back_populates="items")

    # Relaci√≥n muchos-a-uno con el personaje. Permite acceder a `item.character`.
    character = relationship("Character", back_populates="items")

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para este objeto desde `game_data`. Es el puente entre la instancia
        de la base de datos y su definici√≥n de contenido.
        """
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """
        Obtiene el nombre del item.
        Prioriza el `name_override` si existe; de lo contrario,
        recurre al nombre definido en el prototipo.
        """
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """
        Obtiene la descripci√≥n del item.
        Prioriza el `description_override` si existe; de lo contrario,
        recurre a la descripci√≥n definida en el prototipo.
        """
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """
        Obtiene las palabras clave del item, que siempre provienen del prototipo.
        """
        return self.prototype.get("keywords", [])

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Item(id={self.id}, key='{self.key}')>"
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py
"""
M√≥dulo que define el Modelo de Datos para una Sala del Mundo.

Este archivo contiene la clase `Room`, que se mapea a la tabla `rooms`.
Cada fila en esta tabla representa una ubicaci√≥n √∫nica en el juego.

Siguiendo la filosof√≠a de dise√±o del motor, una `Room` en la base de datos
es principalmente una instancia que se corresponde con un prototipo definido en
`game_data/room_prototypes.py`, vinculado a trav√©s de la columna `key`.
"""

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base
from game_data.room_prototypes import ROOM_PROTOTYPES

class Room(Base):
    """
    Representa una sala o ubicaci√≥n en el mundo del juego.
    """
    __tablename__ = 'rooms'

    # --- Atributos de la Instancia ---

    id = Column(BigInteger, primary_key=True)

    # La clave que vincula esta instancia con su prototipo en ROOM_PROTOTYPES.
    # Por ejemplo: "plaza_central". Es √∫nico y no deber√≠a cambiar.
    key = Column(String(50), unique=True, nullable=True, index=True)

    # El nombre y la descripci√≥n pueden ser actualizados desde los prototipos
    # por el `world_loader_service`.
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")

    # String de permisos para la sala en s√≠ (ej: para impedir la entrada).
    locks = Column(String, nullable=False, default="")

    # --- Relaciones de SQLAlchemy ---

    # Relaci√≥n uno-a-muchos con los objetos que se encuentran en esta sala.
    # Permite acceder a una lista de `Item` v√≠a `room.items`.
    items = relationship("Item", back_populates="room")

    # Relaci√≥n uno-a-muchos con las salidas QUE PARTEN DESDE ESTA SALA.
    # Permite acceder a una lista de `Exit` v√≠a `room.exits_from`.
    # `cascade="all, delete-orphan"` asegura que si se borra una sala,
    # todas sus salidas asociadas tambi√©n se eliminen.
    exits_from = relationship(
        "Exit",
        foreign_keys="[Exit.from_room_id]",
        back_populates="from_room",
        cascade="all, delete-orphan"
    )

    # Relaci√≥n uno-a-muchos con las salidas QUE LLEGAN A ESTA SALA.
    # Es √∫til para comprobaciones inversas (ej: "¬øqu√© salas conectan aqu√≠?").
    exits_to = relationship(
        "Exit",
        foreign_keys="[Exit.to_room_id]",
        back_populates="to_room",
        cascade="all, delete-orphan"
    )

    @property
    def prototype(self) -> dict:
        """
        Propiedad de conveniencia que devuelve el diccionario del prototipo
        para esta sala desde `game_data`.
        """
        if not self.key:
            return {}
        return ROOM_PROTOTYPES.get(self.key, {})

    def __repr__(self):
        """
        Representaci√≥n en string del objeto, √∫til para logging y depuraci√≥n.
        """
        return f"<Room(id={self.id}, key='{self.key}', name='{self.name}')>"
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===
# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster_service.py ===
# src/services/broadcaster_service.py
"""
M√≥dulo de Servicio de Transmisi√≥n (Broadcasting).

Este archivo centraliza toda la l√≥gica para enviar mensajes a los jugadores
a trav√©s del bot de Telegram. Act√∫a como una capa de abstracci√≥n sobre la API
directa del bot.

Centralizar la comunicaci√≥n aqu√≠ ofrece varias ventajas:
1.  **Consistencia:** Todos los mensajes enviados por el juego pueden tener un
    formato y comportamiento consistentes.
2.  **Manejo de Errores Unificado:** La l√≥gica para manejar errores de la API de
    Telegram (ej: un usuario bloquea el bot) se encuentra en un solo lugar.
3.  **Desacoplamiento:** El resto de los servicios (scripts, canales, etc.) no
    necesitan saber los detalles de c√≥mo se env√≠a un mensaje; simplemente
    llaman a una funci√≥n en este servicio.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.bot.bot import bot
from src.models import Character


async def send_message_to_character(
    character: Character,
    message_text: str,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje formateado a un personaje espec√≠fico.

    Args:
        character (Character): La instancia del modelo Character a la que se enviar√° el mensaje.
                               Es crucial que este objeto tenga su relaci√≥n `.account` precargada.
        message_text (str): El contenido del mensaje a enviar.
        parse_mode (str): El modo de parseo de Telegram (por defecto 'HTML').
    """
    if not character:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un personaje nulo.")
        return

    # Salvaguarda para asegurar que la relaci√≥n con la cuenta est√° cargada.
    if not character.account:
        logging.error(f"BROADCASTER: El personaje {character.name} (ID: {character.id}) no tiene su cuenta cargada. No se puede enviar mensaje.")
        return

    try:
        logging.info(f"[BROADCASTER DEBUG] Intentando enviar mensaje a {character.name} (Chat ID: {character.account.telegram_id})")
        await bot.send_message(
            chat_id=character.account.telegram_id,
            text=message_text,
            parse_mode=parse_mode
        )
        logging.info(f"[BROADCASTER DEBUG] Mensaje enviado con √©xito a {character.name}")
    except Exception:
        # Usamos logging.exception para obtener un traceback completo si el env√≠o falla.
        # Esto es com√∫n si un usuario ha bloqueado el bot. No debe detener el juego.
        logging.exception(f"BROADCASTER: No se pudo enviar mensaje a {character.name} (ID: {character.id})")


async def send_message_to_room(
    session: AsyncSession,
    room_id: int,
    message_text: str,
    exclude_character_id: int | None = None,
    parse_mode: str = "HTML"
):
    """
    Env√≠a un mensaje a todos los personajes presentes en una sala espec√≠fica.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala a la que se enviar√° el mensaje.
        message_text (str): El contenido del mensaje a enviar.
        exclude_character_id (int, optional): El ID de un personaje a excluir de la transmisi√≥n.
        parse_mode (str): El modo de parseo de Telegram.
    """
    if not room_id:
        logging.warning("BROADCASTER: Se intent√≥ enviar un mensaje a un room_id nulo.")
        return

    # 1. Obtenemos todos los personajes en la sala.
    #    Usamos `selectinload(Character.account)` para cargar eficientemente la
    #    informaci√≥n de la cuenta de todos los personajes en una sola consulta.
    query = (
        select(Character)
        .where(Character.room_id == room_id)
        .options(selectinload(Character.account))
    )
    result = await session.execute(query)
    characters_in_room = result.scalars().all()

    # 2. Iteramos y enviamos el mensaje a cada personaje.
    for char in characters_in_room:
        if char.id == exclude_character_id:
            continue

        # Reutilizamos nuestra propia funci√≥n para mantener la l√≥gica de env√≠o en un solo lugar.
        await send_message_to_character(
            character=char,
            message_text=message_text,
            parse_mode=parse_mode
        )
# === FIN: src/services/broadcaster_service.py ===


# === INICIO: src/services/channel_service.py ===
# src/services/channel_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Canales de Chat.

Este servicio encapsula toda la l√≥gica de negocio relacionada con los canales
de comunicaci√≥n globales. Sus responsabilidades incluyen:
- Gestionar la configuraci√≥n de canales por personaje (suscripciones).
- Formatear y transmitir mensajes a todos los jugadores suscritos a un canal.
- Proveer funciones de ayuda para comprobar el estado de los canales.

Depende de `broadcaster_service` para el env√≠o final de mensajes y de
`game_data/channel_prototypes.py` como fuente de la verdad sobre los
canales disponibles.
"""

import logging
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Character, CharacterSetting
from src.services import broadcaster_service
from game_data.channel_prototypes import CHANNEL_PROTOTYPES

async def get_or_create_settings(session: AsyncSession, character: Character) -> CharacterSetting:
    """
    Obtiene las configuraciones para un personaje. Si no existen, las crea con
    los valores por defecto definidos en los prototipos de canal.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        character (Character): El personaje para el que se obtienen las configuraciones.

    Returns:
        CharacterSetting: El objeto de configuraci√≥n del personaje.
    """
    # Si las settings ya est√°n cargadas en el objeto character, las devolvemos directamente.
    if character.settings:
        return character.settings

    # Si no, las creamos.
    logging.info(f"Creando configuraciones por defecto para el personaje {character.name}")

    # Leemos los prototipos para ver qu√© canales deben estar activados por defecto.
    default_channels = [
        key for key, data in CHANNEL_PROTOTYPES.items() if data.get("default_on", False)
    ]

    new_settings = CharacterSetting(
        character_id=character.id,
        active_channels={"active_channels": default_channels}
    )
    session.add(new_settings)
    await session.commit()

    # Refrescamos el objeto 'character' para que la relaci√≥n 'settings' se cargue.
    await session.refresh(character, attribute_names=["settings"])

    return character.settings

async def is_channel_active(settings: CharacterSetting, channel_key: str) -> bool:
    """Comprueba si un canal est√° en la lista de canales activos de un jugador."""
    if not settings:
        return False
    return channel_key in settings.active_channels.get("active_channels", [])

async def broadcast_to_channel(session: AsyncSession, channel_key: str, message: str, exclude_character_id: int | None = None):
    """
    Env√≠a un mensaje a todos los jugadores que est√©n suscritos a un canal.
    """
    try:
        if channel_key not in CHANNEL_PROTOTYPES:
            logging.warning(f"Intento de transmitir a un canal desconocido: {channel_key}")
            return

        # 1. Formatear el mensaje con el √≠cono y nombre del canal.
        proto = CHANNEL_PROTOTYPES[channel_key]
        formatted_message = f"{proto['icon']} <b>{proto['name']}:</b> {message}"

        # 2. Obtener todos los personajes del juego.
        #    Precargamos sus settings y cuentas para evitar consultas adicionales en el bucle.
        query = select(Character).options(selectinload(Character.settings), selectinload(Character.account))
        result = await session.execute(query)
        all_characters = result.scalars().all()

        # 3. Iterar y enviar el mensaje a los que est√©n suscritos.
        for char in all_characters:
            if char.id == exclude_character_id:
                continue

            settings = await get_or_create_settings(session, char)
            if await is_channel_active(settings, channel_key):
                await broadcaster_service.send_message_to_character(char, formatted_message)
    except Exception:
        logging.exception(f"Error al transmitir al canal '{channel_key}'")

async def set_channel_status(session: AsyncSession, character: Character, channel_key: str, activate: bool):
    """Activa o desactiva un canal para un personaje."""
    if channel_key not in CHANNEL_PROTOTYPES:
        raise ValueError("El canal especificado no existe.")

    settings = await get_or_create_settings(session, character)

    # SQLAlchemy es capaz de detectar cambios en listas dentro de un JSONB "mutable".
    # Obtenemos la lista actual de canales activos.
    active_channels_list = settings.active_channels.get("active_channels", [])

    if activate:
        # A√±adir el canal si no est√° ya en la lista.
        if channel_key not in active_channels_list:
            active_channels_list.append(channel_key)
    else: # Desactivar
        # Quitar el canal si est√° en la lista.
        if channel_key in active_channels_list:
            active_channels_list.remove(channel_key)

    # Reasignamos la lista modificada al campo JSONB.
    settings.active_channels["active_channels"] = active_channels_list

    # Marcamos el objeto como "modificado" para que SQLAlchemy sepa que debe guardarlo.
    from sqlalchemy.orm.attributes import flag_modified
    flag_modified(settings, "active_channels")

    await session.commit()
# === FIN: src/services/channel_service.py ===


# === INICIO: src/services/command_service.py ===
"""
M√≥dulo de Servicio para la Gesti√≥n de Comandos.

Este servicio es el cerebro detr√°s del sistema de comandos din√°micos.
No define los comandos en s√≠, sino que orquesta cu√°les est√°n disponibles
para un jugador en un momento dado y c√≥mo se presentan en la interfaz.

Responsabilidades Clave:
1. Calcular la lista de `CommandSets` activos para un personaje bas√°ndose
   en su estado, equipo y ubicaci√≥n (contexto).
2. Sincronizar la lista de comandos disponibles con la interfaz del cliente
   de Telegram, proporcionando una experiencia de usuario (UX) reactiva.
"""

import logging
from aiogram.types import BotCommand, BotCommandScopeChat
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.bot import bot
from src.models import Character

def get_command_sets() -> dict:
    """
    Obtiene el diccionario `COMMAND_SETS` del dispatcher de forma segura para
    evitar importaciones circulares.
    """
    from src.handlers.player.dispatcher import COMMAND_SETS
    return COMMAND_SETS

async def get_active_command_sets_for_character(character: Character) -> list[str]:
    """
    Construye la lista de nombres de CommandSets activos para un personaje
    bas√°ndose en su contexto actual (base, equipo, sala, rol).
    """
    if not character:
        return ["character_creation"]

    # 1. Empezamos con los sets base del personaje desde la BD.
    active_sets = set(character.command_sets)

    # 2. A√±adimos sets otorgados por los objetos en el inventario.
    for item in character.items:
        granted_sets = item.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 3. A√±adimos sets otorgados por la sala actual.
    if character.room and character.room.prototype:
        granted_sets = character.room.prototype.get("grants_command_sets", [])
        active_sets.update(granted_sets)

    # 4. A√±adimos sets de administrador si el rol de la cuenta es el adecuado.
    if character.account and character.account.role in ["ADMIN", "SUPERADMIN"]:
        active_sets.update(["spawning", "admin_movement", "admin_info", "diagnostics", "management"])

    return sorted(list(active_sets))


async def update_telegram_commands(character: Character):
    """
    Actualiza la lista de comandos visibles en el men√∫ '/' del cliente de Telegram
    para un personaje espec√≠fico.
    """
    if not character or not character.account:
        return

    try:
        COMMAND_SETS = get_command_sets()
        active_set_names = await get_active_command_sets_for_character(character)

        telegram_commands = []
        seen_commands = set()

        # Construimos la lista de objetos BotCommand que la API de Telegram espera.
        for set_name in active_set_names:
            for command_instance in COMMAND_SETS.get(set_name, []):
                main_name = command_instance.names[0]
                if main_name not in seen_commands:
                    telegram_commands.append(
                        BotCommand(command=main_name, description=command_instance.description)
                    )
                    seen_commands.add(main_name)

        # Usamos un `BotCommandScopeChat` para aplicar estos comandos √∫nicamente
        # al chat con este jugador espec√≠fico.
        scope = BotCommandScopeChat(chat_id=character.account.telegram_id)
        await bot.set_my_commands(commands=telegram_commands, scope=scope)

        logging.info(f"Actualizados {len(telegram_commands)} comandos de Telegram para {character.name}.")

    except Exception as e:
        # Los errores al actualizar comandos no son cr√≠ticos y no deben detener el juego.
        logging.warning(f"No se pudieron actualizar los comandos de Telegram para {character.name}: {e}")
# === FIN: src/services/command_service.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Objetos (Items).

Este servicio encapsula la l√≥gica de negocio para crear y manipular instancias
de objetos en el mundo del juego. Se encarga de la interacci√≥n directa con el
modelo `Item`.

Responsabilidades:
- Crear nuevas instancias de objetos a partir de prototipos (`spawn`).
- Mover objetos entre salas y los inventarios de los personajes.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
from game_data.item_prototypes import ITEM_PROTOTYPES
from src.services import ticker_service


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto, la coloca en una sala
    y registra sus tickers.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala donde se crear√° el objeto.
        item_key (str): La clave del prototipo del objeto a crear.

    Returns:
        Item: La nueva instancia del objeto `Item` creada.

    Raises:
        ValueError: Si la `item_key` no corresponde a ning√∫n prototipo definido.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    try:
        # 1. Crear la instancia del modelo Item, vincul√°ndola a la sala.
        new_item = Item(room_id=room_id, key=item_key)
        session.add(new_item)
        await session.commit()
        await session.refresh(new_item)

        # 2. Notificar al ticker_service para que programe los tickers de este nuevo objeto.
        await ticker_service.schedule_tickers_for_entity(new_item)

        return new_item
    except Exception:
        logging.exception(f"Error inesperado al intentar generar el objeto con clave '{item_key}' en la sala {room_id}")
        # Relanzamos la excepci√≥n para que la capa superior (el comando) la maneje.
        raise


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """
    Mueve un objeto desde una sala (o de ning√∫n sitio) al inventario de un personaje.
    Actualiza el `room_id` a NULL y establece el `character_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=None, character_id=character_id)
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """
    Mueve un objeto desde el inventario de un personaje al suelo de una sala.
    Actualiza el `character_id` a NULL y establece el `room_id`.
    """
    query = (
        update(Item)
        .where(Item.id == item_id)
        .values(room_id=room_id, character_id=None)
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/online_service.py ===
# src/services/online_service.py
"""
M√≥dulo de Servicio para el Seguimiento de Actividad (Presencia).

Este servicio gestiona el estado de "online" o "AFK" (Away From Keyboard) de los
personajes. Utiliza Redis para un almacenamiento y recuperaci√≥n de datos de alta
velocidad, lo cual es ideal para datos vol√°tiles como el timestamp de la √∫ltima
actividad.

Responsabilidades:
- Registrar la √∫ltima vez que un jugador env√≠a un comando.
- Determinar si un jugador est√° "online" bas√°ndose en un umbral de inactividad.
- Gestionar las notificaciones cuando un jugador pasa a estado AFK o vuelve.
- Proveer una tarea global (`check_for_newly_afk_players`) para ser ejecutada
  peri√≥dicamente por el `ticker_service`.
"""

import time
import logging
import redis.asyncio as redis
from datetime import timedelta

from src.config import settings
from src.models import Character
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from src.db import async_session_factory


# --- Configuraci√≥n del Servicio ---

# Si un jugador no ha enviado un comando en este tiempo, se considera "offline".
ONLINE_THRESHOLD = timedelta(minutes=5)

# Cliente de Redis dedicado para este servicio.
redis_client = redis.Redis(
    host=settings.redis_host,
    port=settings.redis_port,
    db=settings.redis_db,
    decode_responses=True
)

# Variable global en memoria para rastrear qui√©n estaba online en el √∫ltimo chequeo.
PREVIOUSLY_ONLINE_IDS = set()


# --- Funciones de Ayuda (Internas) ---

def _get_last_seen_key(character_id: int) -> str:
    """Genera la clave de Redis estandarizada para el timestamp de un personaje."""
    return f"last_seen:{character_id}"

def _get_afk_notified_key(character_id: int) -> str:
    """Genera la clave de Redis para el flag que indica si ya se notific√≥ el estado AFK."""
    return f"afk_notified:{character_id}"


# --- Funciones Principales del Servicio ---

async def update_last_seen(session: AsyncSession, character: Character):
    """
    Actualiza la √∫ltima actividad de un personaje y le notifica si vuelve de estar AFK.
    Esta funci√≥n es llamada por el dispatcher en cada mensaje.
    """
    # Importamos aqu√≠ para evitar importaciones circulares.
    from src.services import broadcaster_service

    char_id = character.id

    # 1. Actualizar el timestamp de "√∫ltima vez visto" en Redis.
    key = _get_last_seen_key(char_id)
    await redis_client.set(key, time.time())
    await redis_client.expire(key, timedelta(days=7))

    # 2. Comprobar si el personaje estaba marcado como AFK.
    afk_notified_key = _get_afk_notified_key(char_id)
    # `getdel` obtiene y borra la clave at√≥micamente si existe.
    was_afk = await redis_client.getdel(afk_notified_key)

    if was_afk:
        # El personaje estaba AFK y acaba de volver. Se le notifica directamente.
        logging.info(f"Personaje {character.name} ha vuelto de su inactividad (AFK).")
        await broadcaster_service.send_message_to_character(
            character,
            "<i>Has vuelto de tu inactividad.</i>"
        )


async def is_character_online(character_id: int) -> bool:
    """
    Verifica si un personaje se considera "online" (activo recientemente).
    """
    key = _get_last_seen_key(character_id)
    last_seen_timestamp_str = await redis_client.get(key)
    if not last_seen_timestamp_str:
        return False

    try:
        elapsed_time = time.time() - float(last_seen_timestamp_str)
        return elapsed_time < ONLINE_THRESHOLD.total_seconds()
    except (ValueError, TypeError):
        return False

async def get_online_characters(session: AsyncSession) -> list[Character]:
    """
    Devuelve una lista de todos los objetos Character que se consideran "online".
    """
    result = await session.execute(select(Character))
    all_characters = result.scalars().all()

    online_characters = []
    for char in all_characters:
        if await is_character_online(char.id):
            online_characters.append(char)

    return online_characters

async def check_for_newly_afk_players():
    """
    Tarea global peri√≥dica para detectar y notificar sobre personajes que se
    han vuelto inactivos (AFK).
    """
    # Importamos aqu√≠ para evitar importaciones circulares.
    from src.services import broadcaster_service, player_service
    global PREVIOUSLY_ONLINE_IDS
    logging.info("[AFK CHECK] Ejecutando chequeo de jugadores inactivos...")

    async with async_session_factory() as session:
        try:
            result = await session.execute(select(Character.id))
            all_char_ids = set(result.scalars().all())

            currently_online_ids = set()
            for char_id in all_char_ids:
                if await is_character_online(char_id):
                    currently_online_ids.add(char_id)

            # Compara la lista de jugadores online de ahora con la de la √∫ltima vez.
            newly_afk_ids = PREVIOUSLY_ONLINE_IDS - currently_online_ids

            for char_id in newly_afk_ids:
                afk_notified_key = _get_afk_notified_key(char_id)
                # Solo notificamos si no se ha notificado ya.
                if not await redis_client.exists(afk_notified_key):
                    character = await player_service.get_character_with_relations_by_id(session, char_id)
                    if character:
                        logging.info(f"Personaje {character.name} ha entrado en inactividad (AFK).")
                        await broadcaster_service.send_message_to_character(
                            character,
                            "<i>Has entrado en modo de inactividad (AFK).</i>"
                        )
                        # Marcamos que ya fue notificado para no spamear.
                        await redis_client.set(afk_notified_key, "1", ex=timedelta(days=1))
        except Exception:
            logging.exception("[AFK CHECK] Ocurri√≥ un error durante el chequeo de AFK.")

    # Actualizamos el estado global para la pr√≥xima comprobaci√≥n.
    PREVIOUSLY_ONLINE_IDS = currently_online_ids
    logging.info(f"[AFK CHECK] Chequeo finalizado. {len(PREVIOUSLY_ONLINE_IDS)} jugadores online.")
# === FIN: src/services/online_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Permisos y Locks.

Este servicio es el "guardi√°n" de acceso a acciones en el juego. Interpreta
"lock strings" (cadenas de permisos) para determinar si un personaje tiene
permiso, utilizando el m√≥dulo `ast` de Python para un parseo seguro y potente.

El sistema es extensible y soporta l√≥gica booleana compleja:
1. Un `lock_string` es una expresi√≥n similar a Python (ej: "rol(ADMIN) or (tiene_objeto(llave) and not rol(SUPERADMIN))").
2. `ast.parse` convierte el string en un √°rbol de sintaxis abstracta (AST) de forma segura.
3. La clase `LockEvaluator` (un `ast.NodeVisitor`) recorre el √°rbol y eval√∫a el resultado.
4. Las funciones de lock (ej: `rol()`) est√°n registradas en `LOCK_FUNCTIONS`.
"""

import logging
import ast # M√≥dulo para parsear la sintaxis de Python de forma segura
from src.models import Character

# --- Jerarqu√≠a de Roles ---
ROLE_HIERARCHY = {
    "JUGADOR": 1,
    "ADMIN": 2,
    "SUPERADMIN": 3,
}

# ==============================================================================
# SECCI√ìN DE FUNCIONES DE LOCK
#
# Estas funciones no cambian. Siguen siendo los bloques de construcci√≥n
# de nuestra l√≥gica de permisos.
# ==============================================================================

def _lock_rol(character: Character, args: list[str]) -> bool:
    """Chequea si el rol del personaje es igual o superior al requerido."""
    if not character or not character.account or not args:
        return False

    required_role = args[0].upper()
    user_role = character.account.role.upper()

    required_level = ROLE_HIERARCHY.get(required_role, 99)
    user_level = ROLE_HIERARCHY.get(user_role, 0)

    return user_level >= required_level

def _lock_tiene_objeto(character: Character, args: list[str]) -> bool:
    """Chequea si el personaje lleva en su inventario un objeto con la clave dada."""
    if not character or not args:
        return False

    item_key = args[0]
    return any(item.key == item_key for item in character.items)

# ==============================================================================
# REGISTRO DE FUNCIONES DE LOCK
# ==============================================================================

LOCK_FUNCTIONS = {
    "rol": _lock_rol,
    "tiene_objeto": _lock_tiene_objeto,
}

# ==============================================================================
# MOTOR DEL SERVICIO DE PERMISOS (BASADO EN AST)
# ==============================================================================

class LockEvaluator(ast.NodeVisitor):
    """
    Un visitante de nodos AST que eval√∫a un lock string de forma segura.
    Recorre el √°rbol de sintaxis y calcula el resultado booleano final.
    """
    def __init__(self, character: Character):
        self.character = character

    def visit_BoolOp(self, node: ast.BoolOp) -> bool:
        """Maneja operadores `and` y `or`."""
        # Obtenemos los resultados de cada sub-expresi√≥n.
        sub_results = [self.visit(value) for value in node.values]
        if isinstance(node.op, ast.And):
            return all(sub_results)
        elif isinstance(node.op, ast.Or):
            return any(sub_results)
        return False

    def visit_UnaryOp(self, node: ast.UnaryOp) -> bool:
        """Maneja el operador `not`."""
        if isinstance(node.op, ast.Not):
            return not self.visit(node.operand)
        return False

    def visit_Call(self, node: ast.Call) -> bool:
        """Maneja las llamadas a funciones de lock (ej: `rol(...)`)."""
        func_name = node.func.id.lower()
        if func_name in LOCK_FUNCTIONS:
            # Evaluamos los argumentos (que tambi√©n son nodos AST).
            args = [self.visit(arg) for arg in node.args]
            lock_func = LOCK_FUNCTIONS[func_name]
            return lock_func(self.character, args)

        logging.warning(f"Funci√≥n de lock desconocida llamada: {func_name}")
        return False # Falla de forma segura si la funci√≥n no est√° registrada.

    def visit_Constant(self, node: ast.Constant) -> any:
        """Maneja valores constantes como strings o n√∫meros."""
        return node.value

    def visit_Name(self, node: ast.Name) -> str:
        """
        Maneja nombres/identificadores. Los tratamos como strings.
        Esto permite escribir `rol(ADMIN)` en lugar de `rol('ADMIN')`.
        """
        return node.id

    def generic_visit(self, node):
        """
        M√©todo de captura para cualquier tipo de nodo no soportado.
        Esto es una medida de seguridad crucial para prevenir la ejecuci√≥n
        de c√≥digo no deseado (bucles, asignaciones, etc.).
        """
        raise TypeError(f"Construcci√≥n no soportada en lock string: {type(node).__name__}")

async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Eval√∫a un `lock_string` contra un personaje para ver si puede pasar el lock.
    """
    if not lock_string:
        return True, ""

    try:
        # 1. Parsear el string a un √°rbol AST. `mode='eval'` espera una sola expresi√≥n.
        tree = ast.parse(lock_string, mode='eval')

        # 2. Crear una instancia de nuestro evaluador con el contexto del personaje.
        evaluator = LockEvaluator(character)

        # 3. Visitar el √°rbol para obtener el resultado booleano.
        result = evaluator.visit(tree.body)

        if result:
            return True, ""
        else:
            return False, "Permiso denegado."

    except SyntaxError:
        logging.error(f"Error de sintaxis en el lock string: '{lock_string}'")
        return False, "Error en la definici√≥n de permisos de esta acci√≥n."
    except Exception as e:
        logging.exception(f"Error inesperado al evaluar el lock string: '{lock_string}'")
        return False, "Error interno al comprobar los permisos."
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py
"""
M√≥dulo de Servicio para la Gesti√≥n de Jugadores y Personajes.

Este es uno de los servicios centrales de la aplicaci√≥n. Encapsula toda la
l√≥gica de negocio para crear, recuperar y modificar las entidades `Account` y
`Character`.

Act√∫a como la √∫nica capa que interact√∫a directamente con los modelos de jugador,
asegurando que toda la l√≥gica de negocio est√© centralizada y sea consistente.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.services import channel_service, command_service


async def get_character_with_relations_by_id(session: AsyncSession, character_id: int) -> Character | None:
    """
    Busca un personaje por su ID y carga expl√≠citamente todas sus relaciones
    cr√≠ticas (sala, inventario, cuenta, configuraciones) en una sola consulta.

    Esta es una funci√≥n de ayuda crucial para evitar errores de "carga perezosa"
    (lazy loading) en un entorno as√≠ncrono.
    """
    try:
        query = (
            select(Character)
            .where(Character.id == character_id)
            .options(
                selectinload(Character.room).selectinload(Room.items),
                selectinload(Character.room).selectinload(Room.exits_from),
                selectinload(Character.items),
                selectinload(Character.account),
                selectinload(Character.settings)
            )
        )
        result = await session.execute(query)
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al obtener el personaje completo con ID {character_id}")
        return None

async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Garantiza que el objeto `Account` devuelto contenga un `Character` completamente
    cargado si este existe.
    """
    try:
        # 1. Buscar la cuenta y su personaje asociado.
        account_query = select(Account).where(Account.telegram_id == telegram_id).options(selectinload(Account.character))
        result = await session.execute(account_query)
        account = result.scalar_one_or_none()

        # 2. Si la cuenta no existe, crearla y devolverla.
        if not account:
            logging.info(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
            new_account = Account(telegram_id=telegram_id)
            session.add(new_account)
            await session.commit()
            await session.refresh(new_account)
            return new_account

        # 3. Si la cuenta existe pero no tiene personaje, devolverla tal cual.
        if not account.character:
            return account

        # 4. Si la cuenta y el personaje existen, usar nuestra funci√≥n de ayuda para
        #    asegurarnos de que el personaje est√° completamente cargado con todas sus relaciones.
        full_character = await get_character_with_relations_by_id(session, account.character.id)
        account.character = full_character
        return account
    except Exception:
        logging.exception(f"Error al obtener o crear la cuenta para telegram_id {telegram_id}")
        # En caso de un fallo cr√≠tico, es m√°s seguro devolver None.
        return None

async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje, lo asocia a una cuenta, y dispara los hooks de bienvenida.
    """
    account = await get_or_create_account(session, telegram_id)
    if not account:
        raise RuntimeError("No se pudo obtener o crear una cuenta de usuario.")

    # Validaciones de negocio
    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya est√° en uso. Por favor, elige otro.")

    # Creaci√≥n y persistencia
    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1 # Asigna a la sala de inicio "limbo"
    )
    session.add(new_character)
    await session.commit()

    # Recargamos el personaje por completo para tener todas las relaciones disponibles.
    full_character = await get_character_with_relations_by_id(session, new_character.id)
    if not full_character:
        raise RuntimeError("No se pudo recargar el personaje reci√©n creado.")

    # Hooks de post-creaci√≥n
    await channel_service.get_or_create_settings(session, full_character)
    welcome_message = (
        f"¬°Bienvenido al mundo, {full_character.name}! "
        "Usa los comandos de movimiento como <b>/norte</b> o <b>/sur</b> para explorar. "
        "Si necesitas ayuda, puedes preguntar en este canal usando <b>/novato [tu pregunta]</b>. "
        "Para una lista de comandos m√°s detallada, escribe <b>/ayuda</b>."
    )
    await channel_service.broadcast_to_channel(session, "novato", welcome_message)

    await command_service.update_telegram_commands(full_character)

    return full_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala actualizando su `room_id`."""
    # Validaci√≥n: asegurar que la sala de destino existe.
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    # Actualizaci√≥n at√≥mica
    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py
"""
M√≥dulo de Servicio para la Ejecuci√≥n de Scripts.

Este servicio act√∫a como el "traductor" entre el contenido del juego (definido
como strings en los archivos de prototipos) y la l√≥gica del motor (c√≥digo Python).
Permite que los dise√±adores de contenido invoquen funcionalidades del motor
sin necesidad de escribir c√≥digo.

Funciona con un sistema de registro:
1.  Las funciones de script se definen en este archivo.
2.  Se registran en el diccionario `SCRIPT_REGISTRY` con un nombre √∫nico.
3.  Los archivos de prototipos en `game_data` usan ese nombre para referirse a ellas.
4.  El m√©todo `execute_script` se encarga de parsear el string, buscar la
    funci√≥n en el registro y ejecutarla con el contexto adecuado.
"""

import re
import random
import logging
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.character import Character
from src.models.item import Item
from src.models.room import Room
from src.services import broadcaster_service


# ==============================================================================
# SECCI√ìN 1: DEFINICIONES DE LAS FUNCIONES DE SCRIPT
#
# Cada funci√≥n aqu√≠ es una "habilidad" que el motor ofrece a los dise√±adores
# de contenido. Deben ser gen√©ricas y reutilizables.
# ==============================================================================

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """
    Script de evento: Notifica al jugador que un objeto brilla al ser mirado.

    - Disparador T√≠pico: `on_look` en un prototipo de objeto.
    - Contexto Esperado: `character` (quien mira), `target` (el objeto mirado).
    - Argumentos: `color` (str, opcional) - el color del brillo.
    """
    color = kwargs.get("color", "una luz misteriosa")
    message = f"üåü Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."
    await broadcaster_service.send_message_to_character(character, message)


async def script_espada_susurra_secreto(session: AsyncSession, target: Item, character: Character, **kwargs):
    """
    Script de ticker: Hace que un objeto emita un susurro a un personaje activo
    que se encuentre en la misma sala.

    - Disparador T√≠pico: `tickers` en un prototipo de objeto.
    - Contexto Esperado: `target` (el objeto que susurra), `character` (el jugador que escucha).
    - Argumentos: Ninguno.
    """
    secretos = [
        "El tesoro se encuentra bajo la sombra del roble marchito...",
        "La llave oxidada no abre una puerta, sino un coraz√≥n...",
        "Cuidado con el que no proyecta sombra...",
    ]
    secreto_elegido = random.choice(secretos)
    mensaje = f"<i>Un susurro escalofriante parece emanar de {target.get_name()}: \"{secreto_elegido}\"</i>"
    await broadcaster_service.send_message_to_character(character, mensaje)


# ==============================================================================
# SECCI√ìN 2: REGISTRO DE SCRIPTS
#
# Este diccionario es el puente entre los nombres de los scripts (strings)
# y las funciones de Python reales. Para que un script pueda ser llamado
# desde `game_data`, DEBE estar registrado aqu√≠.
# ==============================================================================

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
    "script_espada_susurra_secreto": script_espada_susurra_secreto,
    # Futuros scripts se a√±adir√≠an aqu√≠.
}


# ==============================================================================
# SECCI√ìN 3: EL MOTOR DE EJECUCI√ìN
#
# L√≥gica interna del servicio para interpretar y ejecutar los scripts.
# ==============================================================================

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre(clave=valor, ...)' y devuelve
    el nombre de la funci√≥n y un diccionario de argumentos.

    Limitaci√≥n actual: solo soporta argumentos simples de tipo `clave=valor`.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        # Si el script no tiene par√©ntesis, se asume que no tiene argumentos.
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            logging.warning(f"Argumentos de script mal formados en '{script_string}'. Ignorando argumentos.")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El coraz√≥n del motor de scripts. Parsea el string, busca la funci√≥n en
    el registro y la ejecuta con el contexto proporcionado.

    Args:
        script_string (str): El string del script a ejecutar (ej: "mi_script(arg=val)").
        session (AsyncSession): La sesi√≥n de base de datos activa.
        **context: Un diccionario con las entidades relevantes al evento
                   (ej: `character`, `target`, `room`).
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        try:
            # Ejecutamos la funci√≥n encontrada, pasando el contexto y los argumentos parseados.
            await script_function(session=session, **context, **kwargs)
        except Exception:
            # Si un script falla, registramos el error con un traceback completo
            # pero no detenemos la ejecuci√≥n del resto del juego.
            logging.exception(f"Ocurri√≥ un error al ejecutar el script '{script_name}'")
    else:
        logging.warning(f"ADVERTENCIA: Se intent√≥ ejecutar un script desconocido: '{script_name}'")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/ticker_service.py ===
# src/services/ticker_service.py
"""
M√≥dulo de Servicio para Tareas Programadas (Tickers).

Este servicio es el "coraz√≥n" que hace que el mundo de Runegram se sienta vivo.
Utiliza la librer√≠a APScheduler para ejecutar scripts de forma peri√≥dica,
independientemente de las acciones de los jugadores.

Responsabilidades:
- Inicializar y configurar el scheduler global (APScheduler).
- Cargar las definiciones de tickers desde los prototipos de `game_data`.
- Programar, ejecutar y gestionar el ciclo de vida de estas tareas.
- Determinar el contexto correcto para un ticker (ej: la sala de un objeto)
  y filtrar su ejecuci√≥n (ej: solo para jugadores activos).
"""

import logging
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.db import async_session_factory
from src.services import script_service, online_service, player_service
from src.models import Item, Room, Character

# Instancia √∫nica del scheduler para toda la aplicaci√≥n.
scheduler = AsyncIOScheduler()


# ==============================================================================
# SECCI√ìN DE FUNCIONES AUXILIARES
# ==============================================================================

def parse_schedule(schedule_str: str) -> tuple[str, dict]:
    """
    Parsea el string de schedule del prototipo y lo convierte en argumentos para APScheduler.
    """
    if schedule_str.startswith("interval:"):
        seconds = int(schedule_str.split(':')[1])
        return 'interval', {'seconds': seconds}
    if schedule_str.startswith("date:"):
        date_val = schedule_str.split(':', 1)[1]
        return 'date', {'run_date': date_val}
    cron_expr = schedule_str
    if schedule_str.startswith("cron:"):
        cron_expr = schedule_str.split(':', 1)[1]
    parts = cron_expr.strip().split()
    if len(parts) != 5:
        logging.warning(f"ADVERTENCIA: Expresi√≥n cron mal formada en '{schedule_str}'. Se ignora.")
        return 'cron', {}
    cron_args = { 'minute': parts[0], 'hour': parts[1], 'day': parts[2], 'month': parts[3], 'day_of_week': parts[4] }
    return 'cron', cron_args


async def get_entity_by_id(session: AsyncSession, entity_id: int, entity_type: str):
    """
    Busca una entidad por su ID y tipo, cargando expl√≠citamente las relaciones
    necesarias para evitar errores de carga perezosa.
    """
    MODEL_MAP = {"Item": Item, "Room": Room, "Character": Character}
    model_class = MODEL_MAP.get(entity_type)
    if not model_class:
        logging.warning(f"ADVERTENCIA: Tipo de entidad desconocido '{entity_type}' para ticker.")
        return None

    query = select(model_class)
    if model_class is Item:
        query = query.options(
            selectinload(Item.room),
            selectinload(Item.character).selectinload(Character.room)
        )
    elif model_class is Character:
        query = query.options(selectinload(Character.room), selectinload(Character.account))

    query = query.where(model_class.id == entity_id)
    result = await session.execute(query)
    return result.scalar_one_or_none()


# ==============================================================================
# SECCI√ìN DE INICIALIZACI√ìN Y CARGA
# ==============================================================================

def initialize_scheduler():
    """Configura y arranca el scheduler global. Debe llamarse al iniciar el bot."""
    jobstores = {'default': SQLAlchemyJobStore(url=settings.sync_database_url)}
    scheduler.configure(jobstores=jobstores)
    scheduler.start()
    logging.info("‚è∞ Ticker Service iniciado y listo para programar tareas.")

async def load_and_schedule_all_tickers(session: AsyncSession):
    """
    Busca todas las entidades con tickers en la base de datos (actualmente solo Items)
    y las programa. Debe llamarse una vez al iniciar el bot para asegurar la persistencia.
    """
    logging.info("Cargando y programando tickers para todas las entidades existentes...")
    try:
        result = await session.execute(select(Item))
        all_items = result.scalars().all()
        for item in all_items:
            if item.prototype.get("tickers"):
                logging.info(f"  -> Programando tickers para el item '{item.key}' (ID: {item.id})")
                await schedule_tickers_for_entity(item)
        logging.info("Carga de tickers existentes finalizada.")
    except Exception:
        logging.exception("Error al cargar los tickers de entidades existentes.")


# ==============================================================================
# SECCI√ìN DE EJECUCI√ìN DE TAREAS
# ==============================================================================

async def schedule_tickers_for_entity(entity):
    """
    Lee los tickers del prototipo de una entidad y los a√±ade al scheduler.
    """
    prototype_tickers = entity.prototype.get("tickers", [])
    for ticker_data in prototype_tickers:
        schedule_str = ticker_data.get("schedule")
        script_str = ticker_data.get("script")
        category = ticker_data.get("category", "ambient")

        if not schedule_str or not script_str:
            continue
        trigger_type, trigger_args = parse_schedule(schedule_str)
        if not trigger_args:
            continue

        job_id = f"ticker_{type(entity).__name__}_{entity.id}_{schedule_str}_{script_str}"
        scheduler.add_job(
            execute_ticker_script, trigger=trigger_type,
            args=[entity.id, type(entity).__name__, script_str, category],
            id=job_id, replace_existing=True, **trigger_args
        )

async def execute_ticker_script(entity_id: int, entity_type: str, script_string: str, category: str):
    """
    Funci√≥n que APScheduler llama. Prepara el contexto, comprueba la actividad
    del jugador y delega la ejecuci√≥n al script_service.
    """
    async with async_session_factory() as session:
        try:
            entity = await get_entity_by_id(session, entity_id, entity_type)
            if not entity: return

            # 1. Determinar la sala de contexto del ticker.
            room = None
            if hasattr(entity, 'room') and entity.room:
                room = entity.room
            elif hasattr(entity, 'character') and entity.character and entity.character.room:
                room = entity.character.room

            if not room: return

            # 2. Encontrar los IDs de los personajes en esa sala.
            char_ids_query = select(Character.id).where(Character.room_id == room.id)
            result = await session.execute(char_ids_query)
            char_ids_in_room = result.scalars().all()

            # 3. Iterar sobre cada personaje, aplicar filtros y ejecutar el script.
            for char_id in char_ids_in_room:
                is_online = await online_service.is_character_online(char_id)
                if category == "ambient" and not is_online:
                    continue

                full_character = await player_service.get_character_with_relations_by_id(session, char_id)
                if not full_character:
                    continue

                context = {
                    "target": entity,
                    "room": full_character.room,
                    "character": full_character
                }

                await script_service.execute_script(
                    script_string=script_string,
                    session=session,
                    **context
                )
        except Exception:
            logging.exception(f"Error cr√≠tico en la ejecuci√≥n del ticker para {entity_type} {entity_id}")
# === FIN: src/services/ticker_service.py ===


# === INICIO: src/services/world_loader_service.py ===
# src/services/world_loader_service.py
"""
M√≥dulo de Servicio para la Carga del Mundo.

Este servicio es el responsable de construir y sincronizar el mundo est√°tico del
juego (salas y salidas) con la base de datos. Se ejecuta una sola vez durante
el arranque de la aplicaci√≥n.

Lee las definiciones de contenido desde `game_data/room_prototypes.py` y se
asegura de que el estado de la base de datos refleje fielmente esa "fuente de
la verdad".
"""

import logging
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models import Room, Exit
from game_data.room_prototypes import ROOM_PROTOTYPES

# Mapa de direcciones opuestas para crear autom√°ticamente las salidas bidireccionales.
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def sync_world_from_prototypes(session: AsyncSession):
    """
    Sincroniza la base de datos con los prototipos de salas. Esta funci√≥n es
    idempotente: se puede ejecutar de forma segura en cada arranque.

    Su l√≥gica es:
    1. Crea las salas que no existen y actualiza los datos de las que s√≠ existen.
    2. Borra por completo todas las salidas existentes.
    3. Recrea todas las salidas bas√°ndose en las definiciones actuales.
    """
    logging.info("Sincronizando el mundo est√°tico desde los prototipos...")
    try:
        # --- PASO 1: Sincronizar Salas ---
        # Se asegura de que todas las salas definidas en los prototipos existan en la BD
        # y actualiza su nombre/descripci√≥n. Guarda un mapa de `key` a `id` para el siguiente paso.
        room_key_to_id_map = {}

        # Obtenemos todas las salas existentes de la BD para compararlas.
        existing_rooms_query = await session.execute(select(Room))
        existing_rooms = {room.key: room for room in existing_rooms_query.scalars().all()}

        for key, data in ROOM_PROTOTYPES.items():
            room = existing_rooms.get(key)
            if not room:
                # La sala no existe en la BD, la creamos.
                logging.info(f"  -> Creando sala '{key}'...")
                room = Room(key=key, name=data['name'], description=data['description'])
                session.add(room)
            else:
                # La sala ya existe, actualizamos sus datos por si cambiaron.
                room.name = data['name']
                room.description = data['description']

            # `flush` env√≠a los cambios a la BD sin cerrar la transacci√≥n, lo que
            # nos permite obtener el ID de las nuevas salas antes del commit final.
            await session.flush()
            room_key_to_id_map[key] = room.id

        # --- PASO 2: Limpiar Salidas Viejas ---
        # Es m√°s simple y seguro borrar todas las salidas y recrearlas que intentar
        # parchear las existentes. Esto asegura que las salidas eliminadas de los
        # prototipos tambi√©n se eliminen de la BD.
        logging.info("  -> Limpiando todas las salidas existentes para reconstruir...")
        await session.execute(delete(Exit))

        # --- PASO 3: Crear Salidas Nuevas ---
        # Itera de nuevo sobre los prototipos y crea las filas en la tabla `exits`.
        for key, data in ROOM_PROTOTYPES.items():
            from_room_id = room_key_to_id_map[key]
            for direction, to_room_key in data.get("exits", {}).items():
                if to_room_key in room_key_to_id_map:
                    to_room_id = room_key_to_id_map[to_room_key]

                    # Crear la salida principal (ej: A -> B, "norte")
                    exit_forward = Exit(name=direction.lower(), from_room_id=from_room_id, to_room_id=to_room_id)
                    session.add(exit_forward)

                    # Crear la salida de vuelta autom√°ticamente (ej: B -> A, "sur")
                    opposite = OPPOSITE_DIRECTIONS.get(direction.lower())
                    if opposite:
                        exit_backward = Exit(name=opposite, from_room_id=to_room_id, to_room_id=from_room_id)
                        session.add(exit_backward)
                else:
                    logging.warning(f"  -> La sala de destino '{to_room_key}' definida en la sala '{key}' no existe. Se ignora la salida.")

        await session.commit()
        logging.info("¬°Sincronizaci√≥n del mundo completada!")
    except Exception:
        # Un fallo aqu√≠ es cr√≠tico para el arranque del bot.
        logging.exception("Error fatal durante la sincronizaci√≥n del mundo.")
        # Relanzamos la excepci√≥n para que la funci√≥n on_startup la capture y detenga el bot.
        raise
# === FIN: src/services/world_loader_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py
"""
M√≥dulo de Servicio con Utilidades para el Mundo.

Este servicio contiene funciones de ayuda de bajo nivel para interactuar
con las entidades del mundo, principalmente el modelo `Room`.

A diferencia del `world_loader_service` que construye el mundo al arrancar,
las funciones aqu√≠ presentes son utilidades gen√©ricas que pueden ser llamadas
desde otras partes del c√≥digo, como los comandos.

NOTA: Varias funciones en este archivo (`create_room`, `link_rooms`) han quedado
obsoletas por el sistema de carga de mundo basado en prototipos, pero se
mantienen por si son de utilidad para futuras herramientas de administraci√≥n
o para depuraci√≥n.
"""

import logging
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit


async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """
    Busca y devuelve una sala por su ID num√©rico.

    Args:
        session (AsyncSession): La sesi√≥n de base de datos activa.
        room_id (int): El ID de la sala a buscar.

    Returns:
        Room | None: El objeto de la sala si se encuentra, de lo contrario None.
    """
    try:
        result = await session.execute(select(Room).where(Room.id == room_id))
        return result.scalar_one_or_none()
    except Exception:
        logging.exception(f"Error al buscar la sala con ID {room_id}")
        return None

# ==============================================================================
# Las siguientes funciones han sido mayormente reemplazadas por el sistema de
# carga de mundo (`world_loader_service`) y ya no se usan en el flujo principal.
# Se conservan para posible uso futuro en herramientas de administraci√≥n.
# ==============================================================================

async def create_room(session: AsyncSession, name: str) -> Room:
    """
    (Obsoleto) Crea una nueva sala en la base de datos.
    """
    if not name:
        raise ValueError("El nombre de la sala no puede estar vac√≠o.")
    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """
    (Obsoleto) Actualiza la descripci√≥n de una sala existente.
    """
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """
    (Obsoleto) Crea una salida (y opcionalmente su opuesta) entre dos salas.
    """
    # Mapa de direcciones opuestas, duplicado aqu√≠ para que la funci√≥n sea aut√≥noma.
    OPPOSITE_DIRECTIONS = {
        "norte": "sur", "sur": "norte", "este": "oeste", "oeste": "este",
        "arriba": "abajo", "abajo": "arriba", "dentro": "fuera", "fuera": "dentro",
        "noreste": "suroeste", "suroeste": "noreste", "noroeste": "sureste", "sureste": "noroeste",
    }

    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===
# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py
"""
M√≥dulo de Utilidades de Presentaci√≥n (Presenters).

Este archivo contiene funciones cuya √∫nica responsabilidad es tomar los objetos
de datos del juego (como `Room`, `Item`, `Character`) y convertirlos en texto
formateado listo para ser mostrado al jugador en Telegram.

Esta capa de "presentaci√≥n" separa la l√≥gica de c√≥mo se ven las cosas (formato
HTML, colores, etc.) de la l√≥gica de negocio del juego (que reside en los
servicios).
"""

import logging
from aiogram import types
from collections import Counter

from src.models.room import Room
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripci√≥n completa de una sala para ser
    mostrada al jugador.

    Args:
        room (Room): El objeto de la sala a formatear, con sus relaciones
                     (`items`, `exits_from`) ya cargadas.

    Returns:
        str: Un string formateado con HTML (`<pre>`, `<b>`) listo para ser enviado.
    """
    try:
        parts = []

        # 1. T√≠tulo de la Sala
        parts.append(f"<b>{room.name}</b>")

        # 2. Descripci√≥n principal
        parts.append(room.description.strip())

        # 3. Objetos en la sala
        if room.items:
            # Usamos `collections.Counter` para agrupar objetos id√©nticos.
            # Por ejemplo, tres objetos con `get_name()`="una moneda de oro"
            # se mostrar√°n como "una moneda de oro (3)".
            item_names = [item.get_name() for item in room.items]
            item_counts = Counter(item_names)
            formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
            items_str = ", ".join(formatted_items)
            parts.append(f"\n<b>Ves aqu√≠:</b> {items_str}.")

        # 4. Salidas
        if room.exits_from:
            # Ordenamos las salidas alfab√©ticamente para una visualizaci√≥n consistente.
            exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
            exits_str = ", ".join(exits_list)
            parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
        else:
            parts.append("\n<b>Salidas:</b> [ Ninguna ]")

        # Unimos todas las partes y las envolvemos en una etiqueta <pre>
        # para mantener el formato de monoespaciado y los saltos de l√≠nea.
        description_body = "\n".join(parts)
        return f"<pre>{description_body}</pre>"

    except Exception:
        logging.exception(f"Error al formatear la descripci√≥n de la sala ID {room.id}")
        return "<pre><b>Error:</b> No se pudo mostrar la descripci√≥n de la sala.</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripci√≥n formateada.
    Esta funci√≥n centraliza la l√≥gica com√∫n de "mirar" el entorno.
    """
    try:
        async with async_session_factory() as session:
            # Usamos el servicio para obtener la cuenta y sus relaciones precargadas.
            account = await player_service.get_or_create_account(session, message.from_user.id)

            if not account or not account.character or not account.character.room:
                # Esta es una salvaguarda. No deber√≠a ocurrir en un flujo normal.
                await message.answer("Parece que est√°s perdido en el vac√≠o. Te hemos llevado a un lugar seguro.")
                # Futuro: Aqu√≠ podr√≠amos teletransportar al jugador a la sala de inicio.
                return

            room = account.character.room
            # Usamos nuestro formateador para construir el texto de la sala.
            formatted_room = await format_room(room)

            await message.answer(formatted_room, parse_mode="HTML")

    except Exception:
        await message.answer("‚ùå Ocurri√≥ un error al mostrar tu ubicaci√≥n actual.")
        logging.exception(f"Fallo en show_current_room para el usuario {message.from_user.id}")
# === FIN: src/utils/presenters.py ===


