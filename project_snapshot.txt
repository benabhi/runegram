# === Archivos Raíz ===

# === INICIO: .gitignore ===
# Archivos de Entorno
# Contiene secretos y configuraciones locales. ¡Nunca subir a Git!
.env
.env.*

# Dependencias y Entornos Virtuales
# Estos se pueden reinstalar usando requirements.txt
venv/
.venv/
env/
.env/
env.bak/
venv.bak/

# Artefactos y Caché de Python
# Archivos generados por Python que no son necesarios en el repositorio
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Caché de pytest
.pytest_cache/
.coverage
.coverage.*
htmlcov/
.tox/

# Bases de datos locales
# Si usas SQLite para pruebas locales, no querrás subir la base de datos
*.sqlite3
*.db

# Archivos de IDE y editores de código
# Configuraciones específicas del entorno de desarrollo de cada persona
.idea/
.vscode/
*.swp
*~
*.sublime-project
*.sublime-workspace

# Archivos de Sistema Operativo
# Archivos generados por macOS, Windows y Linux que no son parte del proyecto
.DS_Store
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/

# Logs
# No es una buena práctica subir archivos de logs al repositorio
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Archivos generados por Docker
# A veces se pueden generar archivos locales al trabajar con Docker
.dockerignore
docker-compose.override.yml
# === FIN: .gitignore ===


# === INICIO: alembic.ini ===
# alembic.ini

# ==============================================================================
# SECCIÓN PRINCIPAL DE ALEMBIC
# Aquí se definen las configuraciones más importantes.
# ==============================================================================
[alembic]

# --- Ubicación de los Scripts de Migración ---
# Esta es la ruta a la carpeta que contiene el entorno de Alembic.
# En nuestro caso, es la carpeta "alembic" en la raíz del proyecto.
script_location = alembic

# --- URL de la Base de Datos ---
# ESTA ES LA LÍNEA MÁS IMPORTANTE.
# Le dice a Alembic cómo conectarse a tu base de datos PostgreSQL.
# La magia aquí es que no ponemos la contraseña directamente.
# El archivo `alembic/env.py` se encargará de leer esta URL
# desde nuestras variables de entorno (del archivo .env) para mantener
# los secretos seguros.
sqlalchemy.url = postgresql+asyncpg://user:password@host:port/database

# --- Plantillas para Nuevos Archivos ---
# Define cómo se nombran los nuevos archivos de migración.
# {rev} es el ID de la revisión, {slug} es el mensaje descriptivo.
# El formato por defecto es perfecto.
# Ejemplo: 2d19...._crear_tablas_de_cuentas.py
file_template = %%(rev)s_%%(slug)s

# --- Otras Configuraciones ---
# huso horario para los nombres de archivo, etc.
# No es necesario tocar esto.
timezone =

# ==============================================================================
# HOOKS POST-ESCRITURA (Opcional pero recomendado)
# Permite ejecutar comandos después de que se genera un nuevo archivo de migración.
# Es muy útil para formatear automáticamente el código con herramientas
# como 'black' o 'ruff'. Por ahora, lo dejamos comentado.
# ==============================================================================
[post_write_hooks]
# hooks = ruff
# ruff.type = ruff
# ruff.options = --fix %%(path)s

# ==============================================================================
# CONFIGURACIÓN DE LOGGING
# Define cómo se muestran los mensajes de Alembic en la consola.
# No necesitas modificar nada aquí, la configuración por defecto es excelente.
# ==============================================================================
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
# === FIN: alembic.ini ===


# === INICIO: docker-compose.yml ===
# docker-compose.yml

services:
  bot:
    # Construye la imagen a partir del Dockerfile en el directorio actual
    build: .

    # --- INICIO DE LA MODIFICACIÓN ---
    # 1. ENTRYPOINT: Especifica el script que se ejecutará al iniciar el contenedor.
    #    Nuestro script /app/entrypoint.sh se encargará de esperar a la BD
    #    y ejecutar las migraciones.
    entrypoint: /app/entrypoint.sh

    # 2. COMMAND: Este comando ya no se ejecuta directamente. En su lugar,
    #    se pasa como argumento a nuestro entrypoint.sh. El script lo
    #    ejecutará al final con 'exec "$@"'.
    command: python run.py
    # --- FIN DE LA MODIFICACIÓN ---

    environment:
      - PYTHONPATH=/app

    # Carga las variables de entorno desde el archivo .env
    env_file:
      - .env

    # Se asegura de que postgres y redis se inicien antes que el bot
    depends_on:
      - postgres
      - redis

    # Mapea tu código local al contenedor para ver los cambios al instante
    volumes:
      - ./src:/app/src
      - ./commands:/app/commands
      - ./game_data:/app/game_data
      - ./run.py:/app/run.py
      - ./alembic:/app/alembic
      - ./alembic.ini:/app/alembic.ini
      # También mapeamos el entrypoint para poder modificarlo sin reconstruir
      - ./entrypoint.sh:/app/entrypoint.sh

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
# === FIN: docker-compose.yml ===


# === INICIO: Dockerfile ===
# Dockerfile
# Usamos alpine, que es muy ligero, por lo que tenemos que añadir paquetes
FROM python:3.11-alpine

# Instalamos netcat (viene en el paquete 'netcat-openbsd') y git
RUN apk add --no-cache netcat-openbsd git

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiamos nuestro script de entrada y nos aseguramos de que es ejecutable
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh

COPY . .

# El entrypoint se define en docker-compose.yml,
# el CMD es el comando que se le pasa.
CMD ["python", "run.py"]
# === FIN: Dockerfile ===


# === INICIO: requirements.txt ===
aiogram==2.25.1
SQLAlchemy==2.0.21
alembic==1.12.0
asyncpg==0.28.0
redis==4.6.0
pydantic==1.10.12
python-dotenv==1.0.0
python-dateutil
# === FIN: requirements.txt ===


# === INICIO: run.py ===
# run.py
import logging
# Ya no necesitamos sys ni Path para esto

from aiogram import executor
from src.bot.dispatcher import dp

# Esta importación ahora funcionará gracias al PYTHONPATH de Docker
import src.handlers

async def on_startup(dispatcher):
    logging.info("Bot iniciando...")

async def on_shutdown(dispatcher):
    logging.warning("Bot deteniéndose...")

def main():
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)

if __name__ == "__main__":
    import sys # Lo necesitamos para el logging
    main()
# === FIN: run.py ===


# === INICIO: README.md ===
# Runegram MUD

![Python](https://img.shields.io/badge/python-3.11-blue.svg)![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)![PostgreSQL](https://img.shields.io/badge/postgresql-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

Runegram es un proyecto para crear un juego de rol textual multijugador (MUD - Multi-User Dungeon) que se juega a través de la interacción con un bot de Telegram. Este repositorio contiene el motor de un juego funcional, con una arquitectura escalable lista para la expansión masiva de contenido.

## Filosofía de Diseño: Motor vs. Contenido

La arquitectura del proyecto se divide en dos conceptos clave para máxima escalabilidad y facilidad de mantenimiento:

1.  **El Motor del Juego (`src/`):** Contiene el **código fuente** de la aplicación. Es la maquinaria genérica que hace que el juego funcione (conexión a la base de datos, comunicación con Telegram, ejecución de lógica). No sabe qué es una "espada", solo sabe cómo manejar un "Ítem".
2.  **El Contenido del Juego (`game_data/`, `commands/`):** Contiene los **datos y definiciones** que dan vida al mundo. Aquí se define qué es una "espada", qué hace el comando "atacar", o qué monstruos existen. Está diseñado para que los diseñadores de juego puedan añadir contenido sin tocar el motor principal.

## Sistemas Clave Implementados

### 1. Sistema de Comandos Unificado
Todos los comandos (de jugador y de administrador) están implementados como clases que heredan de una `Command` base.
*   **Command Sets:** Los comandos se agrupan en `Command Sets` (ej: `general`, `interaction`, `building`), que son listas de instancias de comandos.
*   **Dispatcher Central:** Un único handler en `src/handlers/player/dispatcher.py` intercepta todos los mensajes, determina qué `Command Sets` están activos para el jugador, busca el comando correspondiente y lo ejecuta. Esto hace que añadir nuevos comandos sea tan simple como crear una nueva clase y añadirla a una lista.

### 2. Sistema de Prototipos
Para separar los datos del código, las entidades del juego como los objetos se definen usando un sistema de prototipos.
*   **Definición (`game_data/`):** Se crea una "plantilla" para cada tipo de objeto en un diccionario de Python (ej: `ITEM_PROTOTYPES`). Esta plantilla contiene todos los datos base: nombre, descripción, `keywords` para búsqueda, y scripts de eventos.
*   **Instancia (Base de Datos):** La base de datos no almacena todos estos datos. La tabla `items` solo guarda una "instancia" ligera que apunta a la `key` del prototipo (ej: `espada_corta`) y cualquier dato que sea único para esa copia específica (como `name_override`).
*   **Ventaja:** Para crear 100 tipos de espadas, solo necesitas añadir 100 entradas al diccionario de prototipos, sin modificar la base de datos ni la lógica del motor.

### 3. Sistema de Eventos (Scripts)
El motor está preparado para que el contenido del juego pueda ejecutar lógica del motor a través de un sistema de scripts.
*   **Disparadores (Triggers):** Los prototipos pueden definir scripts para eventos específicos (ej: `"on_look": "script_nombre(...)"`).
*   **Script Service:** Un servicio central (`script_service.py`) mantiene un registro de todas las funciones de script disponibles.
*   **Ejecución:** Cuando un evento ocurre en el juego (ej: un jugador mira un objeto), el motor busca si el prototipo del objeto tiene un script para ese evento. Si lo tiene, llama al `Script Service` para que ejecute la función de lógica correspondiente.
*   **Implementado:** `on_look` para ítems.

## Estructura del Proyecto

```
runegram/
├── alembic/              # Migraciones de la base de datos
├── commands/             # DEFINICIÓN de los comandos (clases Command)
│   ├── admin/
│   └── player/
├── game_data/            # DEFINICIÓN de prototipos (items, NPCs, etc.)
├── scripts/              # Scripts de utilidad (ej: full_reset.bat)
├── src/                  # CÓDIGO FUENTE del motor de la aplicación
│   ├── bot/              # Configuración del bot y dispatcher central de Aiogram
│   ├── config.py         # Carga de variables de entorno
│   ├── db.py             # Configuración del motor de SQLAlchemy
│   ├── handlers/         # Punto de entrada de Telegram a la app
│   │   └── player/
│   │       └── dispatcher.py # El dispatcher/router de comandos principal
│   ├── models/           # Modelos de datos de SQLAlchemy
│   ├── services/         # Lógica de negocio y acceso a datos
│   └── utils/            # Funciones de ayuda (ej: presenters)
├── .env                  # Archivo de variables de entorno (ignorado)
├── docker-compose.yml    # Orquestación de los contenedores
├── Dockerfile            # Definición de la imagen Docker de la app
├── entrypoint.sh         # Script de arranque que ejecuta migraciones
└── run.py                # Punto de entrada para iniciar la aplicación
```

## Puesta en Marcha

Se necesita Docker y Docker Compose.

1.  **Configurar el Entorno:** Crea un archivo `.env` en la raíz del proyecto.
2.  **Ejecutar el Script de Reinicio:** Para asegurar un entorno limpio, usa el script automatizado.
    ```bash
    # En Windows (CMD o PowerShell)
    scripts\full_reset.bat
    ```
    Este script reconstruirá la imagen, levantará los servicios y aplicará todas las migraciones.
3.  **Jugar:** Abre Telegram y envía `/start` a tu bot.

---

## Visión a Futuro y Tareas Pendientes (TODO)

Esta sección documenta las próximas mejoras para evolucionar de un esqueleto funcional a un juego completo.

### 🚀 **Próximas Grandes Funcionalidades**

*   #### Terminar el Sistema de Locks y Permisos
    *   **Visión:** Crear un sistema de permisos granular para controlar el acceso a salidas, objetos y comandos.
    *   **Tareas:**
        1.  **Expandir el Parser de Locks:** Mejorar `permission_service` para que entienda una sintaxis más rica: `tiene_objeto(llave_oxidada)`, `habilidad(forzar_cerraduras)>25`, `clase(guerrero)`. Implementar operadores lógicos `y` / `o`.
        2.  **Crear Comandos de Admin:** Añadir `/lock [salida] con [string_de_lock]` y `/unlock [salida]` para que los constructores puedan asegurar partes del mundo.
        3.  **Integrar en el Juego:** Aplicar la verificación de `locks` en el dispatcher de movimiento.

*   #### Sistema de Interacción Detallada (`mirar`)
    *   **Visión:** Permitir al jugador examinar en detalle cualquier entidad del juego (objetos, otros jugadores, NPCs, elementos de la sala).
    *   **Tareas:**
        1.  **Refactorizar `CmdLook`:** El comando `/mirar [objetivo]` ya busca objetos. Se debe expandir para que pueda identificar a otros jugadores y NPCs en la sala.
        2.  **Palabras Clave en la Sala:** Implementar un sistema para que la descripción de una sala pueda tener `keywords` que, al ser "miradas", revelen información adicional sin ser objetos físicos.

*   #### Definir y Construir el Sistema de Combate y Habilidades
    *   **Visión:** Crear un sistema de combate y progresión de habilidades basado en una mecánica de d100 (tirada de 100 caras).
    *   **Tareas:**
        1.  **Modelos de Datos:** Crear los modelos `Skill` y `CharacterSkill`. Añadir atributos de combate (Salud, Maná, etc.) al modelo `Character`.
        2.  **Mecánica d100:** Implementar la lógica central de "aprender haciendo": una acción tiene éxito si `d100 <= nivel_de_habilidad`, y al tener éxito, se gana experiencia.
        3.  **Comandos de Combate:** Crear el `CommandSet` de combate con comandos básicos como `/atacar [objetivo]`.
        4.  **Crear Prototipos de NPCs:** Añadir un archivo `npc_prototypes.py` en `game_data` y un modelo `NPC` para poder "spawnear" monstruos en el mundo.

### ✨ **Sugerencias Adicionales para el Futuro**

*   **Gestión de `CommandSets` Dinámica:** Implementar la lógica para que el `dispatcher` lea los `command_sets` del personaje desde la base de datos, y añadir/quitar sets basados en el equipo o la sala.
*   **Broadcasting de Mensajes:** Mejorar el comando `/decir` y las acciones de combate para que los mensajes sean vistos por todos los jugadores en la misma sala, creando una verdadera interacción social.
*   **Sistema de Clases y Razas:** Usar el sistema de **FSM (Máquina de Estados Finitos)** para guiar al jugador a través de una creación de personaje por pasos, permitiéndole elegir clase y raza.
*   **Persistencia de NPCs y "Respawns":** Crear un sistema para que los monstruos y NPCs reaparezcan después de un tiempo de ser derrotados.
*   **Sistema de Contenedores:** Expandir los ítems para que puedan ser contenedores (ej: una mochila, un cofre) con su propio inventario y `locks`.

# === FIN: README.md ===



# === Contenido del Directorio: src ===

# === INICIO: src/__init__.py ===

# === FIN: src/__init__.py ===


# === INICIO: src/config.py ===

from pydantic import BaseSettings, SecretStr

class Settings(BaseSettings):
    bot_token: SecretStr

    # Database
    postgres_user: str
    postgres_password: str
    postgres_db: str
    postgres_host: str
    postgres_port: int

    # Redis
    redis_host: str
    redis_port: int
    redis_db: int

    @property
    def database_url(self) -> str:
        return (
            f"postgresql+asyncpg://"
            f"{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    class Config:
        env_file = '.env'
        env_file_encoding = 'utf-8'

settings = Settings()
# === FIN: src/config.py ===


# === INICIO: src/db.py ===
# src/db.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.config import settings

# Creamos el motor de la base de datos asíncrono
async_engine = create_async_engine(
    settings.database_url,
    echo=False, # Ponlo en True para ver las queries SQL en la consola
)

# Creamos una fábrica de sesiones asíncronas
async_session_factory = async_sessionmaker(
    async_engine,
    expire_on_commit=False
)
# === FIN: src/db.py ===


# === INICIO: src/bot/__init__.py ===

# === FIN: src/bot/__init__.py ===


# === INICIO: src/bot/bot.py ===
from aiogram import Bot

from src.config import settings

bot = Bot(token=settings.bot_token.get_secret_value())
# === FIN: src/bot/bot.py ===


# === INICIO: src/bot/dispatcher.py ===
# src/bot/dispatcher.py

from aiogram import Dispatcher
from aiogram.contrib.fsm_storage.redis import RedisStorage2

from src.config import settings
from src.bot.bot import bot

# Creamos el almacenamiento de estados con la configuración de Redis
storage = RedisStorage2(host=settings.redis_host, port=settings.redis_port, db=settings.redis_db)

# Creamos la instancia principal del Dispatcher que se usará en todo el proyecto
dp = Dispatcher(bot, storage=storage)
# === FIN: src/bot/dispatcher.py ===


# === INICIO: src/handlers/__init__.py ===
from . import player
# === FIN: src/handlers/__init__.py ===


# === INICIO: src/handlers/player/__init__.py ===
# src/handlers/player/__init__.py
from . import dispatcher
# === FIN: src/handlers/player/__init__.py ===


# === INICIO: src/handlers/player/dispatcher.py ===
# src/handlers/player/dispatcher.py
from aiogram import types
from src.bot.dispatcher import dp
from src.db import async_session_factory
from src.services import player_service, permission_service
from commands.player.general import GENERAL_COMMANDS
from commands.player.character import CHARACTER_COMMANDS
from commands.player.interaction import INTERACTION_COMMANDS
from commands.admin.building import BUILDING_COMMANDS
from commands.admin.movement import ADMIN_MOVEMENT_COMMANDS
from src.utils.presenters import show_current_room
from sqlalchemy.ext.asyncio import AsyncSession

# --- El Router de Command Sets ---
COMMAND_SETS = {
    "general": GENERAL_COMMANDS,
    "character_creation": CHARACTER_COMMANDS,
    "interaction": INTERACTION_COMMANDS,
    "building": BUILDING_COMMANDS,
    "admin_movement": ADMIN_MOVEMENT_COMMANDS,
}

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def main_command_dispatcher(message: types.Message):
    """
    Este es el dispatcher principal. Captura todo el texto, lo interpreta
    y lo dirige a la lógica correspondiente (movimiento o comando).
    """
    async with async_session_factory() as session:
        account = await player_service.get_or_create_account(session, message.from_user.id)
        character = account.character
        input_text = message.text.strip() # Usamos strip() al principio

        # --- Manejo especial para /start ---
        if input_text.lower().startswith('/start'):
            if character is None:
                await message.answer(
                    "¡Bienvenido a Runegram! Veo que eres nuevo por aquí. "
                    "Para empezar, necesitas crear tu personaje. Usa el comando "
                    "/crearpersonaje [nombre] para darle vida a tu aventurero."
                )
            else:
                await show_current_room(message)
            return

        # --- Protección para usuarios sin personaje ---
        if not character:
            allowed_cmds = ["/crearpersonaje"]
            # Extraemos el comando para compararlo
            cmd_name_only = input_text.split()[0].lower()
            if cmd_name_only not in allowed_cmds:
                return await message.answer("Primero debes crear un personaje con /crearpersonaje.")

        # --- Lógica de Movimiento (Prioridad 1) ---
        if not input_text.startswith('/'):
            command_as_exit = next(
                (exit_obj for exit_obj in character.room.exits_from if exit_obj.name == input_text.lower()),
                None
            )
            if command_as_exit:
                await player_service.teleport_character(session, character.id, command_as_exit.to_room_id)
                await show_current_room(message)
                return

        # --- Lógica del Parser de Comandos (Prioridad 2) ---
        if not input_text.startswith('/'):
             return await message.answer("No entiendo ese comando. Los comandos empiezan con / (ej: /mirar) o son salidas (ej: norte).")

        cmd_name = message.get_command(pure=True).lower()
        args = message.get_args().split() if message.get_args() else []

        found_cmd = None
        active_sets_names = ["general", "interaction"]
        if not character:
            active_sets_names.append("character_creation")
        if account.role == "ADMINISTRADOR":
            active_sets_names.extend(["building", "admin_movement"])

        for set_name in active_sets_names:
            if set_name in COMMAND_SETS:
                for cmd_instance in COMMAND_SETS[set_name]:
                    if cmd_name in cmd_instance.names:
                        found_cmd = cmd_instance
                        break
            if found_cmd:
                break

        if not found_cmd:
            return await message.answer("No conozco ese comando.")

        can_run, error_message = await permission_service.can_execute(character, found_cmd.lock)
        if not can_run:
            return await message.answer(error_message or "No puedes hacer eso.")

        try:
            await found_cmd.execute(character, session, message, args)
        except Exception as e:
            await message.answer("Ocurrió un error al ejecutar ese comando.")
            print(f"Error ejecutando /{cmd_name}: {e}")
# === FIN: src/handlers/player/dispatcher.py ===


# === INICIO: src/models/__init__.py ===
# src/models/__init__.py

from .base import Base
from .account import Account
from .character import Character
from .room import Room
from .item import Item
from .exit import Exit
# === FIN: src/models/__init__.py ===


# === INICIO: src/models/account.py ===
# src/models/account.py
from sqlalchemy import BigInteger, Column, String
from sqlalchemy.orm import relationship

from .base import Base

class Account(Base):
    __tablename__ = 'accounts'

    id = Column(BigInteger, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    role = Column(String, default='JUGADOR', nullable=False)

    # Relación: Una cuenta tiene un personaje
    # Usamos el string completo 'src.models.character.Character'
    character = relationship("src.models.character.Character", back_populates="account", uselist=False)

    def __repr__(self):
        return f"<Account(id={self.id}, telegram_id={self.telegram_id})>"
# === FIN: src/models/account.py ===


# === INICIO: src/models/base.py ===
# src/models/base.py
from sqlalchemy.orm import declarative_base

Base = declarative_base()
# === FIN: src/models/base.py ===


# === INICIO: src/models/character.py ===
# src/models/character.py
from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB
from .base import Base

class Character(Base):
    __tablename__ = 'characters'

    id = Column(BigInteger, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)

    # --- Relaciones ---
    account_id = Column(BigInteger, ForeignKey('accounts.id'), nullable=False, unique=True)
    account = relationship("src.models.account.Account", back_populates="character")

    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)
    # Usamos el string 'src.models.room.Room'
    room = relationship("src.models.room.Room")

    # Usamos el string 'src.models.item.Item'
    items = relationship("src.models.item.Item", back_populates="character")

    command_sets = Column(JSONB, nullable=False, server_default='["general"]', default=["general"])
# === FIN: src/models/character.py ===


# === INICIO: src/models/exit.py ===
# src/models/exit.py

from sqlalchemy import BigInteger, Column, String, ForeignKey
from sqlalchemy.orm import relationship

from .base import Base

class Exit(Base):
    """
    Representa una salida unidireccional desde una sala a otra.
    """
    __tablename__ = 'exits'

    id = Column(BigInteger, primary_key=True)

    # El nombre que el jugador escribe para usar la salida (ej: "norte", "puerta de roble")
    name = Column(String(50), nullable=False, index=True)

    # De qué sala parte esta salida
    from_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)
    # A qué sala lleva esta salida
    to_room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=False)

    # El string de lock para esta salida específica
    locks = Column(String, nullable=False, default="")

    # Relación para poder acceder a la sala de origen
    from_room = relationship("src.models.room.Room", foreign_keys=[from_room_id], back_populates="exits_from")

    # Relación para poder acceder a la sala de destino (útil para validaciones)
    # --- LÍNEA MODIFICADA ---
    to_room = relationship("src.models.room.Room", foreign_keys=[to_room_id], back_populates="exits_to")
# === FIN: src/models/exit.py ===


# === INICIO: src/models/item.py ===
# src/models/item.py

from sqlalchemy import BigInteger, Column, String, Text, ForeignKey
from sqlalchemy.orm import relationship
from game_data.item_prototypes import ITEM_PROTOTYPES # <-- Importa los prototipos

from .base import Base

class Item(Base):
    """
    Representa una instancia de un objeto en el mundo.
    """
    __tablename__ = 'items'

    id = Column(BigInteger, primary_key=True)
    key = Column(String(50), nullable=False, index=True)
    name_override = Column(String(100), nullable=True)
    description_override = Column(Text, nullable=True)
    room_id = Column(BigInteger, ForeignKey('rooms.id'), nullable=True)
    character_id = Column(BigInteger, ForeignKey('characters.id'), nullable=True)

    room = relationship("src.models.room.Room", back_populates="items")
    character = relationship("src.models.character.Character", back_populates="items")

    @property
    def prototype(self):
        """Devuelve el diccionario del prototipo para este objeto."""
        return ITEM_PROTOTYPES.get(self.key, {})

    def get_name(self) -> str:
        """Obtiene el nombre del item, usando override o el prototipo."""
        return self.name_override or self.prototype.get("name", "un objeto misterioso")

    def get_description(self) -> str:
        """Obtiene la descripción del item, usando override o el prototipo."""
        return self.description_override or self.prototype.get("description", "No tiene nada de especial.")

    def get_keywords(self) -> list[str]:
        """Obtiene las keywords del item desde el prototipo."""
        return self.prototype.get("keywords", [])
# === FIN: src/models/item.py ===


# === INICIO: src/models/room.py ===
# src/models/room.py

from sqlalchemy import BigInteger, Column, String, Text
from sqlalchemy.orm import relationship

from .base import Base

class Room(Base):
    __tablename__ = 'rooms'

    id = Column(BigInteger, primary_key=True)
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False, default="Esta es una sala sin describir.")
    locks = Column(String, nullable=False, default="")

    # Relaciones existentes
    items = relationship("src.models.item.Item", back_populates="room")

    # --- RELACIONES PARA SALIDAS ---
    # Una lista de todas las salidas QUE PARTEN DE ESTA SALA.
    exits_from = relationship("src.models.exit.Exit", foreign_keys="[Exit.from_room_id]", back_populates="from_room", cascade="all, delete-orphan")

    # Una lista de todas las salidas QUE LLEGAN A ESTA SALA.
    # --- LÍNEA MODIFICADA ---
    exits_to = relationship("src.models.exit.Exit", foreign_keys="[Exit.to_room_id]", back_populates="to_room", cascade="all, delete-orphan")
# === FIN: src/models/room.py ===


# === INICIO: src/services/__init__.py ===

# === FIN: src/services/__init__.py ===


# === INICIO: src/services/broadcaster.py ===

# === FIN: src/services/broadcaster.py ===


# === INICIO: src/services/item_service.py ===
# src/services/item_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.item import Item
# No necesitamos Character y Room aquí directamente
# from src.models.character import Character
# from src.models.room import Room
from game_data.item_prototypes import ITEM_PROTOTYPES


async def spawn_item_in_room(session: AsyncSession, room_id: int, item_key: str) -> Item:
    """
    Crea una instancia de un prototipo de objeto y la coloca en una sala.
    """
    if item_key not in ITEM_PROTOTYPES:
        raise ValueError(f"No existe un prototipo de objeto con la clave '{item_key}'")

    # Creamos una nueva instancia de Item, solo guardando la key y su ubicación.
    new_item = Item(room_id=room_id, key=item_key)
    session.add(new_item)
    await session.commit()
    await session.refresh(new_item)
    return new_item


async def move_item_to_character(session: AsyncSession, item_id: int, character_id: int):
    """Mueve un objeto desde una sala al inventario de un personaje."""
    query = update(Item).where(Item.id == item_id).values(
        room_id=None,
        character_id=character_id
    )
    await session.execute(query)
    await session.commit()


async def move_item_to_room(session: AsyncSession, item_id: int, room_id: int):
    """Mueve un objeto desde el inventario de un personaje a una sala."""
    query = update(Item).where(Item.id == item_id).values(
        room_id=room_id,
        character_id=None
    )
    await session.execute(query)
    await session.commit()
# === FIN: src/services/item_service.py ===


# === INICIO: src/services/permission_service.py ===
# src/services/permission_service.py
from src.models.character import Character


def _check_role(character: Character, required_role: str) -> bool:
    """Verifica si el personaje tiene el rol requerido."""
    return character.account.role.upper() == required_role.upper()


async def can_execute(character: Character, lock_string: str) -> tuple[bool, str]:
    """
    Verifica si un personaje puede pasar un lock.
    Devuelve una tupla: (puede_pasar, mensaje_de_error).
    """
    if not lock_string:
        return True, ""  # Un lock vacío siempre se puede pasar.

    # Lógica AND: todas las funciones de lock deben ser verdaderas.
    lock_functions = lock_string.lower().split(' y ')

    for func in lock_functions:
        # Por ahora, solo implementamos la función 'rol(argumento)'
        if func.startswith('rol(') and func.endswith(')'):
            required_role = func[4:-1]
            if not _check_role(character, required_role):
                # Devolvemos un mensaje de error específico
                return False, "No tienes el rango necesario."
        else:
            # Si encontramos una función de lock que no entendemos, por seguridad, fallamos.
            print(f"ADVERTENCIA: Función de lock desconocida: {func}")
            return False, "Esa acción está bloqueada por una fuerza desconocida."

    # Si el personaje pasó todos los chequeos de la cadena AND
    return True, ""
# === FIN: src/services/permission_service.py ===


# === INICIO: src/services/player_service.py ===
# src/services/player_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.account import Account
from src.models.character import Character
from src.models.room import Room
from src.models.item import Item
from src.models.exit import Exit


async def get_or_create_account(session: AsyncSession, telegram_id: int) -> Account:
    """
    Busca una cuenta por su telegram_id. Si no existe, la crea.
    Devuelve el objeto de la cuenta con sus relaciones ya cargadas.
    """
    # --- LÓGICA SIMPLIFICADA Y CORREGIDA ---

    # 1. Intentamos encontrar la cuenta
    # Definimos la estrategia de carga aquí para aplicarla si encontramos la cuenta.
    load_strategy = select(Account).options(
        selectinload(Account.character).selectinload(Character.room).selectinload(Room.items),
        selectinload(Account.character).selectinload(Character.room).selectinload(Room.exits_from),
        selectinload(Account.character).selectinload(Character.items)
    )
    query = load_strategy.where(Account.telegram_id == telegram_id)
    result = await session.execute(query)
    account = result.scalar_one_or_none()

    # 2. Si la cuenta existe, la devolvemos. Viene con todo precargado.
    if account:
        return account

    # 3. Si no existe, la creamos y la devolvemos.
    # El objeto devuelto estará "fresco" y sus relaciones (como .character)
    # serán None por defecto, lo cual es el estado correcto para una nueva cuenta.
    print(f"Creando nueva cuenta para el telegram_id: {telegram_id}")
    new_account = Account(telegram_id=telegram_id)
    session.add(new_account)
    await session.commit()
    await session.refresh(new_account) # Usamos refresh para obtener el ID y roles por defecto

    return new_account


async def create_character(session: AsyncSession, telegram_id: int, character_name: str) -> Character:
    """
    Crea un nuevo personaje y lo asocia a una cuenta existente.
    Lanza una excepción si la cuenta no existe, ya tiene un personaje,
    o el nombre del personaje ya está en uso.
    """
    # 1. Buscamos la cuenta.
    account = await get_or_create_account(session, telegram_id)

    # 2. Verificamos que la cuenta no tenga ya un personaje
    if account.character is not None:
        raise ValueError("Ya tienes un personaje asociado a esta cuenta.")

    # 3. Verificamos que el nombre no esté en uso
    result = await session.execute(select(Character).where(Character.name == character_name))
    if result.scalar_one_or_none():
        raise ValueError(f"El nombre '{character_name}' ya está en uso. Por favor, elige otro.")

    # 4. Creamos el nuevo personaje
    new_character = Character(
        name=character_name,
        account_id=account.id,
        room_id=1
    )
    session.add(new_character)
    await session.commit()

    # 5. Expiramos la instancia de 'account' para forzar una recarga completa
    # la próxima vez que se necesite, asegurando que la relación .character se actualice.
    session.expire(account)

    await session.refresh(new_character)
    return new_character


async def teleport_character(session: AsyncSession, character_id: int, to_room_id: int):
    """Mueve un personaje a una nueva sala."""
    # Verificamos que la sala de destino exista
    result = await session.execute(select(Room).where(Room.id == to_room_id))
    if not result.scalar_one_or_none():
        raise ValueError(f"La sala con ID {to_room_id} no existe.")

    # Actualizamos la room_id del personaje
    query = update(Character).where(Character.id == character_id).values(room_id=to_room_id)
    await session.execute(query)
    await session.commit()
# === FIN: src/services/player_service.py ===


# === INICIO: src/services/script_service.py ===
# src/services/script_service.py

import re
from sqlalchemy.ext.asyncio import AsyncSession
from src.models.character import Character
from src.models.item import Item

# En el futuro, este podría ser un broadcaster más complejo.
# Por ahora, es una función simple para enviar mensajes al jugador.
async def _send_message_to_character(character: Character, message_text: str):
    from src.bot.bot import bot
    await bot.send_message(chat_id=character.account.telegram_id, text=message_text)


# --- Definiciones de las Funciones de Script ---

async def script_notificar_brillo_magico(session: AsyncSession, character: Character, target: Item, **kwargs):
    """Un script que notifica al jugador que un objeto brilla al ser mirado."""
    color = kwargs.get("color", "una luz misteriosa")
    message = f"🌟 Al fijar tu vista en {target.get_name()}, notas que emite un suave brillo de color {color}."
    await _send_message_to_character(character, message)


# --- El "Motor" de Scripts ---

SCRIPT_REGISTRY = {
    "script_notificar_brillo_magico": script_notificar_brillo_magico,
}

def _parse_script_string(script_string: str) -> tuple[str, dict]:
    """
    Parsea un string de script como 'nombre_script(key1=val1, key2=val2)'
    y devuelve el nombre y un diccionario de argumentos.
    """
    match = re.match(r"(\w+)\((.*)\)", script_string)
    if not match:
        return script_string, {}

    name, args_str = match.groups()
    kwargs = {}
    if args_str:
        try:
            # Esto es un parser simple, para producción se necesitaría algo más robusto.
            kwargs = dict(arg.strip().split('=') for arg in args_str.split(','))
        except ValueError:
            print(f"ADVERTENCIA: Argumentos de script mal formados en '{script_string}'")
    return name, kwargs


async def execute_script(script_string: str, session: AsyncSession, **context):
    """
    El corazón del motor. Parsea el string del script y ejecuta la función correspondiente.
    'context' contiene las entidades relevantes al evento (character, target, etc.).
    """
    if not script_string:
        return

    script_name, kwargs = _parse_script_string(script_string)

    if script_name in SCRIPT_REGISTRY:
        script_function = SCRIPT_REGISTRY[script_name]
        await script_function(session=session, **context, **kwargs)
    else:
        print(f"ADVERTENCIA: Se intentó ejecutar un script desconocido: {script_name}")
# === FIN: src/services/script_service.py ===


# === INICIO: src/services/world_service.py ===
# src/services/world_service.py

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.room import Room
from src.models.exit import Exit # <-- Importa el nuevo modelo

# Mapa de direcciones opuestas para conexiones bidireccionales
OPPOSITE_DIRECTIONS = {
    "norte": "sur", "sur": "norte",
    "este": "oeste", "oeste": "este",
    "arriba": "abajo", "abajo": "arriba",
    "dentro": "fuera", "fuera": "dentro",
    "noreste": "suroeste", "suroeste": "noreste",
    "noroeste": "sureste", "sureste": "noroeste",
}

async def get_room(session: AsyncSession, room_id: int) -> Room | None:
    """Busca y devuelve una sala por su ID."""
    result = await session.execute(select(Room).where(Room.id == room_id))
    return result.scalar_one_or_none()

async def create_room(session: AsyncSession, name: str) -> Room:
    """Crea una nueva sala en la base de datos."""
    if not name:
        raise ValueError("El nombre de la sala no puede estar vacío.")

    new_room = Room(name=name)
    session.add(new_room)
    await session.commit()
    await session.refresh(new_room)
    return new_room

async def set_room_description(session: AsyncSession, room_id: int, description: str):
    """Actualiza la descripción de una sala existente."""
    query = update(Room).where(Room.id == room_id).values(description=description)
    await session.execute(query)
    await session.commit()

async def link_rooms(session: AsyncSession, from_room_id: int, direction: str, to_room_id: int, bidirectional: bool = True):
    """Crea una salida (y opcionalmente su opuesta) entre dos salas."""
    from_room = await get_room(session, from_room_id)
    to_room = await get_room(session, to_room_id)

    if not from_room or not to_room:
        raise ValueError("Una o ambas salas no existen.")

    # Crear la salida principal
    direction_lower = direction.lower()
    new_exit = Exit(name=direction_lower, from_room_id=from_room_id, to_room_id=to_room_id)
    session.add(new_exit)

    # Crear la salida de vuelta si es bidireccional
    if bidirectional:
        opposite_direction = OPPOSITE_DIRECTIONS.get(direction_lower)
        if opposite_direction:
            return_exit = Exit(name=opposite_direction, from_room_id=to_room_id, to_room_id=from_room_id)
            session.add(return_exit)

    await session.commit()
# === FIN: src/services/world_service.py ===


# === INICIO: src/utils/__init__.py ===

# === FIN: src/utils/__init__.py ===


# === INICIO: src/utils/presenters.py ===
# src/utils/presenters.py

from aiogram import types
from collections import Counter

from src.models.room import Room
# La importación de Item ya no es estrictamente necesaria aquí, pero es buena práctica mantenerla
# por si en el futuro se añaden más funciones de formato relacionadas con items.
from src.models.item import Item
from src.db import async_session_factory
from src.services import player_service


async def format_room(room: Room) -> str:
    """
    Construye y formatea la descripción completa de una sala para ser mostrada al jugador.
    Esta función está diseñada para ser fácilmente extensible.
    """
    parts = []

    # 1. Título de la Sala (en negrita)
    parts.append(f"<b>{room.name}</b>")

    # 2. Descripción principal
    # Usamos strip() para quitar espacios en blanco al inicio/final que puedan venir de la BD
    parts.append(room.description.strip())

    # 3. Items en la sala
    if room.items:
        # Ahora llamamos al método .get_name() directamente desde cada objeto Item
        item_names = [item.get_name() for item in room.items]

        # Agrupamos items idénticos para mostrarlos de forma compacta (ej: una moneda de oro (3))
        item_counts = Counter(item_names)
        formatted_items = [f"{name} ({count})" if count > 1 else name for name, count in item_counts.items()]
        items_str = ", ".join(formatted_items)
        parts.append(f"\n<b>Ves aquí:</b> {items_str}.")

    # 4. Salidas
    if room.exits_from:
        exits_list = sorted([exit_obj.name.capitalize() for exit_obj in room.exits_from])
        exits_str = ", ".join(exits_list)
        parts.append(f"\n<b>Salidas:</b> [ {exits_str} ]")
    else:
        parts.append("\n<b>Salidas:</b> [ Ninguna ]")

    description_body = "\n".join(parts)

    # Envolvemos el resultado final en etiquetas <pre> para un formato de monoespaciado
    return f"<pre>{description_body}</pre>"


async def show_current_room(message: types.Message):
    """
    Obtiene la sala actual del jugador y le muestra la descripción formateada.
    Esta función centraliza la lógica de "mirar" el entorno.
    """
    async with async_session_factory() as session:
        # Usamos el servicio para obtener la cuenta y sus relaciones precargadas
        account = await player_service.get_or_create_account(session, message.from_user.id)

        if not account.character or not account.character.room:
            # Esta es una salvaguarda.
            await message.answer("Parece que estás perdido en el vacío. Te hemos llevado a un lugar seguro.")
            return

        room = account.character.room
        # Usamos nuestro formateador para construir el texto de la sala
        formatted_room = await format_room(room)

        # Usamos parse_mode="HTML" para que Telegram entienda las etiquetas <pre> y <b>
        await message.answer(formatted_room, parse_mode="HTML")
# === FIN: src/utils/presenters.py ===



# === Contenido del Directorio: alembic ===

# === INICIO: alembic/env.py ===
# alembic/env.py

# --- INICIO DE LA CONFIGURACIÓN DEL PATH ---
# Añade el directorio raíz del proyecto al sys.path para que Python
# pueda encontrar nuestros módulos (como 'src').
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
# --- FIN DE LA CONFIGURACIÓN DEL PATH ---


import asyncio
from logging.config import fileConfig
from alembic import context

# Importaciones de SQLAlchemy
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

# --- Importaciones de nuestro proyecto ---
# Ahora podemos importar la Base de nuestros modelos para la autogeneración
# y la configuración (settings) para obtener la URL de la base de datos.
from src.models import Base
from src.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line reads the ini file.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# --- INICIO DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---
# Aquí sobrescribimos la URL de la base de datos que está en alembic.ini
# con la URL real y segura que se encuentra en nuestra configuración de la aplicación.
# Esto centraliza la configuración y evita exponer secretos.
config.set_main_option('sqlalchemy.url', settings.database_url)
# --- FIN DE LA CONFIGURACIÓN DINÁMICA DE LA URL DE LA BD ---


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection):
    """
    Función auxiliar que Alembic ejecutará de forma síncrona
    una vez que la conexión asíncrona se haya establecido.
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Usamos create_async_engine para crear un motor asíncrono
    # a partir de la URL de nuestra configuración.
    connectable = create_async_engine(
        settings.database_url,
        poolclass=pool.NullPool,
    )

    # Usamos el motor para conectar de forma asíncrona
    async with connectable.connect() as connection:
        # Una vez conectados, configuramos el contexto de Alembic
        await connection.run_sync(do_run_migrations)

    # Limpiamos el motor al terminar
    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# === FIN: alembic/env.py ===


# === INICIO: alembic/script.py.mako ===
# alembic/script.py.mako

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${down_revision | repr,n}
branch_labels = ${branch_labels | repr,n}
depends_on = ${depends_on | repr,n}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
# === FIN: alembic/script.py.mako ===


# === INICIO: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===
# alembic/script.py.mako

"""Añadir tabla de salas y relacionar con personajes

Revision ID: 0ef01fb3f572
Revises: fa1ad5c778f6
Create Date: 2025-09-26 14:16:28.789417+00:00

"""
from alembic import op
import sqlalchemy as sa
# Importamos JSONB directamente para ser más explícitos
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '0ef01fb3f572'
down_revision = 'fa1ad5c778f6'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('rooms',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=False),
        # --- LA LÍNEA FINAL Y CORRECTA ---
        # Simplemente usamos postgresql.JSONB sin argumentos adicionales.
        sa.Column('exits', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

    # Paso 1: Añadimos una sala de inicio a la tabla 'rooms' para que exista.
    op.execute("INSERT INTO rooms (id, name, description, exits) VALUES (1, 'Sala de Inicio', 'Te encuentras en una habitación vacía. Es el comienzo de tu aventura.', '{}')")

    # Sincronizamos la secuencia de IDs de la tabla 'rooms'.
    # setval coge el valor MÁXIMO de la columna 'id' y lo establece como
    # el punto de partida actual para la secuencia.
    op.execute("SELECT setval('rooms_id_seq', (SELECT MAX(id) FROM rooms))")

    # Paso 2: Añadimos la columna 'room_id' permitiendo nulos temporalmente.
    op.add_column('characters', sa.Column('room_id', sa.BigInteger(), nullable=True))

    # Paso 3: Rellenamos todas las filas existentes con el ID de la sala de inicio (1).
    op.execute('UPDATE characters SET room_id = 1')

    # Paso 4: AHORA SÍ, modificamos la columna para que sea NOT NULL.
    op.alter_column('characters', 'room_id', nullable=False)

    # Creamos la Foreign Key constraint al final
    op.create_foreign_key('fk_characters_room_id_rooms', 'characters', 'rooms', ['room_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Los pasos de downgrade deben ser el inverso exacto del upgrade
    op.drop_constraint('fk_characters_room_id_rooms', 'characters', type_='foreignkey')
    op.drop_column('characters', 'room_id')
    op.drop_table('rooms')
    # ### end Alembic commands ###
# === FIN: alembic/versions/0ef01fb3f572_añadir_tabla_de_salas_y_relacionar_con_.py ===


# === INICIO: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===
# alembic/script.py.mako

"""Añadir columna de locks a las salas

Revision ID: 214d8e14dd0c
Revises: 0ef01fb3f572
Create Date: 2025-09-26 15:53:15.686873+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '214d8e14dd0c'
down_revision = '0ef01fb3f572'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('locks', sa.String(), nullable=False, server_default=''))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('rooms', 'locks')
    # ### end Alembic commands ###
# === FIN: alembic/versions/214d8e14dd0c_añadir_columna_de_locks_a_las_salas.py ===


# === INICIO: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===
# alembic/script.py.mako

"""Refactorizar items a un sistema de prototipos

Revision ID: 57531370cbd7
Revises: 859294539439
Create Date: 2025-09-29 15:08:58.627342+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '57531370cbd7'
down_revision = '859294539439'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('name_override', sa.String(length=100), nullable=True))
    op.add_column('items', sa.Column('description_override', sa.Text(), nullable=True))
    op.drop_column('items', 'name')
    op.drop_column('items', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('items', sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('items', sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
    op.drop_column('items', 'description_override')
    op.drop_column('items', 'name_override')
    # ### end Alembic commands ###
# === FIN: alembic/versions/57531370cbd7_refactorizar_items_a_un_sistema_de_.py ===


# === INICIO: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===
# alembic/script.py.mako

"""Refactorizar salidas a su propia tabla

Revision ID: 859294539439
Revises: 86e36c04c6ba
Create Date: 2025-09-29 14:00:51.980470+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '859294539439'
down_revision = '86e36c04c6ba'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('exits',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('from_room_id', sa.BigInteger(), nullable=False),
    sa.Column('to_room_id', sa.BigInteger(), nullable=False),
    sa.Column('locks', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['from_room_id'], ['rooms.id'], ),
    sa.ForeignKeyConstraint(['to_room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_exits_name'), 'exits', ['name'], unique=False)
    op.drop_column('rooms', 'exits')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rooms', sa.Column('exits', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.drop_index(op.f('ix_exits_name'), table_name='exits')
    op.drop_table('exits')
    # ### end Alembic commands ###
# === FIN: alembic/versions/859294539439_refactorizar_salidas_a_su_propia_tabla.py ===


# === INICIO: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===
# alembic/script.py.mako

"""Crear tabla de items y relaciones

Revision ID: 86e36c04c6ba
Revises: a22657129f16
Create Date: 2025-09-26 16:39:11.782360+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '86e36c04c6ba'
down_revision = 'a22657129f16'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('items',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('key', sa.String(length=50), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('room_id', sa.BigInteger(), nullable=True),
    sa.Column('character_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['character_id'], ['characters.id'], ),
    sa.ForeignKeyConstraint(['room_id'], ['rooms.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_items_key'), 'items', ['key'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_items_key'), table_name='items')
    op.drop_table('items')
    # ### end Alembic commands ###
# === FIN: alembic/versions/86e36c04c6ba_crear_tabla_de_items_y_relaciones.py ===


# === INICIO: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===
# alembic/script.py.mako

"""Añadir command_sets a personajes

Revision ID: a22657129f16
Revises: 214d8e14dd0c
Create Date: 2025-09-26 15:58:15.017870+00:00

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a22657129f16'
down_revision = '214d8e14dd0c'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('characters', sa.Column('command_sets', postgresql.JSONB(astext_type=sa.Text()), server_default='["general"]', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('characters', 'command_sets')
    # ### end Alembic commands ###
# === FIN: alembic/versions/a22657129f16_añadir_command_sets_a_personajes.py ===


# === INICIO: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===
"""Crear tablas de cuentas y personajes

Revision ID: fa1ad5c778f6
Revises:
Create Date: 2025-09-26 13:49:20.291761+00:00

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'fa1ad5c778f6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    accounts_table = op.create_table('accounts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('telegram_id', sa.BigInteger(), nullable=False),
        sa.Column('role', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_accounts_telegram_id'), 'accounts', ['telegram_id'], unique=True)

    op.create_table('characters',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.Column('account_id', sa.BigInteger(), nullable=False),
        sa.ForeignKeyConstraint(['account_id'], ['accounts.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('account_id'),
        sa.UniqueConstraint('name')
    )

    # --- INICIO DE LA SECCIÓN DE SEEDING ---
    # Aquí insertamos la cuenta del administrador después de crear la tabla.
    # Usamos op.bulk_insert para añadir datos de forma segura dentro de una migración.
    op.bulk_insert(accounts_table,
        [
            {'telegram_id': 1648877346, 'role': 'ADMINISTRADOR'},
        ]
    )
    # --- FIN DE LA SECCIÓN DE SEEDING ---

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # --- SECCIÓN DE SEEDING (INVERSA) ---
    # Si hacemos downgrade, también eliminamos los datos que añadimos.
    op.execute("DELETE FROM accounts WHERE telegram_id = 1648877346")
    # --- FIN DE LA SECCIÓN DE SEEDING ---

    op.drop_table('characters')
    op.drop_index(op.f('ix_accounts_telegram_id'), table_name='accounts')
    op.drop_table('accounts')
    # ### end Alembic commands ###
# === FIN: alembic/versions/fa1ad5c778f6_crear_tablas_de_cuentas_y_personajes.py ===



# === Contenido del Directorio: scripts ===

# === INICIO: scripts/full_reset.bat ===
@ECHO OFF
CLS
ECHO.
ECHO ##################################################################
ECHO #            SCRIPT DE REINICIO COMPLETO PARA RUNEGRAM           #
ECHO ##################################################################
ECHO.
ECHO ESTE SCRIPT REALIZARA LAS SIGUIENTES ACCIONES:
ECHO   1. Detendra y eliminara todos los contenedores y el volumen de la BD.
ECHO   2. Reconstruira la imagen del bot y levantara todos los servicios.
ECHO.
ECHO Las migraciones se ejecutaran automaticamente al iniciar el bot.
ECHO.

PAUSE

ECHO.
ECHO --- PASO 1 de 2: Deteniendo contenedores y eliminando volumen... ---
docker-compose down -v

ECHO.
ECHO --- PASO 2 de 2: Reconstruyendo y levantando servicios... ---
docker-compose up --build -d

ECHO.
ECHO ##################################################################
ECHO #                ¡PROCESO COMPLETADO CON EXITO!                  #
ECHO ##################################################################
ECHO.
# === FIN: scripts/full_reset.bat ===


# === INICIO: scripts/run_migrations.sh ===

# === FIN: scripts/run_migrations.sh ===


